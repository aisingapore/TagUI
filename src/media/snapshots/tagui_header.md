**Prettier 1.18.2**
[Playground link](https://prettier.io/playground/#N4Igxg9gdgLgprEAuEAdKB6DACAigRgDpsB1ACwE9sBLAZ2wDMIAnAWwEMYZqoBzRlthhk6jagBs42WhGys4tWnAAm2AK4AHAPzYAtDRgByemGZxOK7NCFkpzCO2Xos2AJINsFCGuwB3drBCsgDWUBC+cixS+mRcGrRIWLzUwmoARoSQrBjBcOLsaXBm3ABuGAAq7LwAqq4YdLRqChgALACcAAzozji4AEzErvTCRVLs2IXsatwM1JYlRbTU1kzM2OZLRdglc748-IIqKfs6+hQK0lDs8WQQMBN54T3YsTDxiRjJqRlZOXkFo1KFSqtQwaXEEDSGA4tHgzAwtGYYGhR3YCKuNzutAwMCqamoAH1bI4ioRWE4oM8AB4aThkARrSEAKzgYHu1GUCBm1DAnGWlKgJXYaxptAAbBLsABebBmACO+LMAApDLzaBoioYAJSEJSSNkADQACnSANzdTA4diKai8KDYWnMdjyOHDWQafC6DRtbbC6gFSS0dBCtYe6XYNUa5iZcTUQhO3yEXhwGBKjpa02+0N9cOR0lgWPx9iJ5Op-AZrMOgDMuetUZjcYTSZTSr6GeDwodLVr6vzhabpaVVYrIYdAFYe-WC43i83Uy0R52NGLJ32ZyWW2P24KlwB2VfR6dFjepsWL0MADgPDePc6Vu-PDp9Mrzh-7s8HF+3z1o7AW0lxZh7m4eQgjkDY1DMdYqVZaZ+SEah5A7NYphgCAOG4aACVhYUYAJECpBlAARCxCDCXwlQrV9CFZW4VVQdAAGVygAQQAJXKPRsFQ9C+WsHCgMsfRDGwABqbASPgSjCDQgAZCBeUkRiYGYfZKO-S0aCgY52FjJQENA1YDKKSjGDUKA2X5ZDjOYbDALwgjw0kuAyPCSjzQFFweFmbSYCoSAoBwwIjLUfSeAZbAIQgeJrO8ngUioGV8A6PoWg8554u4XS6CkTkGCmcR7l4CE0l0rN-XBBRrIVOY8NYCBOXDfLxCUTNR1-BZ8LgKk8Mgcz7hlDo2s7WgMQJRCqjgAk+sCQb0s0mbXQilT2DAYJ9nAxRJvocLmAAGgdChhGgA6lmCNRYwOsAyHsUCeHgXgnUwwLrNsxbwyGysNAoabvFm7BPva6hztjX7+o+4a1mu26po5CGLRcaH0KkAL4B6iKGCdUCyACZRYz4bioFUQDSzhoyNGizQXlx-HeGspH5F+2BuoG7BDGUBS1HkWBDEhiMbuR-DhVJ1QZUMXmEZwEMKsDMCVrWxgsakCAGAYJR2Q8MBILMQJUZZmh6D2YRwvGTHnTgayzcZ2E4A0AkVbVlMCSpCHKytqabbth31YJRKAY80cWFtHhdIJd27Nt+3VZ9l25srIPkiucQw6ViOvejp2-aGyXyoDKQjOtYIANtsDVrAW37lCrYeA0aZrMLgkzEaQrw3F+aXAAKUYgB5AA5XPKrA2lFAH2X7tkNJ7F8JQ1iI7uAFlrI51gCSZGR7RlYAAF8+eXxuFAu1m25z6W84ixwhQsqRQsmqwPGuahi40euNEJALZn4TeXVuZQkEMABxAAouUQwB1iScmYEgAA2gAXQOmkBqFAkDbx3ifP0ed6AF1foTVQzBzJP3oN1WCz1ZQH0Ki-QkTdD6t15pWB+q917hm3nzPBUB97NyPrQ0crCGHWE3qgzyUt0GVUwYINiODsBGiOrce0904CPT4vaIhWsSFUPITuNYtk1GcJYbwje2BmFfR+tomhfNvp6KYQI548si6FETroHydB6TggUsEURaw5EKOeoQ-g+hvoHX2rKcyB0dhLBOtgNeB1l6xUChyKa5iXEKzjqOHgSxOSNwJIkouyTOypLiY3cymSIRJP9jEtJU1Qn8iKa412KTYnpLXtUkpgNcn1KmnvLJ8NBHYE5HCVgPApC3AiBwKA-k6ykhGPaT2bppDrWflABg5lLLWHgJICmQECTKDoLiK+SpVm2xYHVYUuRmBagMVALmhRbJoSJNFLp1APB7LyAcjZHBmAnMIDwTkVJu4MBVFAgAQmxQBLEADSBJGKuH-r3FiskYHamwAAPj0OWAxRklT0BfOM6M0zCCSD4MIXQ+BMz0ERXHWguhdBnOAOgB52AlTUWmVA2gMCZIQGUqpPgpkpQyiVKgEAiyLIkNMsAVYBIop2yWHaMqYt+WiX2eso57yiiiX5bzLe-KtRanQMAC5rArn4QgLcjQ4ZaCZknuYYIpot47y3tgFwShhTXQmKtYI-hmCqC2WYZZ9ojIWvYEXT26A8hhUeQqw5BI3kfK+d1X5-yADCfdyiuF7tUQBEKoUwrhQi5FRLqXosxRGbFup4AaBJdgAAPFi3sOLS20DxQgXghLiXSFEqJaltLHmMrrcy1laEOVqTOTy+l-LBU+vpfmlg4qIDRWwraJOrc5XhtecclVarrWau1VAXVlyiiGuNaa81ZgA3Wp3vanAjqkT0lWO6z11BvUkKMqjHgTQn6dvpXqg1NzbgmuHemNFggMXXlxfiptZAiXlrJf7aQlLqV0oZcWplLK2UDq5UOmU6A+UCqWcKydtkJVzuleIRdIB5XPMVZG1d0YzAaHyOXBNSaU1pozdC2F8K9qGEBcCsFLGs3wq1KqkA6rN06s-Xu79dyZRmomMeq1NrT3nupkTSQ3F6D+qLnSsIT9IpwAYMBWQz6LkWygCGuwKZIL2k+vBpUYnrlGp-VxbttsznIv-cUCzH7d12YPfoJzGgKymdITADzQ0NXdPgNdWQY7H2CBxspjaNUUxWA0M9dA0X4IRborRI1sJOW8Dg48gAhIluqDU4DUsU6waYYwEHTCQOCAIwQDryIipyWgwQ0Imp4hhKy2lHlKmy3ZPL0oxYFG8DAer+QoBF30AxKACKAA+C36WDdyxtYdhg5tjbqw16bXFtRnOotllU2oPKBfg7iXg+JxUBCu5NNl8lfBFHjdaOA3KxaNr0mQBFR3IsDci0N-Y25AvAFHCtQK+R4DKEBwTGU4PaCQ7e6tlS+wONoVAZd67U27vJge+EZ7r31KZl+3ReHiPodrb4NuC7ToIcWApyjvgnyiaxr+YYQBbE2Ld3EfoMnij1h8AGQiwrw681FprTRKkKR3I2qCxZjd3SjJVe4ATbLWkhAKHuN1-ntBTDUBS0GBZOH4LKC5qwH6x3lcqBh-lgx7nmBQAV88IyHUNpo3ZAslgPWVlRYkMZ9L-E-xTXd0qWYkgCRXHkHtbyRr3fUtHMoaT8GGAQl8ASWkwhmffLjYYDAwvReosT63PPmZAtF9lQxVAEs+v0sK2HqakfysGI6sHlmYNYBtszPXiP5smqp-T3SMSPT6DiUMO7kS4kW9dR6u3mAKHGe8FMqPmSPVhMaMYIW+Uio3uGDVqdjfhBfCqSkt3xvB0Y-T5gAdQwvhTthed4Ia4GoiZu-1jHtg-O0JiEkGl431gn8IDQ4h6n7mzR6e6X7x6diJ6ZjJ794Z5kBZ6s4qh55nIi4yhi7l5swl7rAtS5SFqbaV7V7wZ15+497yAFb0pT7u6z48r-pUFt6LSd6KY8CmBwDcwawAzNa4HqD6S-igTvRf4AFExpakGN597hAD7CBD5F6j7j5D70Ez6LTz55ZL5swr5GAK6jhqzhhb73o7574VhqyH7H5vYgFR5aRMCX5D4EHMBzagJszsB345wu5-gbSjTXC0C3AwD0Aqx+BwBpBLDwBgT16-5CrwTuF2wTTJgioJ5J6PIp4SHwGIE-Js4oHYBoEopnKYG560Jl74GV5V4eQRHjQcDJiz5MH272ih5wGD7iQyFswRET6XDXAlGTSz7KGDrWGEAaB8BOGK6CCu4Ey4iDyYzoR+EBEpBSBf4hFG5hGB6dTDGSCh6iGgF6ishoSnIGKxEwHxE1GZ4xopHIH57oGF74HYF5GLqEEeTEFmFN7AAKG9R-QwBMG3HiFp7wHSEj5syLFwBNEPHtH9oL6qGGCZC0AlBr7cISHKCcDjAYZoAgB8w-HTR5DEZwn8p8zaEyi6HKi760D75GFH6THLHh5n5sz2E3774uC6T+AUD0BNxJYzHEFHZS6wi0AYrPJsgsBnJLaUEckbEdFobJE540iD5rGcmQJsxag8p5pnKVGMC6StSKbdQpA0AeA8BCixgUjwZin8mAkqE6igZSHDr4BnjSB8mCBiy5HcE6kWlmn6i6nspAk6iNABFAkmkVguCljYAinCBpaAZIlTxSgtoBnhBVrJSpSZghm+BtrUpTybIwnhj8rokRR7J5y-TiBBmRlpmQDiBhkpRpRCDZkQDiAxkGLoBInlziColsxKi1l-HmlrCj5YAqRahQJNFRnWEwLNlkBahNGGALa0IuBpD4jiCqCVnEY+n0g2lrBf4sHiBqCcjlnZkoliRix1nyENnWHNmnJtlD4dmj5dk4jKBaq7niQVnFmdmDk4AIJSEwCqC4xCCqDPLsGG7wbMnbJsmigShiipmVTIlVlaqylQkJlYnAW4jWH8p7RqpD7UQMApjXTlAsxKhfkSi-nh7jlaoySqSsDuTBrcHqbWrMEeCXrXQbRGQ-ERgon0B7L0gPl3lnKiBhD3CNBgDlyKCLLiAHTgQBCEJEx3yyjhAGykKrS2BamPJxnQm4i6jpC5Zph7RtgjZsyQUIrAASUgUCVp6SXsDSWunMCtgVhqXgWiSypCaZhCFAFIW3F7SGXsAZhhaBZykqRNAKZeQeCbYgAcZCVMUCDmTKAHTyA8UC6qC+EUWiDHrXSWDWg2CjBeUGYrlMC+Xq5TzOGCB84q78BVaFTUC6DY5qC3wJHTz0pZAvnq5pUuQaBkD+ahHjplUYp64pbioDJ7RerrH8h7S5WTSQFrACR4S5AUC+AsCYHoD9nThrQLa4gaALb1QLALa3ALDMDjUUAagLZchFALY6kLaRYQBKALbHrKALZwUwDXTrVDILYaCcowDrVB4rWRYLam6sCTWEnwDrUYjjV5xTXeA7V9UILCj7WGCqrzb+ApALaxgzUcy+BQAQiOALaaBQ37Vw27WshwDUAzXuxnWUyTUETjYLYPx3XoQLZrwLaVLQArXcEPKk07Xk2rALa+AiCSCbW2BjXV5g45a2zCicBTp9UDUer4GI3Q2HXHUt4g0OD7X3WPUmEvXXBvWVR40Q0I3erI2o0sADn1y0DYRs1PSc1wD9WDW81+TLWrULUbVbU7Ww0i0DkYksAEZc262twHW3QW3WQ9VMxbLeIEg208123nYMALZU3K201+4M2sjBAW2VjO22DiBRju3a3c3ZE3W3B3Vczi2TGO3r4BSu38hq0e1x31RQTCABBWBrBwAKgKlBAfV51xaF3rAl3EZoQLaPTmBwg2AF2HA11uj13HpN3532it15W10QCzW2i2AzmV292l110iC8DD3N091F011l2BjDCj1z193t2L0z1V3F190L0KAzwb1j0tQ72KBbDd2b3z112p4n3L3V2r0L344j0t0r1lR1251TFxYd2N1X0BCD1T1f1QAg270z0APH0P3-2X2gMLbeVb3j0D1QPn0D3QOH112INl3eWozsCpKQN3ARjQC4g8CbW4MYOBQEOwBEM41EwLbK3M2dgR1R3Z160pBLFagw3MDiCUTjVIXMMER6XMOLTsPnUKBcjsOVKVTsP1RVwEj-WGBUgUBiOfVTRSNUhyMSNSOyPMNXkyaWrqAmriNKAEgvB5BRhmRzGBSlwlAQBwz9I4S5D2go68DJjDZpBUCY6EiOhKDdGVWqbSDAwXSPznUKSAMmYqAqBO2sjQCJ7R062e1izrVhNEy0CxPp2h3tT2Tq3p1Z0x220xNA2XVY3TCp3EG66qQNX4xSA8lFP654SlOKXiyynmYO5knXFFYtXjo8ktMkIbYIpyns6c7c5cRpXwSNoDI9J6HjqOjmxN1WNLC9FNO14dXJjYA8nzOESWl1PBYNM9Nc485CC04I785DMmaRS3Z5ULPjMuhbBTP7BEGPIVMlPDOdOLPLa3NVP3MV62HDWPPSD1UvOHMbZ2FrMebPONUmYBydijGwDYTfPAtTRymWk7GUFQulOZA4zMAsSpj-p-PDVnLgt4RAulP7zrP6IEHzagtrClRrSQvFM-Mwv1NEu0LamIsDI6WyVi6YvzZnLkvBCUuVPQsEseYV4kvoDtPwQyjCvQB45PbMAvZKC4U15Khiv2gZFj4QAiQABkqrIzD68ESroxrAXTtLbMHOWz-TuzkOgzguhzCrcgoU9whQYEggurtC768rozHTYsjrXVOD85rAbCur4YLao4OZXMbCX+c0dqIOgbxZwbKcYxOSUMUbPrhq-rCuyz4YyzErBOMrj4yzs+XS2xqp9KBVkhCBBxOeaRGRGBZxVp+k2RBR1DawOb9ercyzeJnxQ+qby+YAYJXCYLm+W9ehKoBhszSode9ayprJSojbfuWqcuGzRrfTvOpr+zFrUgTRHbahXbJQ3+UglzMzOB+kNK6+ObCYTU9ae1k7xzbR9eFY8Gx7s4pbbODE7z7L6RBeW6o4ObWlabl7ZRTY6osYqYGAT7c2GAOoHAGgoef+UAk7AysZBrSL-70uoCd+wO3BH7P77S6ld7iYiHgHIHYH1wkHJjMHJmcHhLkUTLuHKoHGdl24Ob70Mon7MJDaBK4GxKzrhWTHuIUC9HTxMCUCHQMCnzXH7APHGHs+-HgnNTCKvH-UlKCueL9zbMUCzE7E5QBI3cAAYgSLJCmoAvCqJIpyZlhYhJRKJJxoAr3ERBp9p7p73Ppz291ak7Ha3FAr3N3OpyxIxJCtCoAkRPCh5OivR4zdktgC2sF8HZWox+J4tJmBF2tKWYe9qak-Q0KWzgOaJCJ2J3wCc1NBFWtJJzAuZwOagW+2WXK87S50q25x5wSF5z5-Z-5z9rgy+nAMO3VVS9C2l-8qpxxDZzp3pwZ1l-F8EPx0G4m7q0VyJMcZkZ85hkZy5A+z16xH11pwN-Z0N+J1pdlzjnlyF2Nwm767dFN1ApZ9Z2t3Zw56VycVqugJV4Nd+zl20dtyN4V6S6QsmLHNgCZhEGxPIoAjSPRJXipyt+pxd3pwUZt092US9zF-t1AuN0d+hFN2zBxrwKdnd4y7818510izRnRm9mYJ9xxiD2p-15d1D7t-Gdx69wj4d4aijxj+vkT91OGD99gH97wADxBwQQxKT6t7ZxD5XpT7l9T6J7T4jzG6wFNwUad1Z+T0LwxOxoYOj9uAt6aljy5Pj6tIT-It1CT712D4Lxt-9cN3D8HQd96yGxACd2dwryb3ZXhaGkVeE8cNABk1E4nt1-2ab1tzCTt6L-l6NwJ1NyV6+zd+V8l7hASC5xtkHypaOMKE6D9Or1Jpr7qLRkhyV+9yz19+z5z9zyqGzJl37zT+bwV3T1b1L4z2j0z0n+wCn5ryH+GPX437jwMiH-GLbAT0qLn55b79D5h2X4P9NPD5L2hIz2r5ry38wMn9y3c8Z0yBY9Bz747yZmTf1vdx6uH8p+555955mn5-xtgOq5Qak+nW74FJE7HfWktz74Z854NcVzNzKTqtwnr3n3AL9-94D9NyXyP7DxH5B9Le0bSbuZ1R4q8meqfHHjyzx7d8devfD-v33-5U9ABVPYAZX2jYT9wBd+eyhv15LpNr+utb3hlzN5AD4egnZ-td1m5JdN+j-bftVz351cD+vnJrmclP4YpUmSgQgalzv4Zct+ygKgTv1f7bp3+n3Nnl-w54-8eexfMgegLH708wBvPVAHL3O7G9AEkPZDqryKLT80+7fYztr3ox98-+cgwPgoKr7YCLO8vcHg71PRO8pAyeK2jOjti8CWchxe-qYLaIYDKBq-YQailoFn9o+sfd1iwG1Bv9OwufCQd-y56-9ZBpfcXuX2D6S8lBEA7QZj30GEQYBC-LXvAKMFICTB8QgPl4PMFYCbeOAuyngOd4XsAB-vWnlJw2zo4O0crTgUEIe6MDau9XQ-mwJP4as9krNcZhsSIE80SB-1AQUIIrblgt0oOCIR-yiFSCYhMggfqgNqGJCQBE3Y7jgNr5T8MhGvDIV31owIDjBcQmocP3kEW9MBibSwZKTsHr8qhngsot4KE4bZrQKlZ1i0I2RVcNsNXffg1yP4IoOB1odWgMK1qe9b+bgnPPwPoGCDfBEw27qIJmHiCZQ+faQUXyWGi80BZg84ckI2HTcthOgnYXoNgFMtDBuvYngUJOEJDyBWI+nlcNwH2CC2SoWhnulcHZ50uaI57isKpEV8fBYfWEZH36zvC8InwsWN8OYG-DuhHA52hfzdosikC9-MYTCLfZboeStZAQTv04xMDOhrA4-pKNSZMjbIso9wZCNaEepxhSo9ACqIW7e8pQL-SYeEM0SzCkRkggvoD1REoD0RnIs4RX2xHI8dQJIlUNR2UEqg-RuQnfL2Q4zag8R6QokdjytH+i++bo+4Xt2pEWCbeIYg4fRm1DIcDsp6MLNALjGhjluZPGwQ5wjHpie+VgtQet1LG1MPIcpHFvP2pZ8sHchndPijhwoCZOWjY3lpUSdyaQn0IXDaHSmnJCVJydpdYiwGqokI6AzseAurXtIsB2SC4zYsAG1INkWOYGRSm5gNbNRWobw6ct7zSJ-puSy2JcROOjB39gxW4mdo5TwRtdZ2vqBUm13vz9iHWXyDaIUFhByBOAzqIyMkAWD2hikHNWwrMRqpKMgJGxCgkqBnGTl5x54ydgpGAk3iDWKFH8hBK5LDt3yE7dCacgBYNMcJmYRGCFwihdt6AOE53Pei-FB8Io3UVaPcAwjOpJk-MSLk+kIbxQCYlOOmHKywneFkK8Qb8sgQwAAAqKBAAAEOQUoNVJl0QkbFzO-KfjMhPI6oTBJIk8ScoEklCZpJvIWSe5X4yYTi047XicpNzzCS6epDVJEqDUlQVNJOEuSSAC1AKS8J9oYyVgBEnoMLJVkqSbZPcoOSmeb5AySySMn8TUKJk1SY3g0mm8ZJLAOyY5IfHelgpP5UKWJPCleSopzAGKX5K7QBSPyfE8UCFNclmS8GgUSyWflSnaTopPk2KXKRcmmT3JxU0SaVJslpS7Jvk6nFlIlyGTPyCUlSWJILDWhaAEUrScBIymAU4pNU1SX1MUCDTvJ8kzKUVWykTtxphUohmyVEmTTaA1kyKeVPSmVSDsTk+KXlMSkFS6pq09aZtKGk6TNUek51jxK6mHSepok7gDAEkDTTmpukvaWNO6lJTHpjDOAK9O2kjT9JHUwKXdIElJSTplkp6ZIHOkzT7JVUlCV9OOlsT6pUMuADDLelXS5pCGYGTlKWmiT0EOVAEBmTKnDT3po06qYjNMn4zVI7AQmYUGJlNSAZZMoGfWE6m5SwZSM8yfVIJn5B6Z6MpmZjPJkIz7p4M5GatJ5lEz+ZpMwWSzNJBsylpIeKUiTMukgB4ZSkymSJMVn-TpZqsrGbdPZn5TapYsp5D1EohSyVZrUxSR5iWkQzFZ5siqTLJukLSgpIsgqaJJui6ZtZKstWdbI1liSPZDAL2Q7N1ltT5pOMxaX7IhnuyzADAe2TtMFlWyGmNs42dHN0xxyWp10qABTNdmxBWA4gPog-ihiDiCYdKf8QgEihpShKCVYQqBJIRB98I4EtKVBJglzjpyCE7aXCNXHtTWZIMg2WhKbmJzbGd40vNwXrFPiFc-k8ObxJwmDydmzlRTNRKfQjxyJ-YyifcEXmHAqQdE78UdXpBMSN58bLmW4QXxOyp5oMw2apIknKzg5Pshpk5Ta6nye5uMyOSnI5DpzdpQs8jvfNlnRh5ZfshqebCDnxyQ5s87+Y-Llm9zk5XM1aY1K2k6zLZ+0sBdxOdnnyjpVM9aUApGmgLh54C3+ZApfnQLLJZ06+cAoQVxSkFk8p+RHNdlUzUZmCsmdgucq4LJcz8mhW5JTmoz35CcxBTguQVny+5D0iWfTPoWzTP5HmChd3IgWsKOZRswhdTP9B0y8gXCuGR9NvFMK+FVCl2TIs1mcMRFICnheosoVSLqF2i5aRZLtkkKM5qig1hIrDmaLUFD0gOXotvlDzDFkivBdIovlmL6pAc5RWQrUUPys5O48eS+OElCT0A2AISdgAB4rRsAlQGoK4AMaR0LmKYH+IbkiVAdFcqkQArGC2BiEv8VcZiRSxgBKMGKsiTWK72nG+pU8U4+CAIyUCwABskgdgtOg7kGJiCz5LkK0qQlxTdx9451jOLOi+MmlbBLpTPM9YFA1aZzFvgETDh+4RlLSmeRiT7Y1QcSQ7DjkYTZmTKB8WMGdsABJwQAVQ87bZryCgDeUfIqgKIvnD9wRR6lXIJ+NqBYWpg1+2pHxqDE9hYY7lgQflEPm2VnNGF94hysEtwIK4gV5HeuSUoWVjKm5fYlwJjDmDxY8lveL-NRM6WBARGEgBKDwQ2hoqYAAANToDUBRGW6APPaBEZLFcV3SyCe0qKyUqZ5vS8eQMrVpDLYwUKiFuMq2Kdg-l7NVgDMrVr142VVTGFW7BWXb5B2eJUOSO02W9zuVuy6lAcqOW9MTlAQc5V8hoClFrlKmIyOSqkCexHlypZ5RPJuZvLCQHy-lDquwA-LxIsq50ACpHn6Qx5IKyoVIGmFF1ml0K7SZYDhxKM6Vwq0cJSotXVpWZ7q2AASqWCiNfVnq48h5FcpCBSlD4+gC5Nzn5yzkAVUxvnWAi2AcCoywIIxWwbVy-K0gWQOrGzUtKLV0xJ8c60jX04BSi+dDAdI5nJrHlepQdGcgDWErB4MoPpZmDlLtrw1kgG4c7myWIq1g+SgzE8VLVch6AoUDaItEAQhreJJKqDjg36iCqqVXJGlbXmrXUq5S2cdfNuq9Vxq11SyysJSoY7i4pwTxedTmt4kHro1GUDwJCqcmJrEZTa1NeYHTU4xM1UgXFbFXuAFrToxapLGeonVf4ugcrO9bWvewNr8pb6qDTOxA3gw44vahdbPlhU4B4VOSuYKOuRWyAvST2NIA6FviozsVBMUsOUF+mURalKySjWRw8zURyNtG9DYrARV4xsN33XDdgHw3+EiNCzSCMRhnVkaUw8abWFyGqCsNTI1G+0PxpFRykGNwm0TbAHE1sM1+Q61jbkpw2gQv83GwjbSAWbu4cGzMQIIJv4BwANSeVKSEupMYa5TZdGhpkdnM0WAiOPqWTQaw5hax2ChABBMoAoDM4TMzARCujDaacxPN3m3ze7njS4MuQ1qVTbXIyyIQTIFWFwI5QS04EPClgcKNwPCZqYUwT2cuYpBajWQCIBIf4PEEPW1lnIrkCiFqF0DcM7I0fAiFqAwDJQOg6YSMgltsjO1HIxEUiORHcjkKEtJW-IGVuUB9jSV0gSQLbCVCsBaASWnAPqNLjKBPU-wKgKbmGwSpDcYOQbeRDmHORpIjG+QP1q22MxAC4YYrTtvEgzaPIAdJYudsEoVpjIJWomNSju0RAnREQPbTqAO1vYKhOcaqXtH8gzoPUIceAD4Q8C6MUYkEGQChHoCcSayVIAHb2XQAQ7nYfsUlSKkUyFLjYmCZdZyD6lPRwifkLVQMRNU9IUwrVawOFBcY7L3GFVeZCytNWloVQxNZyT9Ah3yRtJIraJYKDnDzx5GHOxRP1qaLDUZGzscMKLvZ0yT+Qc4A0P1tF1+wJd-OqXeK1LAABNIXUPm6AgBxstcXFiasvwBi-iKkZCj9CpBnJR8nlSfMbvl3m7JSGPeye91F0mIu18FMgHOhBiEhFZxOSQMKHd2+MDdBlFCcYjIQwBmN1UnBoNRB3Kxwd8jCMFDsfw7RmYDjb7l5mR3yMxdXaqDhjpcBY6RAOO6zXjvyAE7+IRO-OCTo91k6IsVSwsldlcbChadlVO7vro+WGAWd3pNnUrs518JudJQXnZ3sF0Vgdd0wP3aDBDyyVFdVcAXc9Bl3qQMwTPUcFSHYTUIZQbjOAK4EaUC03dDOgPVRB92db9dXusaUvsKhh6DWgOyPVcCCK+EIdce5gNDq8aeI8lqeqACjrR1Z65tPBN+qIHG2F72aJCWEBQGJ3dVSdvSCnbIlsZ4g69d+8qo3tiQe604zOwldYAn1KAp9XOwBDztLB87J9yu6DoPumC66R9nupCuPo704Gu9UAOcOrsAqmh59nYYPRwnDCr719qYTfUQZ33e7zA+++A4frlIMHD4zGr0gZr9bTgNAP1bfgMSSwGaUVsYMQw4A9ToBRD4h0WMYxc1KH5DFlHqB-tz3f7cdrIIvTrlL0RQGdlesA6VUgM06YD8yJkrIeUMQFm8zepna3qQM90CDw+7fSHhYgaANAc4eNLYY0PqQ6DUMfw79WP2sw2DHhzhpwd92RHbNPag1uodCPaJQV3BUHC4YQOqgQjHqKwnCSaIKBeQGoTJGyUSPZG48EFITB6RwD5HrgU0AIqZCMhzZLVqAe4PBSb3wGW9berwz4fVh+H9cyhhlFkc0MwBeyv2zyEJPCX2golcO8cj0gTK-hfIOUQJJUXoDjB40jEPFQyAwhQ4AIeWCJVEtEnTL7iC+O1OOTF57HMl42+Y8cD0abt-ybDU41pSaHYBnjimP7hmLGBVkek3gQeAqDuAXAjY9IHMBzHSAqZfjoOiJS8YePqUoTUlf0UBxACfBr8leNAAxAqMQnnjo4AOqDtpDlx40IXTnqzxlBAdUA2IdE0RUopVkxe1MFYzg1YAcADoggdnqUwZMeJvCYgO-fcEED5AqJKLOidXBWNkmXAWJhQDibRnRV7QR+a4NFQFzcAoI3UepWEnANfGQTUgME1VHtAvH4MZJl4xSeThaVveNHJFING1MvGeSMJ7Snf3+ZGmAYJp54zyWFPqgdeeJ4OgSapAyRNcDKFEmL2RbCg0WaYOETqZ1P2mRA2Jp0-iY-7unYQnpyk-qeui+nUw5pjcVIX0B2iNTzxp44GeePmnLi0FcSNmdHzInNsaZ7AGFh1NyavTWldAKEvGN7GpBhLGk2sbxUOIvcnAbY3DozVk6mKFwcYFPHVyrH1j27WswcZ5XN4F8sCO1DZW4hhddAREbiLPwb78VOJ9ATkExQ2hfs0ItZhAJAEahRV+zGx5KpMYuPLrbjU8XvmBVsrldnjsayczjBWP3AfdX4-AJOtgDNYeoToNkBIiuPcB9IswDk8+ZgAQmXAgWZ2r+tEBsEUsVATiRCZSbR9f1vKGykmfpCuYt0OpnQF+ZyjTQwSdxs85pWY6eEHkzylCy8aQBklALOAAKNpPWAiUNKVJgE1OeKrsAITcpBC2YFNz0Z0dZcLmBdGAlXRFN+K3SE0AzPPG5SnFzKsBOsKW7pAAQa43lywvjkGUfFvFQJfKwQmt4p0VJriq3ShKMNggTKP6D0hDik9xeiUykCnKk7Qk29bXKlji38R9dcWRPDjFyDZ6cAmWQ5ZxgCgmZLIQxYtaTv8ZsUWUQR4fPC2qKJE6Qh420VkSrb2q8COZwohGD33sGvdlsUVQO1xL4l60T1HfC411Amr-qiecztToZ3M5sxHGW-I+G332XPCAaTIcfDlajsWFE7MfJAZyse68rtAAqxYaKvjYDsB+TKyqGysM62rHV2vUQcIDdWIxpVpnhzGbyTaIOY4VrRWAqu4wqruQU9l30cD9Xmrg10SPlaasjWur0wZtdhRlzoAbtUgDFHZeWuOWpA1XKTob0pIuXjs7l6AJ5e2Nf4TDfl3epnO0u3L+pa5igJHh5BaRddMyEwxZbKhWXes42lnQgZhtyJYAUEuG0Zrnx3829M3dMMGHSPw2j4aNofEjfgCwASUjhqbfja5Cxa4VggEzd4wr3g3iMkNynYFHgCOB+Kr4NeFJupv+6Pl2+7G9Sm32MFRIw7PmxOuNJnIlr8Ta6-1pcCVXrrVgX1GvKLRVlnW3N5G972KJXLKIOaGgcrYJusxtbXIfYRWLVsaqNbe0I25NCJxhZ82sBUK-sXBGpEIrw+YvNWxisV4GI9bDfDoX7ZrKJVXeDKyYU2u16WrvjIa3teuxFWeAyHNsoZ311KEW1aGczkJ1GH67sbk17cEDHgPO7GmXxma3ACm3zW2tHN0GJnaMLntQ7cYba7tcKsmqxrh1nUO2JOtQAzrlBfXdom95R2hb-UeDQnclKKU80gtluyHu96MRqg8aeNIAm84O2Al0VhlU6pSprBN9r+dGH6xMPRRuAikfmOzTZBbBvUEAO0Jf0tU2XfUruxK5w05VrBoCDIotkkTv7lsyu2Rc4twVrZXFkrnt1ZfoR9uX2x2vcsu0HdjAh2q7Hu9QgdnQD1iz25gZQAHfxC-3qA-9zq9XZKVGA67x1gLKPINZtwfrT6PfYvf-W3RC7j8VezyDKhxn3zTdHe3vesvjaCwXBk+7ZrPtBXL7exEtnbaOLUDK2Tt6e0-bdvvdMSpCN++KvSvGEiSP9iu+1bLujWEHJVikuTZ0vdUUw6VYyONnVwmHaa5cqKOtAJghRH4uK9mx4YS3jY9kg2ngGk2y2esL71t94mFZvsO377ztx267cKIv2sSXt9+-vmTxf2cpwj3KztdEcAPfGxVzudvo6MuGzSMAFiNMAgAkAMGMACjfIH0ftlDHbCLLfE3g3WERjRRYmzzzb05N8Iej6YK3D3IJPjHyTuO3WtGOFytIOkAyyXKMv846LbEdm7ZGlvVXnLGuP7M9bOWtVvLHPB0PYH8uZyrbuxG20w9ZEsO-BkV9h-uxdtKUri8V6h9ciiOOPeHYqtK4YT9tCPqdzAWByNYvHzYJrUj3RE09WtwsNl7jxqxs62fXZow3VmdgSX9tiPNn3j4a5c5rtGA9nZVjyNNfuKzWlQLWgykSCuvVW1rpd8548-ucvOjrpnNfk3d77-PxbgL260J3uuVHWndEdp69csBf5xEn1xQN9ZzjiJPExl1rAmQCC6QjoPIFY3xQ4CkVDme+7SHwAacIHbIPNzdTC+xve81g6N2UuNGRutwOXQ+Jl8jZ7XlEBbzrN6MLaShcvDnP2wifNoBerWVg8tgrUvDiKFtGH4V1h6cQmcXF7H7tnh9iRcerPBHUke5xc8oTFWSe-1MV53ZKdmdDAid0SAK51up2c+acMI6YmztfPc7EHX50K89huuu1YDjaya9BcbPwXSDyFwrmhedbS0YRtu5a4BKOl9S3dhFG+2HbRvI4rdu-sPdHvj3GIk9mxcPMmcz3WoGDh1q7uweKwxi+LmpyQmURwRrA2idm2wfme0PXV9D8x8W3VdjO7HWBWx5w4cfr49Xzj-hze3iKnPeJwbyuxYejASO4RoD9axA8nc+Pp3QD8Nx2OnvdM185Tqh36CGL6w-W1bh6IS7reqIQ97Nnd1ogD10OzHgzix7bZGc5ENX4zsWA-Zrb5Fn7g7lK97YEd9Wl3Tzs1xI7ecFzXxHiBY9lGmb8ACXtT0y5ImkTQB2b5iKVy09cv-IPLnT-gF-ikTHR7Q2LgK2nagIquQrd74Z3KNvsR8bHHD991w9me+7zESVz96-eWdDterdz6nd9FNfp5fNEdoD4+EQ9yuar1zWvNKo8dseKAHH76GG+xZrPjXon8T75vGvixnXQrWQJ66m0+vDosLhy4C4DcLvIHrjMTyG4sMSfrnJndd2Fmhd8e4Xq1hF9gCRcyuUXblsyei+JiyAsPMiHpwExxdM8frbnhm0e-5xGQv2JL8QGS67YSIqXIgGl1wbpdcTxt5iD5eYmZddz6UiXlW3f2+g92Mi-6VLzrdbgZemiOX6LRp-5vDtzEDHCVxp6Q-IupXst9k1RN0jiBlXwVq+5Y+YePvu3FHot-291dfuDXvto11laM8Gep3I1iT9x84z-UyvTxLu3a+L6FeXz+z6yPF5jeZ224HrhHF65+cLXMwy3jNyHqBfgO9PnHuT2G9M8N2LPKfFb4Pbv5R2pv1rxN4OmTf1q+7zrXb3bEzdtfs3Y9ie0+-IWFuwVHmbtaW-nvlu93S93B75-AP+fa3MEFRPBEbeH3GAx9uj6fbbc3vVXQzrt3yM6-avpnXDxZ-q5HfNfx3bJMR+x8M+jfwtq+OdzuMDeLvZPFP67BJ9ndneUHDqtB1u5A80fhswhiH3B6h-yJj3sP+t-aAR+UOErKP1twM4x-Eesfd9qK116o8DutCvXonyx-WdDeTvgHxT-s5fFvkBYjMOGMhYMSKZGgRjIvQszpSdIv8cNfmDDFITk5VD3iAtgzGVhrBwE69Ah5TunVKAKQrv8aCoc+jJbBG68g37DFUB+snznLMCB0CHg0ZhQZe0D5U4VvEZfC-voNP0ST9ZQqnkHmt-BDouu-xiMmcIDPHPdh-NPK1n7Sb5cAoe0X6HsCIX4I0yA1oKYfp720Y+pXmPtzjXyNdd-mudf7zysP75q-HO6rwns5xYb7-XOpPA3o71P8Os8ePnKnjb2p+292-BYI-g-MC8n9h-Tv9dqF3TXOvD-+P6o5vnZ8Uy1+nP6xDFwZjD-jFm-uQGALi+6QNLVATf1xElnkBbR9Nt-+35PBL9bAVNoX6cgJQGhDFk9AP4xoQOZM8B06SSkYy4eNetdh9+sAawgxeYEPZYqY2OoZpaws-FyAheZfjDAIG38A1B7QZzLNoGI-vhyCd4N0uX5wwItuv6MwVXvZ41eCrn+ZKuadLQE8uMoF3B9wJaHlgPIsjMACGAHIIYAkWlAYWqGAxAcoCiB4EMdASBZATIFkBW8JKr++JMCmBwwSrD9icBuXtwE9wvcHwH7AAgUqBCBIgWIG0BEgVIEyBhgJUDMApYLqCAE88LvSTQ5QBAA2BpYOSQKBJFkIFKANoNACuA0gWYGEBagdwAWBTgcmAyBlAcjY2oyLq-5eMX-r+A-+hZLYFJYdKHrDowogBTC1w8yCr4d+37oa6-u1On37jeUduIEze9rpEFOui3hwGEBq3rQifOK-t65r+-vsXZ0+c-rv4me+-pG6H+RVOX4feD7iUHmBZQT3apuNAUEHCw6gaLCrMcUs0GD2LpJxIMovQdd5teidgJhtg9nvTKCURkBgEbQmQZoD0iwACpBUAbbgmB6INuOGA8B+gZxJGBFwd0T16b2DMEcIzLECQPBh8N7wrBokG2A6gZAWSBhB5WPEbkcJwWvBYQnErqCxg9GPgB7QeaAbYICxJsiaIm7lI8pwmBRAUSYAvANZIohmqIRTaS10ANh2a9oOg42oOcIX7Mg6xBFDbB1TtD75+MHsSHu+4DuvSu+9MHf7va2AN3BpALIGyD9affjfrMhrIeyGGqRIXf5SBKxiYDYosgWkqkI7xuwQkSd-lB7WWffp1JNQWetOQf6WyKrCjAgQOSH8ARkGOIPkpEmBBm+iqBMB3AZAPuLriNrgaSNoUhFBjukPQryTLi8Gk8F6UHQHtA2hG2GOLTkJFsA7boa4vaHmhiFopQ2hI4nCxFuQYeOLikDoXMFukZ4O9zTwkaL8G5g5fi3psQ-UAlo0QjmvACgIwAPKZNwipp6HuaXMPrZmaAlk5pu2owg2RySVeBxiiQ-vmkHPEoCBchVke0MaB0gf3I8Hc4REBzh+cBIO5wdhEKDChGgjEAAAStXOUCq6RoIAh7QDYeIDOkGIJ4R3AskJaHfYygSkb6QmJmrTxBt8C+CJhThsmGwAqYUWHzkFgJmHZhu9PyCBBgsLWHmchAAqBFAFAIxANkLEFWR8oVeGWHLiFYY8qGkS4duCHBdDrGFAh+iDcGr6SoLGEbhyYKO70of4evBd8jwa3bmaUgMb5T2Rbo6oluihj+JkAuIXbjAqJblYgWQu-riphqRKipiZ6xHMqHV+F6L3hRU8oSDKvm5cCljShwdBtAYqAHBQCmhvoQ96Ckn4daY2hkomaHsRdao6FyUroWLDuhDZJ6GdyPoeeIOhnEcaSmkoYWt7AWm5FJi8RqGPxGRhKhO6Qxh64fGFbhhAUmEph8gGmHFhGYXtBZhNIDmFnhbMP6rhg+YZ5oHhFmm9ilhhnOWEEEyHNWHl+l4fWEXQnFM2HCArYa8HthnYdZw9h6aIxD9hQ4SOFjhE4VOEzhHhF4SuA8ADhQF2o4IGrykIKgyKFYTeClHdqRbm24AGREX4BfI4QL4boQuuioDKQgBkjgjgHavlF5RUgKfy1RhAFsj-sC5hkRu2YQCZhu2toQ1FMRWKq1FV4IgEtoIAnUfVGl6Y1jia9Rw6G7ZdAhRGeg6qhgMuHOqlYCBHaRDAR7A7h+kS5B2RR4SZEnhvgVACehVkWLBuRhAR5HXhTQMwB3hDZM+HiwTkW+EuRj4FlHjy6UZlHVRmQtlERsI0EYYygewETBFRpYJFoPU1WMoDlRFKlVH9qmQrVFdRo0U1EHCVAH1GGA7URbBV4UMRVGEAPUX5A78btgNErmw0RqwNR0UKtATRGGFXjTR6qG1CvR80d+EXRv4WrT-h5wXoG3B0BsBFaR3-n8EMikEeKyt2sEcpaKU98luhykHMZQZcxg9nBEbuWEc+KoRu8hhGqU4saejzQffnOoLqhaOjqkRwAKb4URJgHhHUR0ELREtGC6iuq5qdJLSwhMzQgeJ+hnEdaGmkPEWxEqR0kGpGCRppG6EfEHoZKRTCEkeGHmxi4QGGyRikVnYKRy4qajKRTpI6FqQGkdZDLRrMQmG6R60XuEGRW0cZGmRCphZHswIWoWHphDkS+G3R54u+FVhNYVFo9Q5nJOFeRTYSaC+Rg9gFHAoQUd3C9hoUSxADhw4epyjh44UXEAUuoLOFeEC4axyUxK4VIBrhcYZHE6RgsHpGxxm0enHHhZkaeHQA54YzCnRN4RdH3hy4o+FsMjkdOTvhFoV3HLh5ZNTFtugsfTG8BQERHEJBbMfBiCx0Ea8Hcx85PBEAw-MQaynxwsY8GixSEQayhYksTiF3Eu6nLEIwUSkOSuoVML4QCMOwJ9TxWPIBpgPUC6p-iyA8pkUAJagQHRZGgmgBqDwAmoPQDzUipooa7+o1KFwqxDZB-qYJEwJBaAEs6mCFFwZmvcqpITNsFQx6hSuDSYAmgBgCYJB0ExJMAWsD4RKIC6qxGSRnsaxxcRVsb0JmxfEXbEyUxus6FCRbMCJHLiYkW7E3MQcfqT+hMkaLa+x8kdaS+x-CbbHOkQiepHRh6CdHFTahgLuEEQhkYeEJxu0bmFswNkWnFGRGcTdGrxLkbnHuR+cXWEtx3kaXFkAfkYVCEAFcV2HBRfYXXHhRjcZFFOJMUZiAwA8UWwT+mDYGtAa2y4atEZG+ifuFjxO0RPF7ReYanGwAhifZHXRr4dnG2J-1HnHMwBcZ5GNhPka4nlxbEB2GVx3YdXEhRYUQ3EEgTcVFFeRQSXOEhJCUeEnMJoUFElr8IOOn4xxBifHG-EiSUnFTxMSbPHnRl0cuKZJWceKRrxEScECdJHkD0m6JcSXHEJJiceZHDJeSe7hXhc8eMnwSK8c5Fu2OoO0lskvZAtFnoQkpkraJyMLMmKhJETglkRwCQrBU28Cd4bk6yCeqq0YN6vzj6ASgFIDxKtQAbCNAUgAADEfQPgB9AVyQZFFMxZOIAsGEAASpf87gL3C52nIBA7KhfMDIxRx1yRDoy66uuimQpLkDil0S-ICqAQ6fOgsDSBe0DIyEACOtSkUAHGIjGgIbWgSlkg8jIQDEp0AKSnyMRoDmEqAoCNSm0pvmvSmGAkgHpigI5YMTi7+RKS5qSB8jH9wPmfKVSm+agqYQDCpoqa84SpL4n37QpVZHCkIpvgEikoph6tgnLiH+gtrja71qYAwp-5lpBf4OwF-wcJHsQInrxm4pbHsCfCTImDoAkSImOxwkc7GiRrsTqjuxDpGolyJSUD7EBxwYf7HnigcTbHBxakaHFaJuETok88yyaPGWJ48UMn7RZiaklz4-SZMk2JbtnYknRDiYXFThJcS2GlJ5SV4lVJPifXERRzcdFFtxsUXcChJiUc6RWpuqbADwpuwIanBMEDqcldJqRosmppG0eknbRayZPHZpmySzDbJYyQvF7JmcYWlV4HafYBdpaEPql9pqKfMmEhAoFyFspHKfojo6+tGjII69KcORcAJ0JgmRa-UGamGMWwBalAafFNLBAJN+qQmwAhuCOkqg6+rrqNRdABnjXQ2BkoCAIAEq84HBS1HAAkWJ6QdBUgJFgjqeAJFvSkTA0wGhDZpF6ahlXQxCTemwAYgVhlPEC0fLFSpbKaWAGgqurckuaqsYpjmpy6tppJYmKeXDMw8bBfoWAYOmGEbEjqSGnBxFseGnupdoZwnOp3qS6G+pYif6kSJgad6HSJcabInSRPGWxm2kSibwQqJnqYKQJpXKGHHr4h8ZuExJw8X0mrJJicnHv8HCJkh-QmBOYlpJ+afsl3RRabkn2J+SY4nlpxSW4lz4niVXE1xNSQ2kNJrcRETNJbaeEmlgAKCZn7AvRlyB-cHIY+DaIqOkwiwZ2APPBhW9gL5SICRmbVjJO6qfy4h6xmb5QZWHIFIQ4AbYAdBIIMWXFkmZiWYfAZZxTncjiQEWclle8tgEPT3AuWVqBnoEWTIz2ElRACgUASlpfFQZd4gtH0ifcaBGZCX6Xoljp-SZmnrJ2aa3ozCSWSZn4Ex0ReGlpIJDskLp4pAWkHJK6XOABZvlEFm5KsAKFmGqlYM1l+wwANFmxZmePFlEwJWYVBlZXvKlmVZ6WdVlZZygDlnYAeWQhmFZZ2cVlVZM2Wygmod2dNmZZhALVlT09WS9mNZ8RkZktZASLSztZnWU0DdZTQJvGwA28X3F0xugfvF3BzMf3FHx4EZjn-hZ8e4kXxTQDSlIoAMLaF3xg9oTkuQVAMhZBpXaLZkGaSrGZmIOBiOTkwRIscpbE5xlIrDmwrrt7BOwVIPZ6OAlCY7AcE4UO7CnWtMVBH3xrwXBGqpq5NznWwMbnzl4QFANaj-BHmKznnx7OZfGEUpmLTk9BJaXZnqiTOfqzkcx2SRbhwfrsrnOw+WRbmpwVuRnAq5AiAD4NM5uZwRvZHQLagnGaEdLFykbuc6Ee5XuYRkwwc4HtnkZz0GeLikd6ckrz2NGXhpJYD6LdgqY1WcKDn6wOpfoXAvhNOQcZLAFJFexbqbaGR5nGbIn2xPqfWrSMomeeKSJ+uUXm55XCZuLyJcmWsBRpyiZGlN5EYRomJp+HmsCaZCzIPGK5SySNl6ZSSaYmTZDov9nxM1kbmnjpUkJZnZJ1mXNkzxC2U4kVpZcW2FlJgUZUluZvibUn1JgSc2nBJvmemAbZgWXwDBZu2esRHaU2aVkPoTCJ1gkWp2QgTnZEDl9kA5nWFqAHQ6qQ-lFZCWa-kpZumMMYHQewE9lkA3+R9m-592d9nAFwgB-kGMdWWAVP5n2ZAUA5QObEBg5pCEZkPorWdDkdZylvDlwAvWbcK9xnYL3mDZ24YPkjxM+QMmTpySZZHX5V2Q9mtwi+XlwLZZ0beHLZGxKtlWZ62f5mn5vAOfkwAe2Vfnj5N+aSGbw9+e9mIFEBRPle87+Z-kAFCBfGBIFMhfWjqpsBdAWgFkhUoXSFpWQ9mH42WT2RgIyNMDmKFz+Zdl4QehagXDGTWellYFUOYSww5eBXPIEFFYD+E7xkud3qARGOaQXIu1EnSgaFEiFYVzmxBZqQPAqwGZiEss6kDpbIGea+SPImuQTna5ROQEWuYZOR4VCxFOUkUuQQRTTkSZBufNlG5jObmkqUCRXPiU5DaHpjy5luUrmO5zsILlLad8CLkFsYuUrAS5eiPjllFWRT9lVF9uTUUi5vsGrlxSpRR0Voxylrrm4ENeTOnowRRR5pcgpuR5jAAX+QrlrRkcNbnwZEhdUWrFtRUhkaFJFgHlWFexc7moOZuUsUB5EhQHm7F7uQcUAwXuUWhSx78QayLFChe7nnFQBQYV7FRhfAU3Fn8XulEZVcKyn-gxERRkNkiOg8nTUO7LHoUwciDORxUjGYuYagYAA8hzAqgCOKCAUJd8p1WFAPKq7+OqbCndpm6QwDIp-abXmnIGKX7D7p-xSRl4pOCT3GVgmKZvDRZ05LbmeAZ6J6RJYkAMxmg63EKxQX6xUCxHJp2KQekypZKRAAUp-KcqlKpqqQynQAAyW1o4RFJe4x4JQJRHlMlWJQ8kKmEiGYAKptXgxlN0WeQiWzAlgKiWhgy-ABaYl2JSHm4leqb2mElRqWik0ldJeSV-F7jFSUklQ6auGdg9JQYiMlIJW9kUArJTgBekHJenksZ3JZADp5fJSynSpEebKlVwPKbvSKpAqZKVqpABeKlUQzpS5CHpXKVXDypGwImUSldKRxjqpaZWrkWgCpS5DAmlUEqVO+JKaqUqh3xipgalD5FqV5lOpYbSLmm5GiWmlHHGqX7KOJZ2l4lG6TaVEl26eimOlWKQZE4prpeimLRC+kdk+ly4syX+l9nkGXRFUeisY8lEZfgEClk5UKUxlEOvGXH0lKUmWFlIqamXyU6ZSHnRlJKbGVKAuZa9jHlBZUKlFl55WsHylGZfGB1Z1ZSannioJWrHJadWY8lFwTZXxQtlr2G2VwlWeZ2Uml90D2UWl1yVaX4lw5XaVulZJROWEpxGSmCkZqFbOWel85SRZMlfpQGVca7JWuWxFYZbyXbl5ZeynCl3KbymPlNKcmUcYqkMDkllq0ayn-FWZbeVwA95b77iljFaeUsVsQCWXvlV5Wyk0J4ebWUglvZYpipZGpdYC6lWwPqWsgSJUaXQVDoN2XmlFAf2Vrpg5T2mIptpcSVjlc5ehUcVLpVhXUlpqbSUmVDJQRW+lBWcuWKYq5ZyXdmm5TEWRlO5RhWcVtFXGX0V-FSqkplYqS6F2UweYKX-FVMMqVSVi5TJUuAqWWBX6QCle2XKViJYaUol6leiVmlxBL2XapA5daUGVI5SoCoV45f3leV5lTADYVM5X1l4VUWXZWLlRFSuWkVLlRuXhl7lVRUflXFRDq8V+ZQJXPlZ5UFWapoVVCmAEoKNrTKxSoSCVwRe0F76BQH+rEF9UOxhAC5AoNr6XTV9AN5SIQnyewQmx8GHBGKU1EHpqjx+tn1SEAGBnCBnIu1W8yCeSoHBGQEl8eGCy5SISoKG0SvPCFPsD1g34WA89oIBQIhtEJzDwvvn2YQBuEPxTjAp8JVAdgd1TKAPVhYsSbPsr1agCbOvhXFgLMwHBEpf4T7H4AiAzqKIAjAMplsDzVA4n-5TwpfjuCQ1voJfHQh9GMSaohHGG9V2UC8sjVSAjRujUI1mNTyD0gONVmrtlBNYICF+--tPBFAOeTO4CZ3GWFy8JfGU6mhppeUJnl54iVXniZyXiSV553CY3lyRtjqGGqJ8aZ3lqZSaUNlppVBWNlTpKSbMXmZ6cVwXz5lYTZmG5WyYUnOJlaevnVprmdUk75HmfvneZcUa0nH5xyTun0ietUPkZpgyeNnTxLBXZlzp7BVdFz50yfdGEA3tYOnDsq1baGrV0EUljDofMVRk0wZFLzVYOGjnMCjk+CUUrqOBwCliZ0ydWaWK1StVY71q-6JaLril4im6DQM7ERIsSggHLXikgRTTBjAblfsDblfZSmkqg+taNmB1RtXQWyORMCNW0kcynkAqGTOVQXm1UdQvlTF9mcXGOZVaZvneJtcfWn+JjaY0kH5PmZ7WLWw1aNWT1o5KMVk1bttR7+qoAVPkm1c+KwQWAIGUIxu2tQA-UfphyaXigBzOCkDP1oGddFxmfAEjH2E98owl3iB9WPVH1hpSfUwxaES-WpgZmsMa0GhBYFh+1lBYPU0Fo+e1CH1E9RA0qGVtQUU21bBfPER1S6Wtn74r-uPX8qudcoCn1r6MTEuRfMHA3X1BYWkl318ADA3XR39VOpv16wB-WZQHDY0pu2f9cmBFpzhcA2CWJKJg0UNU9X+mOmu8mw1wNc+oQXoogbLyZb2zee7nSR5NUTmfhkqZvZN0D2to0b2JDiqjto5XENk-p0wNI0AZZAOPUwNmYSemehxDoA0swJFnBEI8KjXCAwIZyYNUuQOpN3DF10AI4Vk1P5eKR7QcES4GnZ10LNV8kPSPYAaAEldNX0opUAlX2grNjtCKAr6MCn4AVYJ0Bbo8oWbW747+nQ6hhkdZdJxWyUcpbhNaEYmSZxYTRAARNZAO+GW0iVF2pPR1mAeJLcbtsSb1118Z8wV1zDm7bXRVdTOwYN9pIw22RZtUyW4NS+aHW21q+SUkO1a9bWkb1fiXUkBJTae7Wtp+9dPYjNYhcXyL1YdYQ0TJY5TtUVNdTVU2TRVeAjx76MCIcmaNcAJU27y1TXQ3YALEPOa+akAXcAQZMdSwCAIIlJkANeReciwSAygDrAHQ6Oqvbn4UEnXgmZidSljUNKzHc0PNkTc3h8k9gfaQqA6+t8jhg1AF3gwtcOMPLRB9DVfWis0+Sw1wAbDfyh8N3hJiHcNKNr5BUtWGII0WwHlCI3OFB9faSWN0DT-XyN1qHfjeNMda7qBa4RuNWmpDyQoiEavPmMQjiTAFWThAs6tihrwFcskBgA8CHk7itstiF51e9EmhFC1yta6myZ1sfxlS1GiQ7Gy1leeKTV5eRUrX15RpLJlq109hrXKZqkdrWL46mf1krRyDbpkB1aDcnEz1FmcQ3cFrkfs2zNK9Qs0VJ69e5lb1nmdOG71HtWEnH5EWlFqBAwWjfWz1JTQ7KW1zBUzA21K+aG3+RG+eG1LNkbas3b1Xme3GbN8bTqA8A-mkK2fMfrWbXpt8cpm3BtubS4lOZHiQW01p2+ZvUlt0bU0lxt7afC1zcVeKWGINaHCQUsxR8ehWxJ-tUYnUF+mRsn05s6YtnzpRDdYkkNddizCRaPLjyRTNIdfg1LZa7Vknz162dW1FAtbbu1ZtoyeHUTJjbTMm7VPJOfUvhiOW4Uo5jCGjn6BB8ZO2dUwVsMWU5N8eRx-tWRWLHkc6DncVvxeIY0zyYZZbv546ZWJJWcpuWB-qCoJCCirQA81LayvYYoN2DrmE8CHDUxUFppBVwlyvaCvA7wEkCmW6QJkDoQ9CQq3YgqTWCAlQ0INaBwg0IA1AXQzQNOBcgcEC1CEAbNnVZIdcUmt7B+5HOBYYxcOsOLIwQyCnqfGu1RkH9SGWgKCjgAKF5yAI2HQSAdhiaL2Hxog4exCMQ4YFAjoARKJCEQhxnWZ2mdFnSZ1Wd5ndZ2WdNnfZ12djnbZ3OdDnc51GdTna52edlnWKB9ALnRCFigVYHtBjgvnWOCBdY4C0BBdY4EF1igQXbuBBdF4EF1tAe0GKDOhYoB53pdUFFADGd7uRCEvZB0IF3YAEXdgBRd2ADF3YAcXdgAJd2AEl3JQLoRCHgpLoYF34AEXfgBRdJpC6Fxd+AAl34ASXX0DOhYKfJS+dfQIF2pQ8lFF1edVne53yUMXX0BxdfQAl19ASXVWDOhVYBCFVgvnVWCBdVYBF1VgUXVWAxdVYHF1VgCXdk17QLQM6EtAEIS0C+dLQIF0tAEXS0BRdLQDF0tAcXS0AJd7QEF3OhY4Bl3mdMCO9xgAuXWAC+dEYAV1gARXY-CDQ8hfoi5YiFgyZ5OaJAiRs1KmNBKVoOmFABNCnzoD3hgKnYxBqdLQBp2AIWnemg6dencygqQPplKxlYfptQClkGrB0BUgqsP912o0Lo-D6N5cqfzY9PKDdzBWXPWVzAABFGFhY9OYDKC49+PYT3E9BIKT1sQjEOT2HgKLJFqcgNPXT0AwjPQwDM9yPedZs96PbaHA9I2Dz0Mievdz00CgvegCKOXOSpEx1t0HibCgivfcFPmFaA9o5gp4nr309VIMt0uYyKAuBL+FATWBSYFPcQ529yvSY1u9qsLz1+9w6Gl2Qd42FiF+92AGL3qdmnbWnS9svWABVgzPadbdBqPez32gnPRH0G9b5Pn0m9smIRTm9MoJb26sNvVT2cgtZK70AwBoJpxnIjvYV2LMRVDWBu9VYPGie9oOT737K3YP73y9tvdT2pgtPSH2q9YfYb399kff4JykMfScb998fap2J9RPcn26dMvQjwtAGfY3ZZ92vfii69U-QX1doB-cX2WopfXk4W9C+Fb3oQVfXb2197far0dAw4JWgPaK4Mtjg99NbP3TApZb8Uh5BRusxvRWevXiN4uCdcD-9OPLnaBQXhPxQEaB1cEQ3K4UD0S8AGAEyAaASAygMtYqwBhDPAOMDsAEwcTR4AswCAIqZSWCwDMjjA+A9uxaQNsI4DEA0AJq3c0biOrge+gDPVCcgISK9GRAjUEUD2Ad+lYB1wg7i2ZHwiA45zYANdFioygF4C0jz2t0IxCQQ+UOXBnahbu1CsERA14RUmwYS4AJ161WAk3q21f1hAD5sAJG6Aw4BmxSshOOXkoDqvL00GDUKSa26AC4KYPSsVfhtjoDqvNiyCDrcK4NXVNgz412DJg3JD30Tg9BqGA+AwijutA8dplOGJoLjjnU90C4FGgREJpyZhsQ7AAAorqI9AmZ+BYjmBY4Q1O0lVGRtEMuQf-ZBBwAjECoOQDdwJmGYDnABbmCDB0GIN+QJFg0NIZurLIPMA8g5BmVurAG0MdDL7cjkTtFiB+2MxMrD4Uko5Q80nqDfgOkUjFWlFiE+5dxEUwQDEw1+xwsltu35OOfDis79efVj4N7QffnB019iw6oN3AYvB-k34aQHy1fximJyx-xHgAAnLAoUEWgpYJQxwW6WOg+wQQJn+pIj3YxQ2YBlDZgMcP3ABfrIavwBMO0xtVv-aAMvDvsejq7DlGYjBQjUEEcMVDnJsRSbkX+IgPIDqA1iMYDggxRJsBiIz+p7hSI+UOMJtgNJr6QqTfagOgcWGhCsAirfzV70KKrE3qqt8Ek3KwUyJuRbI3MIqafpGCYSPEkCAObDlWDZPvAfmJVaHmX5Y5Q6iyAHZiMBQQeatBCxKnIM-grmYAPyXBpU6A+j6FIBSTmx+9UaKPajORT01wquDlTbGhWwLGCTwfoJnlQwndBtDJqRaDuD0AqERLiTIfjQgCCjBIDJo+DsBejryqoocQC-DphH7ikkDqKKYrGz+dgDEAghOYxwwhghtA6oEhdORijc+J1jyFemLVXniqYxUVX4BUSAVZj4pDmMaFnxSYVN5OY1YWI51EO6PP4KoNtgTYu2MEAocgxcH4lqFVAEB0jDI8TVbAOEEEQXJMHZCPPDfwzCOADoY6sT3J-5eRaEj4A4CMdlAcRiN8AWI2gMagWoXiPr4KY7fkSjpYEIXHNkmdmPajKRaTkGjy4hWPGFsQHqNTCWhB4Niwwg3zDND4YJIMYkMg3IM68ig-PLKDAIyiOTDwnTgBaD2DBtULqeg-SiCjjeEYP+DEAI9iZszg2LCWDi2KeI+DRgw4MBDkrEEMWDK4z1bVDR8F4MA9shjVUbj6xLmO25+E2yA-ZbxQWPETc+CWNwFJhRROA5Z43mO64ukJBn4AAiLkNaZBKQUM-DhI-8NLDXhFUOCDtQx-h5jzQ00N90CUJhn64uGfrhgtz4+0M68duehA9DOvH0NHBb7Z4UMxX7Vjk-tM41+MrDUw+0Wt2sw97n3FvNuMNqDek+g4E+w7lsPq+J+GONR4+w2EyHDZkycOPGpVhcNlOnlYQBm0zNpFWIdIJb6MPJPkxH5x52jLb5NsGI-YA7AqKU3m6tNrUhYGtHqVJlep0taIkV5opAGleh+ygZJtOxylxDBT2mKIB0DVAABO6DEfoIBrG+nSOIPk3lMUlN5TPAqqbMC7CRLu82yFuZUAcCbSPoQXcA-qcmkNJBYIJhyNOq0YItAVFSElU-VPulUxP0M9537X3mWq8JHzC7x-CNdpzTZBX3WGAc8PPBzgREMUUmRiOctPYAXhUzGjDbRQNnTtLeltMENuyeKSZhYQJyD+BJFn+0zoc+PdNr6hai7HTkB0+kV7xn7d4VrT24KQUXTThldPqwmnH7jmNMAODOBgVQ37gJA2AFAg+DcCN9xlYj0-pN45rdm9P+B304MNHTGk-9NaTYEatOEz600PEgzC8NI15w71U1Fnw6pItWWAW09xDJgwULg6oBG0A+S-mOKqBmG4xkxB0UBOU6i55T+gOZBnwBSiNPM29ZAHGj4XjE0S+jPxSyk0Jtvn5PQc-GntCBTk418Zy0o0+NqBe4QJDQi0G0PxoYF3gEiBTEvuD-gLQooYrOjTpyt5R2sxHRFD8ahsFjX0g+rmRK72JsCKE1oirQcwowAQGPhhlgDAyGaQuNQzDUAXMICmvoYoG0DYdF4E+aiA01BtBPYjYUW4F0ukHCCX6KNDuwLmdrLORQAfIRepbAXHbAA8d9aIq3PA-yYkpOMZOvlDUIPELoDqwZA7K0RA1s44DuIBjI4Dr0eJvb5KgFo8wB7AYUPcAAJU6prP6zbc7k0CzblkLNkhdIYAwPkFqt3PIwUSHrPhTNylTZhAH+MRgwDt8NCWHplwz-3XJ-SQh3QcDAIk64gCUVyB7QB4Xogf6R8wu1KmjI1sDLwhmu7jPAhfqwhetc7UJSqhcFDrA4OYxFSP9Jy80WqgQuHm7iyArFmoAKDvANcBO058zepNQZ8xYCea5ocFYZRGpDfM6ovYwgv+9yC-rYI4PIG9jYLnmnfxCBAmBCHEL+ttyYhJbXlvA5id3PAtShuCxfNpJcJnKTwhd+Iph5Q7ElqGFNdFnKTZ0QlOqTZQ5U0XIww9IpQv-QhgEXxW6eC4ECj4vZNYQyLeM7wFXBDALIzXz-4bbpZi9nuZDr0YNSpjydR5balRYVIOHFrTwMxQWfz9kYbW0FkizADRJDqIwsjzpyg8BmkAwpYDVzHkK+0DDqOSot-TJ0wDO-t0w9LnuJN1SA63xIS5kUPxYxU-HkcU4XMMmTmEfEteR8s15MAmmnErDHzoeErDr6TAHtCTIH+iSKFzzAIq3uwxhkbDUuWoVku1h1kD9zZt+sMGH6+1tY0tiwJuWcj1LtYa3AcA3kKnC1h1eN7T5F0zQZobYPSwsh9LDiQiidLDia3Auk4cP0vrBjwBEA3DJqAnAhwqfo7lm9LFesspwPOQ7n9FX3JsXpwBy5mBrLScLssD5xyz7Bo6vRVsX9Fqua6P1gkyM5okICBh-o2IyxfShnpZyMrlFqzdMxR1oY05F6fLDAzgy4BbINuVaEqcJuPsV245fnGSSoFgBo0WAA8hKwrZAAryAg0u7B5LEAHZJV0akliu5LnuFgqBcty1cv85TUNCsET6qV3hkrUcPcuUrPOdqOdY9niWq-LhQOEV41w2OLmeVM7Sg3D5WaSRbTLMzWM0WJc7ddGIrGAMiv1A7sOispSmktivEr7lPitXyCq0StMAMUgvVLtBSa2321+bY7Vb5ztT21756zeW0tJlbdR3I2u0zfXdxIyTMvvaDSz1AxarK5-5EM8yw4kIg6QO6tG54UNEgWQxaM8uFLxOAGvkjLy-BBvLLLovU1McyxMt2Zrwrys6Z8Sd633znoTGs85XS0iJeRtq1GtiwYy96vj4pK3st9FMcOGBnLocEcv0rMcLStFrdy9culr2y+csVr1uarmLRzS3g2tLbMHmuxr4+PBWXL-dbO02LQ9bQWSBbq92uNLMnfnJVj2q0fAm51a5cuVrFK3HBNr2xRDCEtxFfSSojTRewB6YWwAarfivS+bADj1yTkyacLAEaAY02S7sEaAOKwUvkjU1VAAxOcAONhFLoYiUuKtOTKsBXr9EWtA7BF6z9Hg0jy6SAnri4pQ4hcLToUpLA-SEXpKtQNpRF3+AJl+uWpBdMIDxZU9BRxfivhI-Mzk4wdS0CDvlOngXrLTWlHKNYwckFsmMoLAhLTFi-kMt6bgSmBzgdG94SZhKkzTG4zx0yMNBL7MVEuPBwQTivkBqgThuFowxbxue4ZqL7Xl+wQYWiUbvM+hF3EAm2RtSbGvRTbNzG0NUyMTtjALBqAaG5JtwDlLjq28rkm983MAvzTiHHpOG1BLBB3k6wz2BTqOhFXrOK794FqBG1kFvjz4tuD1iJmc5uaA1qLesIA964+vPr3-SykAm56y5vKzSoPZue4vmxj0PJxS1SMIbF61sEZ1eA3+uFRvgIBszuoa+NoRrGs16R6QqI0kGlgG0mIB8U4wAxJkAB0K2bUWX+LjXBBn5uyUSbOGxyCWwnm8EF0BWdiRuCwOmxRv-dS0dRuRDuiYxsMbgm8xtUxqk74vvt-i8MNvYow1xsGTg9iJtMA-G41sKb4YMJs4bfG2djcE8m0VsGdGvdiGybva8HiCbe24RTKbqeKpvDM6mzYCobe8idvTEaquVscThm6sAmb6EWZtkbFmzhtWb4gDZtXoEWxjQOb3bk5ttbKhpZu8bo2ojmOC+G6DvqiCfAMPnTNG04ZDbVWwhSuBOG3Y0bbv8D5REwQsGRscgLG+4Vsb+M4EskzOOcMU+Bipv4Fw7JKq1tNbKhhTtTp-gdPYg79O6Ygyb0sazv47ODfNEK4O2xMFNQdO9zvOrpvg1ukbIsBq1UA2603So7kXhh5RYMLXVssU-lhxRUVIa56NBrJSzJBZby6jlttrjMLDuaBZyC4C9I1Fn6x1b0u9vbmQaAZMj2iOO0ARs7+Q6DuSp4uwLvBhQ2UNum710JkvoQjG5mGU7-IGjNc7IsGckhVR6wZGlgg4eUDzwskNksf6XpCeyOjafnxbjEB1eYskzli6On8ryayPm+t0+UznXqnmuNhFAUezHvdxW8eNuzTxO+jmk7A2eTvcbWuTEuXxAHRrkN7iRU3vzyLufiHqo4HYdvJLHmASH8tjGs9IADxHPHtSGv0izYp7280I0aZ-W561Jrc7bYuj5M9ajLl7SOZXvozk2+xszbnGyfFt7nRR3sqWQSoB0H7IxY-Fd7UHb3u+5HPmkt9+-0XxbKace2K1JYRs8nu4BsCf4Rp7c+xntI7Vi4vuDrPrcMkpxqbRBLS6Acuvs+LVe34s77mOXXv2e787Sw5aqeHc21eYnatrgO6gKwzOsQHUfs1MWlEgDu4GAMmp7DYfgRpaUCKLgcy5PMaNi1YDY1NhNjw7FQdhLylvtLMHc+BfvHFA+z3sHbN+6B3qooldcmcgw5LwCl7se+FsBjHUn9j37KYGIcW29nikP3AiezAB5yU+x-tAjX+5NDh7OQkrM1lnKS+u2+oc9PuaHyYGSPly2g5tWrUFIGxPzTC+ysk57gqzmmgHuBl3xw08yRXusbMByTscbZO8EvzbbOUfst7DTOwfwtIHdweJLfMzLH8Hd+7v7R+Eh2CWilUgNH7jAnsOrhYbLwNsgsA-JTYekzfa8NnZ7S+0Ouj5-60VF56GxL5qcs7hxvueH2+94e77vh3NsYz0S9QfN7ES6fv+Hjey0ed7XBxsw8H8w5B2D72h0Zu3oz+xrPglDICMcpHpaGkfdj7vpkcXR6e4jsDbWe9YsTpKa2zAlHiYGUdZHwx79RVHUB1vvqTNez4fwHjR1LnNHLB60cn7rex0ft7XR4Co9H3exEd97UR+EfQdB83HGRY2SzdX8zUh3RA3VLYzgCFKr4OsBfHkU-dB8DbwPwMsp3eujqTV9i5If1gnKfCfOLCNoCdfDIJ++nMUtJAlEWgdqEBZ8UWeZoCWj4wQWzW+sgLb6IHjvqSo7QmsHf6xYs8yPAJNogMR1z2FHP+CsDuqqVNEad+htAhUkBgQgmLESCYBlY7Nmx4Y5JwTXDTAX2yNbpsyE1BPBDn2E4jzFDTKvrcuOtr3zFg3LrrqocB7GDhLsUOGcH4tPFIjianaeFKdX4u+LdAY4FhnKcQTgQ+YOSqZVAzh5Y3vNPMDM1gL7MO2Cqs6c24OoAaqysl+2qfY2eyAafW4nEp5MU2DbFnOcDDgoxkCM58-BBZ50x+PBvrIp4uSI+wZ8jYwcnUKUxNCoNFNDVMjHFnNdcnQQyIFn0LNJz7StVhWdFnPJ3owGLCgDmeFnsHB5C1nSnO2fGcZZ7ewlnRZ1MGbuRRJUv0gSoKWDqnQjJ2flYTQmqCrs-GjIFyk-GmOeNKE5xWAEUro6uwTUc5zYotEIZ8udHop-WudswQENcCbnAIRNSLnqYLueaMJ6AefswG5yRZykT2dufZnl56uf+r+kIYBzUmoPecGsn5467jnvZ62dXnVqDecnpJ5+IoQZ5582fQsK5yX03nOpGBcNMOpJBcvnsF2+erse1Ahei+4DshcAXpHHufXnaFw0RDImF9IBDIOF7meAXr59OdswwUyRfBT5Fy2d4XQFwsngVKcRDQkXNCQxfQX+F8BeEXhgArRZzJFwJedQO57hdsxVF6xfZYJF4NiiXFF0xcSX75y3gkXU+LJeMX4l6hfUX7MEnQcXSdFxd5nPFyxfvnmViReZWel5RcaXrF3DQkXcNGZfyXFl4pcYgyl2NCqX3F8xcgXVM9+dfyaZC5f6Xbl3xc5MJl1E62X6l-ud8XBZ9ZclnPl+ZehXml4XAkXDcFFd2XMV6xffUGhiRepXoRolchXBF5pcQ6JFyjpZXMF8lfvn8fJ5f0aIXMFdFXOV6xeg6RgGVd3ymuJVcGXN5+7AkX4cIVfNXfF1eskXV601d+XsV6-DxXr8H1cKX6F+ZBCXhSB1f9XrF8vAcX6ECNf2Xq7GvAkXjSFNejXh50JcLXxV6uzse9Vzh4-Qa14teWRLhiRek2S52JdVXvF5pd5MdVwNqxOw+odfbXbMNua-Ee1zgzpIj1wRd5QBUBNhxS-KNjo0QuU0qqOYKqtgy+UiwDsgol0x1arsnal5TVvYeePDV1sCKOJBqo2qAiS7pCHncEEgjZ2yQLcH+gAAGjZwTd6AugMij-UjZ3JJEd+kPygqcKaP-CyQ6aLgDVAHnOmiac3OASB4q7EK4AsQAKIzcEgunVZx2c-8Dc0gAVAxQn8UaqD8qRTWJ+sCMToI-wAiQ4UNUaFGdRluhqmhqDYyJkIAHTe9wDN0zcs35QGzcc3XN2xA83fN+miC3REMLdFcyZDX70ztjLIDpzRQBnkShBPCVRGQFN8IiSAVN+ijEOs+FsBxw-t4tBbAD2laIGNwd08TGNTQgyx7CxDn6aR3-UEUD1q-KATeao5XPmLp80tYneMZtuhrdoQWt5PhZ3JrTndwgokBKnOs+dw7eKUtN5Ch63-N8zes3BIOzdsQnN9ze83-N1bc23gmGchV3Wt3CSiQut-rcEgjd0bfN3Jt+3cW3AtyxBC39N6Ldbb+kH3flycJEPcN3ht8bet3pt+bed3M99bdz3gmAphykC3MxpGQBZ7GfqALOBya4whlrl6+E1TIbQmx42qOchnkp8jaes4gGACNwWp9jY6E39yrbynZg1mzDseSOkgJIxSEXBZe1Z+x7BWIDzCxNIED8eJCdmzsA9tIBSGwidIkD0g-jXMD6g8w2GD4g-dMLOldWwPDCPA87824qB3LXOD+UibI81-g8N1QnbNfzQt7J-ev3OtoJkPgNTGR0fAIkEsysPf9+w-S1X4Fw9xACQFgAqn+IbOftwGGvLZsrFSi-jO+B8uTVww9DECvRU96DycTMiwG8If3X9+acq20tQuA1ME1D3Yqiuj2w-4LJral3l5eCT1bdMG5+1zmPAj5Y+6UclFuA1MR5yahwT9KE4-6Pgj1Y97QnDxthIgxCa7FIPDjzo-8Pfjy4+yU33eXmPnXjyeI+PUT+eccP8T7Y+zyt58eeOPKT2y7S1wmR+eJHHLkk+TsuTwY8BP7j6MuJHYT90y-nV1aU96PqT9LWVPYsCemmPp4r49NPATwU-tldj2g6gXOT4095PAT0E9iwOpO0-JPQz+U+uPzoaM-PXtwNtSrsmT-BeDPFj2knNP5eXtQTPDT2s9z4+T+Xmb6NT2g4YXqz84-rPFT+XlzhEQN487PZz3s-dP5eYodHPoHVc-1PnT8M8zPe0E-0bYVMDc-vP0z7E+BP5eQVN9PoHbRenP0T+c+fPLTzmkQ02z-8-+Pnz20DxPK86NOgvA+zQlXVCLzE-CJe0MI-BPSNDGcSPh54S8LAWL2U+IvgLzC+GAauMS80vkWOS9TPlL7i-UvLeD3bdMSl8OzYvUL1S-xPSdOy9oOYtIy+7PgmQU+ZWAr6B3GXXLxS84vToUF3l5tvnS9WX0r0y+yvbj5c8YgErwPuNEKryK-7Pxj2fB0vPxMK93PgmdS85MWrxswBXur6a8bPNTGfdKvglza+Qv9z589GPzwu1iWv+IXFfOvXT0i-l5GV9vx0vgb9IG+vHz4C8FPN+nS95XYbwC+4vBT9RJ0v8fLG-Mvcr9S+1XXr98Sa4Jry6+ivBz1kt0vrVym9qv1jzUxfrdL91fFvPL7i-uvo2Ngh0vD8Dm9+vgL7W+Hn+CHS+sITb+G81vKL7yp0vTD86zcvrr4C-fPME-QB0vVD4O8yv1b3K8KUwT5m-8XXb3G9yvo72zD5eUD2J5Vvw77i9zPzhsQN0vRD1u+CZ+L60+5O9wEa9nv1eD+BxMaVQVvSimdAXURQGpCo+ZMntHRa7s-AGczk6d+pE+qvs0K0-HnJT0O81MmCei8bMET80LAfwTxudAf07wNBiwITyAlgf+IZ49vPcH-gcwfvTVB9tLoH5k8JPaH3+-wfbMHU+wfhHzUzglyH8R9FPBH7s-GPEGX8-ofG2IbSUfY+PR8Qv559Gt8kDH2R9x8Cz0oAsfKz7++0fBL44Dcfwn+6yu6LHyc9Cfdz9GvEXpH+J9rvF1AJ-EX7Hz-c-PGgGJ+yfGn1ZeZP4LzJ8uv+B3rNafhnxtitz0gXh-GfW7x4+kvvxNWfCXvxNZ9MfDL9WdSXTn2M9B4dL5y9TvPH20vaX1Z0K-ufGxyYR0vUrz5+KfIqSLRKvUX0F-GAjl9Wc6v4X9p8AflUEa9UzsXwFfVn1r0l+mfYsOFfVn4V7F9xX1Zz685fHHxtghvwb9rTKGS7zoG5r8jNG8NfsX-HzVnyb2V-qfrT9m-VntV7V-3KG2K1fVnRb+19cBN4xjQVvY30V+DXJX4Nexfnb-Z-YPw33V85perAF-oQvX-+9swy19WeTvcrNh8bX9n+t9EfIQ2J4bvh3zUxEP1Z4e+LffX6e-3XzOfY+Xv0jyVtEOxEkZBkO2kAABelgC9dhFUQA+I4qs-JOJysM4i9dmn555k8vXtjt0zcDoQmNrLqIP2Vhg-SXs8Cm4Zs6pgA2SMGECPDOTJnVuqN6ufgMAUqywAYATdq4ugr5MPXpuE3dbqqlozwH3NfMQo6pDbUTo24v9SBYS54PAOA2MDTqUAKvqqATIH+DWg3zOrhUjtSyHMUnKQYT+rAJP90EYBO7IfD64KmNMj0J8HbnouqEiHajTIYENwuHMWSG8J6vAT629j52zwb+fPq7ynHPP4irwrWYpv4C+ooG2GQu9Ntv7i-2-YsHQt2q+v6a-x3qYCK+fhrLGLCO-KoiK-e-SPyrZ+-rv2zDu-BioEo2-trwE-m-dKDc-O-cr0b+mYlH7Yq1kyf3JRG-ntyU9Z-pbxthN26f9b-9Y+f0C-RrQ5yb9x-0LzY+sXHv80Jl-BTwRRJ-yX2zDqYxf24rATZf8i8gfLXEZi0Gef63+qgff00Ad-Mf6X-V-gL7u-UQLf7m92vDQnnqEAY-2m6T-O7zY+7+xL9-IM19viSEfmhNcjC2pgvooiiuq-2m-1q-Vtm9Xhy-4ph-gFjLgihiUoXRYZv01Z79z-AT3O8vuaREH9e-KLH6a+-i4f782YAP9o-iv83-v68amONpN-oW44VHoZHENZYqSOk1QIDKBRAH9Y7QFKF7FgdB1HNCRA5ilgz4FFQsAqIAg+JFRv1NsBbwkFQT-rm87+DaIXMLNxEIshEJYgKAdZqQQZNJMoo2PAA5lPihhRg8lqMtZpBCK8k+KPXgPgBRUIyhFBooAgBVNohJiMPXg4irXhWAfOR2AT4NPmHIDqsBwChRkgD+zrftnWMoCFAfZNfBp88I-u15umIIDxHr8oAiGwCpoD4Nh2NoCLAboCBIvV1y8n-BBvn7gPgHnhTATIB5ATYDOAfIB1cg0xrAaoDG8HD9rNNsoBVOrMqMvelY8rwCIFgaxrAduxG8M6xFAZ0xqzhow9FsDApiEZ47gh4wTUN5QIECjQdgoPhl7ML9GzvEDbAalNy8mkR6xLoD7PHKQqXBgB8YGoAXYDEDFAeCMNRvEQSgSa17ATUxHAb0pbAY9UGIPCEUCFUDb4mlsVjGYCPAbEDe8M0CmVL9AmqiBNhRvtJLARf5ZAHL9MauXITDMhRQSsGUYiqGUcJEJR-GNFMTYmDgHqGHBGHG8Ri2PZ4+5gPNr4D+YTgTr9FOiRV-NPTgshPphkMsC1uIKMDqsOMCkIJpAxsP+BcsPvB3jEJRCgLyBgTnR0MAO2Nu0vSNlzLIBvKL8leVO9ZBpkBAmjBFBNjkDVhAMVtilnRYXLLIAGBs6wVDnbAWvPe5SPJrYxcHKQ9kEcCCQfSAmyLLNdAeWIYQgUR+gUzxL9niDjgUM4IKIQQh8JYCXxONohckzBtJBigTZuXA-TuqU7gjsZ2ZqVsGih+8YKNABPVJfogfm00BQWtFXTh00hMOndc0KihJRAqCbcN7w0biTkRBHKQ1UNPMWCK1MbYIEA1TInobNEYB0SPSJtSJqCQQsqCfJLqDUUKOB87hBltbu5R7PDkD-wGqYhAK6DWTkQUGRDIBIIIKC7QW14dQWqDzqp2AXQRqASMLY5nQWoA-jPhBXQXCREYlaCNMqZYjHN6CiNoqRAwabMjTkWogwYqD9gKz57PO2IMYNMAShh54VYH6Q1gBigkQBTBC0J9BEQGAB6wWj0cwcGDL+gY0mwfWDEuErZbQZf0Q-l2DtqPWoowU3gATBmD4wUEQZQIVhgIumC2EGqZJVDODjYHOCJwQi0+lLxl+QQWCtQQOC6wUOCeUD8oRMIFA+wcNgpMEeCiwaplF8M6FBweQFUbqRgYbm2DCwUzhzwbWDmwdtRy7mvx7wXmCPwSCFHqqqhUAL+D-wQxBRIPCFzOItZTwbDh8wbmDvwTDVAITBC-wYBDgIVAIwIZ-AIIe2DXTj+DYIUBC0QlIxQIZuC4dCeDcIZf10IX+CEIe5sDWF+CF8GdscAAmMCYJlRuAJ8lc4M75fCGeQlgR3VP9DOQlqMz9fCJWUlfhGN1gEdQLQONoVbrUY2SBachQRrMeATVRIEvLckjq6g9mJ4RDGnyZeBhzNh1Inhg0NJCXTuthgbO4ZCIdBDK8EjdkQoiFdIbngsIciEXwrSCqaiBwTIZXh2WPDdEVk+x9IYjUzsOpC8wUJCNIUzhHqjAB9IYg5bIcSZCflZCGIAwBDIe8Y7IagAygP5DQoUFCe+LCEETOFDCzKRDROs5CoIcFDiTKvcDbk3cW7m3czbh3dLbrvdhbi9UrIbWIuQfD81aJsD1ytBJefsPoyAtHkjGI+lH3sOIF8EJR1gWqVSobEU3hKJDvghbFCuuuD2oTyp60KUCamFeIOBD1CsYH1C7BgYCRjAfYhoRVC8IN8EqOMhwXUra0Xsp8xhoc6A+oZnxUwPNCw0tgAn+ugAOBIVgVoTNoyQD7kMAFAhaZB98uyNQAxFHfJ-vI8dUoihFGAcVCiDOVDCDFVDuAeEC9Do7c6oWqRpoUJQ01P+py9L4xtgHQBLLOE5vcAKB4MAdDVCvnkW+qfxIYYhM67PacUJuYMamN0ReiCADTfAiCh5gTAHyGkAHqNaDHkHDDOod2BYYdNCdlKtD4YY4NkYRtgvNA9QoAeopBltBISoWRUWMs9DKob1C7VHEtAfCEoBIceYGvE9DRISnZIYVNV5RgSBD0uQFxIe9DaoRBtzLMDCIbKDDj-gx4Nhkx4P7Dnp9IOCDOxpghMEDcpaADic2CJwMOOqXBWKIAxpARIh2mEHB1TN34ZPFtYTVDiA4HIA5uPGSRr8IP5LYYN5A7AzpbYftZq7ONZHYRscsZPVY2ZJ44PdB7Cw7NXYI7LPJ-rov8nrNPNbZv+MwPHpA0gZ7D7YeyxUwTcQSfHp5oHMHDTVF7Da7PtII4XQBAboLNgbr5hQbh7hKnDlBEAlnDAHNc4U4UVg+5qLCfUOQE64WLD3XPbclMHjAISvV4fAisCoIE3CG4X+oiNMYtfVpBB5WorZrjg0xzVOsMlnJ34P7IUwMnPRBSMALDkbIJgerKnCGrBO45UJDDl4TOwrVFroAblHCi4U6NVVHxQrlJQMN4aTCyAlvDMwDvDKQCABAsHvCgbsaxi4Wcp81Gqoz4S9DeoYJhavMiN98DDde4d4hAgeOgCtI3BWYXhAkvGECY8h9CwIIUpD3Ef8YsOfZiXEnBQvBS5VABF5hmLS59gFZNNhsx5VYVIB1YehAyllrClfrrDeVKwMDYYIQjYSPATYQ+QzYdkpDcC7CjvPCBQ3A7DFPL7D8gqx5p3JnDG4OC5r8OSR3nCc414aT4NnJwidnJR884WOwH4c1MY4aXDs-OXCmEcnCESPwiA4UIjQ3NP4-riAB74YXDH4YfDY4WXD9ICoja7KmD9QSAAtEPt4mlkVh03Dzw34Q9cl4WjczkBoip5gfCpEdBBiEFIBxEAxYLsrNp98CDgTEYwYXdLvIMkIfoL3AEiojDswjgrZAvDscdCeGEZ6arwd34tXsAljKwEYlmtftBjceYdZogEd9AQEeD83oRAipYfpBIfIf8vEPBBAvAgjSXGvZkEd+JqXFIB0EfS5FYVPC8gros1YV1NIQR7Ym2DrCbYCQj2OpgEnbhQjCEd2Y+KDQi5gHQjpPK7CmfBQBOEWN5dnD7D9nLZNRkfp4JkfJ4F-NMi+EWP404WT5xkaJ5-HLnD1EZHCJEcqpn4dIj9LLIihvP44a4UJ41kaJ4FkZJ41EfYjFVFoinEXpZwPAnCxkWG5DEQax+UOYhagmgs3vPPDRIIvCdbFvC7EbsjNEZIiS4c4iVEFIACke4i0Umk4cop8jTEUj5-EZL59skEjkUf1o3CuYgIkQki3sPCiOEDEj+jgYhMUbUdIkSqApwnSJUkQ9DrNAucX7nc9YyNp9uGrpAsMMqtxIEJCijKH8dbLbopbg7oMYd4ZDkD0gAbM6AgbLjdRgoLA6Agw8jEbcimptsxUjsVNpAJjC7gWfdOTqRp+AIvNQIFhswhAoj-QRKjI4WbV-Rizk0tnigXDgHJqmkmQxbpVlZPjeDkTMoF0SEVDeAU+cNTrs86UaZ8GUcvEVQWai5bgUZhIeyiybJro3UTEFMYfyjAbGABR4OqZRwGQFwwJn8LUWzBJSHYDRIN6j5FtGjHlHfxXYmu5ZWBDDmVCaoItuzCJlLMpw0TKBggfMoqoXzBtlOp9ZQKa9-RGQE9oDaoZtPFD6NHzCGdEqAS0cjYq0bmj2YZRCvhmDZZYXTZ5YSQgoqEExUUq95eoVWcbkcCiHEVoi6tpKCGjO6jaPjeCNUQvcHBHTlg6A3Is0SNDw4Tsj84Zgk9kEoxmUZo8ZtL6jgHJqjL9mIiC4WOjQUQciStqoAYbuGjZ0ejcAEaogzzjSiXXk6jyvi6imUTDdWUXUZHUfuiaWg6gA0T5og0SGjNtEuAh0byh40fcBpZo8p7YvgA40TOjE0VW02vCmjiwVMCG0VVCc0VMoQMW8CKGksQi0XQhZlKWiRXhWjeoS2j0Maui6xAkZ60Zmim0U65q0bNp20dLCabF2juID2j4IH2i7SoOiRocOjtUfnD94eOicNnIAGgLj8Fpvy4o0WjdUwQzCIVEoxUMSOj84TikhKkdRiEluj54UPhr0QtMD0fOjpMeIiQUfsij4Zej3USpjRMRSj2bAk9ILl+jVKPSiDwm+j3UR+i2SF+jZ0T+iL0H+iBUf0hg0cKj18Hmiu-lGjpuOolXHtBiwMdYQY0cmi9pEhjgfhmiPdCujVoXspE+K2iOMfmjZlAKocMVFi1aPhjy0YWJK0TRja0fZoKMWFiqMZfN0sXRjeCDLDGgHLC6RvzhWMf2l2MatDOMe8j10ZpjT0dswJ0QJiNHIIAYbrBiDMepj9fEujIVFJiuMfWgcUtxD9DCAlFMTuj9MRUZb0fSIesSei7kWeidMUJjxICNi50bajx0L+cTMbSi7cOZiNSJZih8NZiwMZyi-UaytHMQBjXMWGiMMZGjDPhBjvMbJRfMbBivMd7xEMZ0FkMZmipMW24aMXypVAeFia0cWi8MVwEy0bm9CMSNDiMWTCPsW0c60ZSYG0TliXzHlj8TkCcCsQxiisd2iSsb2i1qmxi5WHmiNAeRxj0Txjmpg1ibQE1i1gC1iRMWiZD0fgIFgp1jJMdmiNMWZUMKgsAhsVeih0TeixsVqjqsZKjo4WCiLlLNjd0V8Q2sYtjUOhBdH0dkizMc6iLMVyitsdJC2UbZjVMfZi5UbyjEQf+jBUS5jvbqGjgMTFiPMWdi4MbGi-MedjbsUFj7sW5ieVE+ZeULNCAnt8Fk0VFRtccg53uGcwReil5eoQJEWgKJBjcQhjTcYBRgseminoWcx1QRqxLcTTtyuIljAcfrjMMW9j3cY+BwcazACMali9cQDig8WRjwVFljhlCHjI8Xrj6ajgi8HEDC4cUxiEcSxikceVjmhO7jh0SqIvcYkDtkcziD4cEEcQPrBJ0c1jp0QTi50fjCegqTj3sZMID7IrVLcW3YL3MfxEHs3ieVAMBPwoihOHgXjd0QMB7Yg+Bp7P3jTUQskErNg1tbgDcyGqNUacXpi9cfuizhpmEN1lkMKwDaii3EEjJ8Yj1SvF3i27L9VumiSCEjBPjKGr6jp8RI058cpiF8TejaavPisYDmAb0WJjuCOGMVKmVBNQvqFTtNzVtaNw1OGtuh+8S3jHqj9VGMvlDNpCZFcgLbBT1iwlV8ZGRF-jPjaSBfi5sVfjVMR-l9qvdgsToQBjqqdUigKASvXBATQoFASbAPnDYCWyRIVMNjECWjcb8RliUmsfip6qfiYCefiSCbTisYE+Zr8aQS78fujsCeATOYPDN75JvEMbotEJsZjjtMS-C+KIwTnQMwSkCTai0keOgkLnzikvMJ9X0cLiWUaLjP0ati7Mdyjf0dLj7gLLjnMYBilvCdiNcWrioMTBjPMQFiEMWbiI3HoSmCRGjDcZ88HcQ+4ZZs7idccdi2CQbibcfbE7cXYS5RA4TMKDrjXcShjE8baFBlI9iu8Xsp64NFixCa9j4sYnjPsUljvsWHjgoe7iE8UwTu8gHj+8QWjsMSESzKF9idAgHi2XH9jnQL51q0WsFgcZljQcZRjsibljwiawBNUpjoYcYDDabOnjeIIjjvuMjjrMLnjEgb00C8aswi8aOipsfVicNhgAEmhXi8cVXjVcW1ja8STjilGTjkidsidmmyB11Go0GCbfiIiTeiYHmrRYJG3IkLjhIHQv6J0plIQXYtmJRpFsTK5EpF7SAsSO8rpQu8tATCCXyQ-Gs9BAmk0Ai8gsSb8Zfi2CasTH8ez50cTVjJsVKiQbuei2caITqiYvjJCZSjx0HtQVsU+i1sYLiNsYoSPUTUYxcaoSJceoSHMZoTA0XLjdCbrjlcadiOPprijCQYSbsYFjHCebjLCRETXCSNDBMp4T3BGBBzCeu4SSawArce9jRoa48PCTbjk0V-gaSWmiCYaFjhlEHjC8pSSc8NSSaATKQgpnUTYwKniQYRnj-8FniB0evhq0f7j0iTijoibhjYiTkT4iT3xEiXKTKCSn4nofHi5SaQEu8f5i-EddAaHCiiErLEZDVH0Q2iXrjKYVmwy3pNB-hL0IvcUbt9pF7ibwWdpF-pHto9rJAqNJqirSVYSOifniDSYXiKcYIT+mAMTGzvxiccauMRicJixiYTj2sYuipiQ3jZ5K6ShMTKACCfWhN9EK14CbujxCbYjWfB8SIih5gMcXsi-iTNjASXmT4ydzjwiGRdZCW-coSS+ihcW6iRcZ6iESZCS1Cf6jUSdoShUQrigMaGB9CddiY0XiTByUmizCUSSLCSFi3ceTiNZvRj6iYxj6bPaAysTKTfce5iFSYyTg8RUT-oGqSEBGliqibRiSiSk1Y8aypdSXuS0cL0SIjAfpOGLvpqHOaT3IJaTHkN8EAHqhM7SeEEeidxi2nPji4yX2R9sGyC7CHuQPSbIcvSepAzkYySqsV8Ti8bxiyNpGSIPBFBPyTiSJCUTiqhBJj1yW+TasTRR84VmSkKEsTXiZVj6caz5b0UejviaGSn4eWTliXuiH8YZjEfPRc6yRyiGyaWimyTujtseLiuUZ2TDQt2T5cTTIREHSTC0NiSf7riT2gcYTVcQSSxyT4TiSZiTSSdbjySdLV+SWzhvCamiUif3jGSbbj7cayTHceO9xybSSc8QviAyaeIuiWSQ10RBTmpooDhiezjWsfGSJichSg8ahTbgrjhgptDM3sNhSECVYSWCTDc1yZbjdsTXjGceBTeib8SSKcITdMThSgSRRS70Sbg9ZhCT+cfISGKe+jlCTZjESSxT9sV2SnMT2TOKYGBuKRGj8SUOSBKRlTRyfYSOSQpTtKZJTyYdJTVKfYT2SRpTZWM4SCidYS3CSa0WSeSS2SbIA8qe1x2iVMFAyS4TuiSGTSycLNWGFKtdAdBTBMXBS+KQhT1MRNjzPkpinKSsTVMS8TrVHFjC0SETgSZRTxtA59wqXIT1sYyjYSUxS4qXtieUWxSkqRxSZYOqYBCV1TtMDCD5USR1YbrGdz8EodnHCYB7RgTBpWFGAeplicFsVITa3ADgaKT6iNZj994QYlTDsb2SUZlrhvDGCE84GlTQMSOSLscborsSYScqV4SmqRVi90R0SjqVpj+mOXjGsdGTTKdXiGcYRTbka5SltLyDOAOuTfUbejqyfMRYYNmdTMZFSYSc2SlCa2SVCe2SkSaxS+UexSMSZVSEaSrj4KTdjhydDT4MblTyqflT-SYVTDocVT6qQhiyqaJSJyazSGSTYTZKHVTyYQ1S7sWJS-CcETkiXySSqV4SyqY6C9lLUSuTrDiJSU0TM8S0Ts8SuSCqW5SlSb7jksb9jw8UwSkiWIStSUAiwcZuSr8HqTjAEHgDdI5FTaXfiBMLYkLyTwYrydEZuDP7ovdH0QGYUESwsa9COBDJSi+BrSlRD7iuVHuTIiXNTSMcqSX0duT6MLuSSMRFjo8SDjk4A7SVSZUSM6dUSOMA8RrokWkfaYHS-adz4TSXeSXlP1hHyYjCFTo897SSU93cTaToJmu8m6THcHyWrSqSRrTwwWoji6TuiPaQUSPKbet84Z6SY9sBTEKUWTx4SAAB6RjgAKTAA5DrdwKUfBhUcfpTOqcjTecHxiTKYNSeXMFSJiZHSRIL3TMiJMUKrl1jE8dsiB6a5TZqRkTPaewSAbphTTZI5TcyYvj5KVjTboSWTN6doj-1K-CyKZWSXqf6DFapZTycUYi56aPTMyYK0sKdujASZzjRsfhTCyRvS6sWWT-Kezj5scTSSafaAxaCtT6yV9T4Oj9TdqX9SUqRcBvKE-hgaeDVxKWzTeKXvTDCVlTwaVri+aRbiCqUpThaXLTRaY1SGGXSSpaTVTmSSpSRaaVT2GeLTNKavSQMWjjiyURTjqRGSd6aMT4KeMT-QcIy+GerT2GZrSDyQtMr6e6ih6fSSR6bjTocBRYCabySbwbejJnCoz+UGAztGfjTUwK9CDGSCT2bKZcPqQjYHkt9Ti1Adj0SbjcAadxAgaYQ5yGazSeKdlSIaXpQoaUJTTCbzTBGRVSlcRJTmGUbju6QKSxafJTGGS4TBaUySZabwzWGfwyFaROT5GZVjEaUzifKdPNJGWjTYKdIyhqbIyGYYfTBScoyx4faB+UOZQDdIPSb6YqS76bOjrJL8o8aboyLGQESrGUj09chUyFptUyQ8Ip4zGa0zCaR0yQqdYAbLnYzhjA4y8GU4zfqS4z-qSQyPGbyAvGWEzKGb4z1cXQzCSSEz+aeEzpabi9SmTEzgsZLTqqVJTaqckzDofLS4aSjiRGevSkaUgz9AMZT8mVOjYyTIzzKXIyu6Qoye6UozwwcYyQADkElYdPCf4WRT78WmSs7G44BEeNSA8VESVafTjUGQaTxIMCyS7Id5amVhj6mbbTF8cWCi3IZShCT-SBATcoKyQtTorN8zMWVxA8mVGSCmU8yimVWTXqeERnLuTTVsQLjGyVTTGKTFSdsd+jkSVLiCGbMyiGX2SOcelS6GVzTAmTDSqSRczWaf7iImbYSombJT9mU4TlmVwzjmTwy9mQIzYmQ9iw6QESI6RKyo6Z8zMiE0JjaQLSNGRKlk6RbTUnvkTC6ZqT3uEUSE6bfTh6VkS86f9AQ8bZDLcTbTNGVnTSiTnTyiTaynaVUSaicnjO0WniFyV4x+0SbEQ6dyTWVOHTHSeqyj6UoyY6YewdWZkyIWYnTM6Qay4iSliEiURi8sSoz7aW6yOafqFnLsbZwxJDj06spgpAFpgh9D-SvAcZg-SeTCnyVTCbxk3TOidaSq2baSNsAdUerAEIlKecyhSaigJscGNwWRoyFKPvSvKWIyAbt2yzbNERl6UaoEmWBTB2TkyS8dvSHmZXjyWdQzimcTiFWT3YvmVa1gGTMSKccGNXhnpQkWYHj5qY0zn6bnj6ccmRxsdkz3yV-SnEQCS-6fizFokAyz6dMSIsdZTt2VdER2T9oCltAyyKbAy1MWezvKRezbmd-SL0TCyOMcFTMboj4kSOMzn0fRTGWdFTaabFT6afFSdqUzS9qSzTlmT4y+WbQzuafQzNmXEztmdwzAXiuzhWTKyjmUVSTmYRyOGZcyYsaIyZ6USyt6VBSpGQuzcvP2ySmeGyymWuz72fXirKf3TXaT8Qe2XUz3sX2ypqUeyyCaNiEGTcy+icgzsWQFSJqUFThqXeyOsUmTusdViqCHnATsB+zwWWgz36Z8Sp2f+yJOX5SpOcBzcKXJyMGX4AgrpBy6Kd9ioqVZjmWcxTtqRoSOWToTXMeJzfKaZzjgLjiQFlMRUtHmprqZIBL4B7gLqZycAGezYKzuZz6WdBz1qdTS4Sard4OdkiOyQlSHOclSDqYbhnOdPMvAD4AE-NxBxAHtQSpoBIYzpydGEq6COYIcwv8DVB7zHlyysEFzEfAldaWZCSwuZZyYOdZy4OSyy4uUhyZcShynOeey0KS5zUjt5yHfEWFc1LlyOTmVhToElgG4CYhmgZVzxtCG9sGbRS6uTkSrOS2T4SXTTYuQzT4uchzCGUlzQaezShqZzTMOQKyeabDSKORkyEadRzKmeIyv6X1QZkG08GOeaivyVpzp6YeSyiWFjdnvqTSMSZyCrjVyIqWtTXUUyymubZyfJGty2uRtyMEFtyqGUxyaGT5jBKVmzBWQKSLmcdzMUKdyFprRzR5tSMqYDdyfsc8zPKSxzySQ2y26WxcX2HJojydQAwMRxhMXrqcF0QkzW6cENNAMS8M2c9y7nhxgaeeTzEGXpzAOeDcr7nxRUjrvTweVziqWQpUKrqFzKaRFzfuUtyYucy4WufZz1uZyzNud0zP6QBzUjqdTNCQqjyuWwNoqAqM1quOoFHg+9U2KvpEatYzwOY1dBed9zNsTTTRec1zVua1ytCe1zeyYSzp2VojClA9SigD1NarhcwukWj9-GHBQ9og14qANzz7lJajrIYaDPcNxB7gNw8sAO5p60Kk0xrLYEMAAgBagSxlPIaQjAwGXibYNGBk1CiFp5gaE+URNNjSkeo62NnlCCO4M1gHVNdILwAJ4FQBK5pNzl1O1dPuatToScLzYOWbz-uZLjM+UDzpeSDzZeedz5edMdFeYqhleUNzVeSqQE5h+p-oTOQLolT8+AEr860JXzrNL1cjeXXyfuQ3zouebzEOZLzW+Y5ybeR3zkeQrzsGC3ztjOFBFUcNyDAL9Dh+ctAx+RxJqfgQhp+eOh6EHPyGWfXzGuY3ytqQDzLeWiT1+VyzQeasz+WdDyDuUKyjuW8zMmYjy5eazy64okpqgGxBY9ujyzKVjyP6SAB6EF8j3GZQgEUUAiH4Bpy6cUgSr4Wajd4dvF6EFijpto2jhrtoh8UUktgADgLiUdijSUckiN0ItTl1Dwhb+eFyF+Q-yl+U3y2WbvzX+Ylz2+SlyD4dvzmKGdT1cAfzVeVFRWEJCdddIBy7WMUBslGKViaXzzMGfNdQuQvIpmeyypeW-ykuW4zSGZ4yLZvBgRXrjzghs-M7EGHD2lKg8OkOA9k2EJ018AzCtBfXTAHnjzn5o4hPCCpQSHkYKakMhpb9mFgIYYYK6HsYL6AvISU4n29GOdFoP+RhzIeasyNmUqzKOQALrmZ1yfiRnzUTvRI52TGTbuZjz7uWoi94PAKUhQii94bqis9HvAtFmWQv2b6i1LF8YV4Fot9eeNpVrjXycGfILGoPgylBewKREKoKFmSDS5WBYLIJlYLghgyN5EPoLVxKg9GkJ0gkoD4Cnjq2txKKa9tBRYMtYdpA7BXBhuhWrRehdBgBzq4KCYVMKyHl4L6UYYBFWk0RdnrhyVmYELLsVDyduUEzDuThz4aQjyIhX+yuudEK5FrELSWY8yEhRSzoBdpz7NBVdF6uuSRmaL4ZuZ9TKhWj9WBczTXGfMzM+IsyNBUMLc3iMKPHg8BE4PYLUHrZAZhS2g5hRMTmhQ6dG2Qh8StsqdJhTQ9IRZ4LZhS4KBlBCKlhRV5vBXy4bhYK4AhVhyv+XsKYebJS4ef-yTuScKdOWcKD4W4j0ICMgYUf1T3Ob7yE0Uuz7hY9zk4HpRU6Qjd6QbFCC+T5DjIbTUDITmITOfN4ffnSyPhfqFnGcoKMEPUK-hY0LNBcMLLBc+Sm2VQA9BS+wuhTQ8wHk4KwuP0KoOrCLlRS0LVRTeMqALYLvsCiL8kDqLmkPqLLJsD9UHtaLskLiKVhfl4-BYTYiRfty1mVhyQhS7jKRccLamCzyXOVCiGRbjAMUKmo4hRjS7uWJzyMZSZMkTyKQoX0D+RYclBRfpDSwlqgXhaniqkHILEYAoKvhdbyuWfKKyGQCL6UHCKkYQiLjrsQMNReCKaHng90RdCLMRa8ySxUaL4RXjy29OaLqxfkhaxbqLPoDCL7RTWL0jL0LnRc6i93vBB1hXc9NhehziRXtzv+dhzQhfDzJ2TRy7ec1NGIKTpoUWGLmRejTWReBjhqb+zs6U9D4xbCFUAKmKBRXCYhRcoI0xRxhtVME49VLFoLUme83hfYy5uX18FCZFzNqQhy7OSiSEuftT2+d4zeWVOKghesyRKXOK-RQuKzucjzHIJlob3vQBIBZjToxeCpHhdOtGWsWgk6jkwAtgj12cSuilAJpwoaG0zV0UJIWtAm1nUr6iibDwYz3lhhXiVhKcJeuSUnAYzzQA7oTOS9cHxRMzcGVULpmV+LAMYWL1BcZg5NAhKWlqbJHURmL65E8KPwS9dkOqFMAoBh0IkIL9nmO9c0foX4xfs-iUqoQ4qyGaKuTCryxTFFR7FuaCCqJQMMubpBsuYZoMOp4tnGOkDoDJkCRUYb5Jgj00j7pqCXrvZ5UgvSdaQp3NAGMycffCoAroOYECop8Y7WK5g7uLZL4OvhDcwS9cfIa+AGIAIj4QlREPyJFCYQtjowpZ1IIpVrEopWrx-JY1BApYKDgpXCZQpagBZkglLf+sQlopVTVYpdlLMErlLrkrh8iiClKIYpVKQpdigwpRDpSpbuUq4AVKEbkVLKcQ1LSqnZ8KpZuCfvmlKWCpyAapTWgwpUQT2pfYEwGrSRmpYitWpcNKsIdqkJGohDupQFKUIX1KchMlCspWi11iHcT+QA8S4ACNLfGv40oANtKJpTiA89ENLbiftLtpbtKzpfcTcCpfF5pUFLFpSJKysANKowGFLFYjepsQDNKMEleolYkdLWpW9KXyCNL-pVOo7pelKHpdVLMpbVLspfhFXoiNLoZeDFfpSdKoZQuoCIpVBYZcjKKYslKFpalKlpb9B+pRDLBpdlLH6Z5DPpSHkiZQjK6AGFKiZSNKyZZjL7pdjLHpXjKYamtLgxoDLCRuTKgwMVLCRqzKhxp1K-JVjKqpfzLnpYLVOZTzKd2dzL-+juz2Za9LuJg2RxZdCNlxCDLlpaahwZUzKw-GFK09tlK7KX7gRpbRdzIQjc1pRrLvJuLNlAPZSdZcbKpZdlLDZVrLJAGbLdPl1K6ZQLKHZULL3mI1FUXo4ARpeZ8LZa7KtZu7KSZUIc3ZRZ97ZaDL6ZSrLVpZDKqCrDKx4nrLJpYjKI5X7L7DkvtaZcHLHZcnLnZWFLx6bJARpRnKvZRnKs5YBSy9knKlZb1LcZStKooWtLh9jbL45S5AK5XZ8fIa1Ka5XnLonL9JFZSXLlZYLL8ZS9LspQ-t1DsppG5SJoe5awwc5QpoB5eIA+5Y-tB5YXLW5cXKMpUzLw5cIctNmIcPZf4QF5V6SvZfPLRDl6Sl5SIcxDi3KepTjKZ5WHKCZa4cRaCNKtSlF9o5cdKKZdlKz5b7KOMH34b5YHK+ZQ7K25U7KO5cLKvNK6gRpZywvZZywv5a6hd5WDL25bPKj5TehfqNTKWALegvZaAqPUOAr+5r9QmeDZL+ZUFsufAVoNoE3BAaY-AjZjrCBSlj8EcPyVKHHzCUBegrvRqwwP9BfAAgAoMq4LwNXFrcCEBUzAP4OfBlAJfAFBgVpDcDX4s1PQh34LaAQ0TXMfrjMhgAFIE-4EAgQEEYUSQJAhYEPAhEEMghd0gvoyOnMIDQDHtBwnEA-uDeEozBWAqQGR0xop6NOFdAAP4D8E5AlDlYQCQrOKHdC-gtWD6UCkgEolKAhoJMRWABWgdFQshbQHRMxFYhZTQLYrEuIpgEAuAhtHnKwHFXorvFcwAoELYqnhFMFDMPPIHUHMgC2AEr+4bcDrDjQxwHHug4IgPgNHvmjhrlwreAM4qIEEEqEoqyg5oY4D7PJhMhKIYBBwgkrbII3gSLAEqcbspYizBoq4gPYFBClvRNcCUqxFYyJSlVUrL4skrAlYJxWfHtBKlUkraQPegoEPgA+0Mg41+LUq3gKNKIHDcE1FrIw-FU4qwtOmKxpJoqm4BTBAoPc0WYMxoWEnSNIEV-hlgSC1ooPE19pRlt1pWyBNpQE0bpTQ0PoSSUQkKc16mrNU2AXUptqHvzDyd7M0mkClsAJk1smuBoMhZYkw1v5M6qrU07lXQ4C1E1Anoi4BWBqpUOfg15BKGOJyLMvI0pDIDVRLXU2vEeIGHjXV7QnXUhmhGDZHKM0ZQASBvRtwAWoPiq5wIXsuQO1likqhUqqjirdmjPVD2kc0HSlSRwnA3NommOJBADskIwCPApAmBAvSNo45WICrzmiKI28WENblec0s7C4ArmlwYhOIItBCM3M2MjioHqBjFryAwdksNZZXmsnxuiPYA0ICekjNm9t-mk+EdSEC1RyKC0rlRC0aAB-oJUDdtvAGht8tu-jRmi-8x-DC1T+KvYh2sOh+VbvJebKi0dSBi03BNi1cWs01nCqegUiQw0SWqm0yWhS0QAFS0gwGyyoGo80mWt-iBueLg36DFRRAM+9JKL1g4Gp-UYAAy1+UEy1IKKy0+YuI0OWjGrroHI1QAnZQRuQCqRVe6rkFYjAbWGMRaoShoEFujF+Skdh0ZeDFslqrFCeRLgdVDhVtaWmcwIBwApcP0gvvrSYM8ESpMVH5AiQnWreVA2qDWL+pFoMcqgZR+kO1ROM+1VSMeALoBhyBIB-1KFNB1YhBqACOqsgGOq0gBOrsjp2BFoP64tdvmlgmtSpXjg0x8VaXNiVRcol4m6VXFWpZ8UtUcgGU8Q3XAhEEjN+rkjJzCGmKFhr9g8VyOKFgcIrWrYQPWqq+bg4qRiUAiAEQAJwDZhsGOcAfOXmVjyMcrgNsZtYfMfMXeHSZcYAdAv3q6AzDlAAGTA+sz3owkz3kJYFphBsUcGyBUwTqZRwOtAqyGhLQ9GSZRwKXNcgjvhS5vvgtCOGBS5kZsMIAgdp1dxBBoqoBqmCIZi0Iq1ioJCBdIGSZ4MAJq6AGqqG+AY47vqETizDqZmNeIBWNfxrCVbfxaAL3AvMKpqn1tMAhlTAgzkDoBvtONgWIETBnTGtBkUj1BlIOASs9DdczNSRqnYVE5T1thrWQIA1F-ihKonKxqzkCRYrNdMAbNcoA7NcEAHNTAAnNRoBNOC5qz3iHx3NRsdPNT81YfL5r84f5qUgIFqPIJmZnjDddwwCFrQnLZqQuFFqYtXFriOK5rBOElqb8ClrvNWAB0tfWhMtU3K1NTlqXjOGxUjLaYFHOhLCtWFqItaVrS0OVqXNDddqtVhqAeD5qyRhlr9pRlYAtVRrWtZmYtNTpq4cGe85tSWYLQDqZ4MLXhFNbQBbYtCiZ2HtCttcprZGERrFgDOxsANRqdTChtBKOzxHecZtAfnpR+UKNrYfKZB+0RS5aTIyLRQdjCIAvYAFELyoHyMdreBkoAPFqoBq5o6YFBl-ghBY-hFyW81+KP9r60AWx-GD9qq5AqQqAIyZsGFMc8sFdTP9MuZdMD9dpAMQjSLiiRMQmSZSzJqZHkFtrNOMjqGUCGLntJ8xCsFtqdtdTrjyOdqXjO1B8dX8ycSO0iEokzxctW9qHyLyhOdWwQaIDzohwoAhZILHtymMQihdb3oAYoxAESsi4RdWLqIoNUBe4K4BZdFoBYCjLqEShFASAMMClQOrrOtQDcIQIvhDADdrD8LVqxtWABTIEJRS+eAsvht9dqEALreVJ4QVyE0RplQvgjArtr-Mb5hGdUjqWoCjqPEBrytcB9r0eAdAHtcKAYvETrizCTrnjApq9NZ8haABTq-de9jv3uQEeSHTq49Upq3msnrXQOpqedbDrTtsTq1tS8YqSA0VClL4RxgEJDDGhRxVrC5EtAHXqVsEmBCAJ6EwQDwAwQNaB6QLoBg0TShUAJFAOZfagGID0IB9YVoe9cQdkYAPq6Fg8AsgBcA2yC3rMAEk1vsNfhO9eSQ1YofQcAKfxV9bcBQIHQsbmsWZoUbmBGdRnwAOKiJtwDqZ89S+AD9YhxwQntAqdfhqiYIhYZSJas+QbDqT9ZCYfdefrb9coAQ+CtrfmfUi+vPJqisEYQ6ABbrpgKpzdtczq8tYv8jdSqBTdY9rWQKZBRADbqunAVoUZkohhfBRQm2K7qGYjMqb9YyLtFlxAOABQAxBeZBaTkIt7QEaAWIOUBBwvYQw9Q7gMEQ7pC9QKBGNSNBaQHC92dQ5FwAHTRocLh5NUBnxiwI7h2NZ9FgTDohFMFvdsoXEpu4LZ5ygNzhAEJIgucP-A2ICxB54JIa54NUBygAIanOBAg1Gj+NsAKIaLbuIbJDdIbZDd3B5DYoblDUax1DdBAUgHb02eKksRDZPdGbvobmIIYajQHIaFDUobAEAaBXAJxBiehYbj0OIAjQO1sElnYasoXoapDQYbgUEYaTDUobuMLHsjQK4AiIBYbStL75H1jYaqyPZ5dDQ4awjU4aIjS4bjDW4aJIGAKKDa4A+4BYbSKKORlILhAUjcyFPtAxsEtLKwmDUXJXgVJgWDdBxoUYRqeVCnqX9cJZzAP4b2tmUaqGq-BRtEXqszJwaS0EIaxrNBx+UJWYWWuNoWhETBfqN3BpTg8kwCfEAAIEIbtGJJQTYjzrYQOsauckFBoSB6hFjWxqo9V0b+YMC0xjdwMJjVhhpjWC1l1HMaDjcoBAEHdqP9CsbYdHeRuBhsb6cJ1qdjR8a9jZDdfqE8aeBitrEcjqZ+jVcb+UAao81bMbRJZeZctUkaVAFUaP0JIIajd9p1II5hODRUagII+sVtTqYDVNYbz9ZyBgTRpAdTNltNkCmAMGC1ARUJ1q-cgQcKAozqxAozr2jUrBXQCRZYdYRqOQN+ddIAEaPpneRxsARVeTdMB1LJob+TZobXzFYaysCRY8TYfz4TcoBH1pKbhtMkaEtOfhaAHiZgWr3A7gODNxhaJQSLANgpcDAB8TZmsAKCWYBEDqZo9ZAj8VdABWNcZrxsFEhyTRIBxYZ1rRwBaaoAJE4stWe9S1uRq7vtgAdAJab3TVBk-NVNqJja6bmtSZrjjTzqgYERgXAqCgJANWR+UD5wjbmxBF4JqiedWCatNRdZIzRABozQBQcTS8ZOtQtr3TTKAetcVrg6P1rnNcRx8zXd8DoM6bgzaxrr8FpretQ15u4C6aZtXd8GtWNFvEGbq3TZWbTFacadTH8r7QPWbbNY2bmzV2bQzVSaNNblqAblhr+zQbAeUrvYsYFmbJAAOkHkrp08VDIawjSxAiILOZpzWcgwjfPAwUDIawTZykITXqb+UIQBzzdgBqgAkMKDePZLDfqb4Orvd9DWCbBjfH0ZDVeaiIDeaEjROaedd0byOLqbxTY1ARcBOtezblqCheNpoAHOaftYubCqhVhOtT+aXjIbrd7KHgsMLAbLdWchbzNgAtNZYAAAKT0AXC30oOI2zmbC3HkNR64WvNWm7e02NRZjhtGqbbYGii28dfUzP62014MBi3McQY2nQedC6QKM0xm2Ar8oGPCR6+C3wW9hX5wwNaL-MloxapUDVmls2hmyjXdm-FX0Wk5LpiuC2CWqS2jm8bB6qthjY6WS0yW7ADyWu02UmpS3fmwMxgW5dQQW77VYwdU0wAaC3Lmw9iCWn82IWxfB-IMPUpALzUW60yAYW7yhYW1QD4W-C1KgQi3YAYi1nIOixkWlloKWqi1SUGi1u6-gLqLeVj6W+tCMWjo0565i0Um+K1sWt+TeMDM2Lm3i0gAd1AR6+g1GWuy1SoJODcWz4zwWayaO6x5TbUMiC94VqI5W4YHp3HQBxmqFCgoVwBi6n5QkWflAkAeeAj3WoBqGpHouATq3dW5m5eGn5R49QBDzwfTphGgFDrmwcIyGkgApoOeAkAfTqAIYa1c3Rm69wTiBhG5XWq62zzNW1q2yQZS3wW1M0xm9M3FWzM08WnM12W54wVm0M3JsQ60-mwc3ha4c01ms94aW9Cn7kgq1tazAExm7LWda5QJvW7HSnGs00OW5C3OWqGapauA2HYBrw4W6ij+WwK2kWyMZXYF8h5qqK2GBGK27aqHJcm9K2o2wXAxW5-XZW-i35Wssw2KRf7Tm8bR0ASC1YwTU1OIGC2wmzMykgqU2AWw03ThYE23G6zRmW+c3Ogam3O6my0G6xf6iWjdGd0UoZM6SZBVmsk0sWxS1A2sW2+m7s3Da3S3i2lK1E4KsxPfFUaAEdqaQItPzFoVC3q4eDWEARDUfoFDUJ5Z5APlKzTjoIs3hakrUswMrXxa2W13rMUINQXuCgEXhWHwWs0GwcoDkjFRXb4Ei22WlnWdgTjVsGlUA8a3woiaoXKWACTWwaqTX0AGTWlQRrzFmdNHu2hACe2vQiqAHkiFLOm2BmFJAJ65dQygcnUua8kbIuTaXDqz4ZRgTAYLTOgCDa1LBi3aiSyo6UEuQYY2BmeO0e25xyqAU-j7QrO0mMcA2BmS7URAa7XYoQE2LiKQKO20CA3g57UopGkypHUlQCW0C1FuC7DkjW0Jt2iu38gTu0XagWA92yQQ3a-u16UQe294Ee0dLfWCpHHX772KrBfiO1imwKDhT2zMxmml8QXags3YAAAB+d9vy1PJAft9usKgrGpW1F2HdND2n-QPtszM3dpaJEQA3td2um0qSgdtO9oWmpkFlRZcArgr2sf0awCgwsfl3MXWvuAcEQvtq2sYNLxhS0d3w8gP1mjtz9AuineqqaT6DQihsxMwNIGv895D4o5kDl+T5Du1xWxawMcnVCiJWxh0mhZw+OnmACuPQAeCNYAExs3t2Sxm0aIR2YOvCgkAjrdOd2q6BfIi+pPumk0XWAEBHgxh+awAGyyOloAyENEdT4NEdd-E3tjgNEgZ4HRZAjvDAojpD+hEuNFyMMu0KjtBChCx+ca-Eam08yaIAjv9OepobsHlG10U2uQAoACT44QBNAOsFoAyAFgFcY2UAzjutGLfmi140T4AyACAaIAGTU5AEmIoOtKGRA2OAOwD8gvjtIkzjtSQRQBgAPKSqAHAGQAfSj2gIADXgVIABQ75kf8jEHNgskAGQOTqfEeToKdK4on5cAFwAK4MqduBDyduvN8dBVGcdihx11IBWQAkgxad9gCUAJACdAGgF8ddymYACwGcdapjnN8QF8d1oF0AAbICdeTv1cmTt4A2TqQAuTtnpbBGoA4TrvEeTog8kgAadfxiadSgDydwxC6dwgGQAvnXURToExUZ+RDFvjsRizjqrglQACIRzoIKW8CAAA)

```jsx
// Q1. Why is formatting for this file so messed up? - it's created on the road
// If you want to know more - https://github.com/kelaberetiv/TagUI/issues/490

// Q2. Is there a beautified version for easier viewing or editing? - yes snapshot below
// https://github.com/kelaberetiv/TagUI/blob/master/src/media/snapshots/tagui_header.md

// xpath for object identification
var xps666 = require("casper").selectXPath;

// assign parameters to p1-p9 variables
var p1 = casper.cli.raw.get(0);
var p2 = casper.cli.raw.get(1);
var p3 = casper.cli.raw.get(2);
var p4 = casper.cli.raw.get(3);
var p5 = casper.cli.raw.get(4);
var p6 = casper.cli.raw.get(5);
var p7 = casper.cli.raw.get(6);
var p8 = casper.cli.raw.get(7);
var p9 = casper.cli.raw.get(8);

// save start time to measure execution time
var automation_start_time = Date.now();
casper.echo("\nSTART - automation started - " + Date().toLocaleString());

// initialise time for timer() function
var timer_start_time = Date.now();

// infinity constant for use in for loops
var infinity = 1024;

// initialise default global variables
var quiet_mode = false;
var save_text_count = 0;
var snap_image_count = 0;

// counters for tracking messages in r, python, sikuli, chrome integrations
var r_count = 0;
var py_count = 0;
var sikuli_count = 0;
var chrome_id = 0;

// chrome context for frame handling and targetid for popup handling
var chrome_context = "document";
var chrome_targetid = "";

// variables to track frame offset if current context is within a frame
var frame_step_offset_x = 0;
var frame_step_offset_y = 0;
var original_frame_step_offset_x = 0;
var original_frame_step_offset_y = 0;

// variable for ask step to accept user input
var ask_result = "";

// JSON variable to pass variables into browser DOM
var dom_json = {};
var dom_result = "";

// variable for advance usage of api step
var api_config = { method: "GET", header: [], body: {} };

// variables for api and run steps execution result
var api_result = "";
var api_json = {};
var run_result = "";
var run_json = {};

// variables for R and Python integration execution result
var r_result = "";
var r_json = {};
var py_result = "";
var py_json = {};

// track begin-finish blocks for integrations eg - py, r, run, vision, js, dom
var inside_py_block = 0;
var inside_r_block = 0;
var inside_run_block = 0;
var inside_vision_block = 0;
var inside_js_block = 0;
var inside_dom_block = 0;

// determine how many casper.then steps to skip
function teleport_distance(teleport_marker) {
  number_to_hop = 0;
  if (teleport_marker.indexOf("[BREAK_SIGNAL]") > -1) {
    for (s = casper.steps.length - 1; s >= 0; s--) {
      if (
        casper.steps[s].toString() ==
        "function () {for_loop_signal = '" + teleport_marker + "';}"
      ) {
        number_to_hop = s;
        break;
      }
    }
  } // search backward direction for break step
  else if (teleport_marker.indexOf("[CONTINUE_SIGNAL]") > -1) {
    for (s = casper.step; s <= casper.steps.length - 1; s++) {
      if (
        casper.steps[s].toString() ==
        "function () {for_loop_signal = '" + teleport_marker + "';}"
      ) {
        number_to_hop = s;
        break;
      }
    } // search forward direction for continue step
    if (number_to_hop == 0) {
      for (s = casper.steps.length - 1; s >= 0; s--) {
        if (
          casper.steps[s].toString() ==
          "function () {for_loop_signal = '" +
            teleport_marker.replace("[CONTINUE_SIGNAL]", "[BREAK_SIGNAL]") +
            "';}"
        ) {
          number_to_hop = s;
          break;
        }
      }
    }
  } // handle as break if no step left to continue
  else return 0;
  if (number_to_hop - casper.step > 0) return number_to_hop - casper.step;
  else return 0;
}

// techo function for handling quiet option
function techo(echo_string) {
  if (!quiet_mode) {
    // mute about:blank, eg for desktop automation
    if (echo_string == "about:blank - \n" || echo_string == "\nabout:blank - ")
      casper.echo("");
    else if (tagui_language.toLowerCase() == "english")
      casper.echo(echo_string);
    else {
      var translated_string = translate(
        echo_string,
        "to",
        tagui_language.toLowerCase()
      );
      casper.echo(translated_string);
      if (translated_string.indexOf("ERROR - translation engine") !== -1)
        casper.exit();
    }
  }
  return;
}

// for muting echo in test automation scripts
function dummy_echo(muted_string) {
  return;
}

// for saving text information to file
function save_text(file_name, info_text) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  if (!file_name) {
    save_text_count++;
    file_name = flow_path + ds + "text" + save_text_count.toString() + ".txt";
  }
  var fs = require("fs");
  fs.write(file_name, info_text, "w");
}

// for appending text information to file
function append_text(file_name, info_text) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  if (!file_name) {
    if (save_text_count == 0) save_text_count++; // increment if 0, else use same count to append
    file_name = flow_path + ds + "text" + save_text_count.toString() + ".txt";
  }
  var fs = require("fs");
  fs.write(file_name, info_text + "\r\n", "a");
}

// for saving snapshots of website to file
function snap_image() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  snap_image_count++;
  return flow_path + ds + "snap" + snap_image_count.toString() + ".png";
}

// for saving table from website to file
function save_table(file_name, selector) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  if (!file_name) {
    save_text_count++;
    file_name = flow_path + ds + "table" + save_text_count.toString() + ".csv";
  }
  var row_data = "";
  var table_cell = "";
  var fs = require("fs");
  fs.write(file_name, "", "w"); // always reset file
  if (
    !casper.exists(selector) ||
    selector.toString().indexOf("xpath selector: ") == -1
  )
    return false; // exit if invalid
  if (selector.toString().length == 16) selector = "";
  else selector = selector.toString().substring(16); // get xpath
  for (table_row = 1; table_row <= 1024; table_row++) {
    row_data = "";
    for (table_col = 1; table_col <= 1024; table_col++) {
      table_cell = "(((" + selector + "//tr)[" + table_row + "]//th)" + "|"; // build cell xpath selector to include
      table_cell +=
        "((" + selector + "//tr)[" + table_row + "]//td))[" + table_col + "]"; // both td and td elements
      if (casper.exists(xps666(table_cell)))
        row_data =
          row_data + '","' + casper.fetchText(xps666(table_cell)).trim();
      else break;
    } // if searching for table cells (th and td) is not successful,  means end of row is reached
    if (row_data.substr(0, 2) == '",') {
      row_data = row_data.substr(2);
      row_data += '"';
      append_text(file_name, row_data);
    } else return true;
  }
} // if '",' is not found, means end of table is reached as there is no cell found in row

// for translating multi-language flows (comments in translate.php)
function translate(script_line, direction, language) {
  var start_keywords =
    "|click|tap|move|hover|type|enter|select|choose|read|fetch|show|print|save|echo|dump|write|snap|table|mouse|keyboard|" +
    "wait|live|download|upload|load|receive|frame|popup|timeout|api|dom|js|vision|else if|else|if|for|while|check|";
  var to_separator_keywords =
    "|read|fetch|save|load|dump|write|snap|table|download|receive|for|";
  var as_separator_keywords = "|type|enter|select|choose|upload|";
  var forloop_keywords = "|from|";
  var start_conditions_keywords = "|else if|if|for|while|check|";
  var start_helper_keywords = "|echo|dump|write|";
  var conditions_keywords =
    "|more than or equals to|more than or equal to|greater than or equals to|greater than or equal to|higher than or equals to|higher than or equal to|less than or equals to|less than or equal to|lesser than or equals to|lesser than or equal to|lower than or equals to|lower than or equal to|more than|greater than|higher than|less than|lesser than|lower than|not equals to|not equal to|equals to|equal to|not contains|not contain|contains|contain|and|or|";
  var helper_keywords =
    "|title()|url()|text()|timer()|count()|present()|visible()|mouse_" +
    "xy()|mouse_" +
    "x()|mouse_" +
    "y()|"; // break up mouse_ helper functions to avoid mistaken triggering by tagui_parse.php as sikuli process needed
  var seconds_keywords = "|seconds|second|";
  var start_seconds_keywords = "|wait|timeout|";
  if (!script_line || script_line == "") return "";
  if (!direction || direction == "")
    return "ERROR - translation engine direction parameter missing";
  if (!language || language == "")
    return "ERROR - translation engine language parameter missing";
  if (script_line == "" || script_line == "\r\n" || script_line == "\n")
    return script_line;
  var front_script_line_return = "";
  if (script_line.charAt(0) == "\n") front_script_line_return = "\n";
  var back_script_line_return = "";
  if (script_line.substr(-1) == "\n") back_script_line_return = "\n";
  direction = direction.toLowerCase();
  if (direction !== "to" && direction !== "from")
    return "ERROR - translation engine direction must be to or from";
  if (direction == "from") {
    var column_from = 1;
    var column_to = 0;
  } else {
    var column_from = 0;
    var column_to = 1;
  }
  language = language.toLowerCase();
  var language_count = 0;
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var language_file = "languages" + ds + language + ".csv";
  var fs = require("fs");
  if (!fs.exists(language_file))
    return "ERROR - translation engine " + language + ".csv file missing";
  else {
    var language_raw = fs.read(language_file);
    if (language_raw.indexOf("\r\n") !== -1)
      var language_data = language_raw.split(/\r\n/).map(function(line) {
        return line.split(",");
      });
    else
      var language_data = language_raw.split(/\n/).map(function(line) {
        return line.split(",");
      });
    language_count = language_data.length - 1;
    if (
      !language_data[language_count][0] ||
      language_data[language_count][0] == ""
    )
      language_count--;
  }
  script_line = "[START_OF_LINE]" + script_line.trim() + "[END_OF_LINE]";
  var start_word = "[NOT_ASSIGNED]";
  for (language_check = 1; language_check <= language_count; language_check++) {
    if (
      start_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (start_word !== "[NOT_ASSIGNED]") continue;
      if (
        script_line.indexOf(
          "[START_OF_LINE]" + language_data[language_check][column_from] + " "
        ) !== -1 ||
        script_line.indexOf(
          "[START_OF_LINE]" +
            language_data[language_check][column_from] +
            "[END_OF_LINE]"
        ) !== -1
      )
        start_word = language_data[language_check][0];
      var regex = new RegExp(
        "\\[START_OF_LINE\\]" +
          language_data[language_check][column_from] +
          " ",
        "g"
      );
      script_line = script_line.replace(
        regex,
        "[START_OF_LINE]" + language_data[language_check][column_to] + " "
      );
      var regex = new RegExp(
        "\\[START_OF_LINE\\]" +
          language_data[language_check][column_from] +
          "\\[END_OF_LINE\\]",
        "g"
      );
      script_line = script_line.replace(
        regex,
        "[START_OF_LINE]" +
          language_data[language_check][column_to] +
          "[END_OF_LINE]"
      );
    } else if (
      conditions_keywords.indexOf(
        "|" + language_data[language_check][0] + "|"
      ) !== -1
    ) {
      if (start_word == "check") {
        var array_script_line = script_line.split("|");
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        array_script_line[0] = array_script_line[0].replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
        script_line = array_script_line.join("|");
      } else if (
        start_word !== "[NOT_ASSIGNED]" &&
        start_conditions_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (
      seconds_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (
        start_word !== "[NOT_ASSIGNED]" &&
        start_seconds_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " +
            language_data[language_check][column_from] +
            "\\[END_OF_LINE\\]",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + "[END_OF_LINE]"
        );
      }
    } else if (
      forloop_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (start_word == "for") {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (language_data[language_check][0] == "to") {
      if (
        start_word !== "[NOT_ASSIGNED]" &&
        to_separator_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (language_data[language_check][0] == "as") {
      if (
        start_word !== "[NOT_ASSIGNED]" &&
        as_separator_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (
      helper_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (
        (start_word !== "[NOT_ASSIGNED]" &&
          start_conditions_keywords.indexOf("|" + start_word + "|") !== -1) ||
        (start_word !== "[NOT_ASSIGNED]" &&
          start_helper_keywords.indexOf("|" + start_word + "|") !== -1) ||
        script_line.indexOf("=") !== -1
      ) {
        var regex = new RegExp(
          (" " + language_data[language_check][column_from])
            .replace("(", "\\(")
            .replace(")", ""),
          "g"
        );
        script_line = script_line.replace(
          regex,
          (" " + language_data[language_check][column_to]).replace(")", "")
        );
      }
    }
  }
  script_line = script_line
    .replace("[START_OF_LINE]", "")
    .replace("[END_OF_LINE]", "");
  return (
    front_script_line_return + script_line.trim() + back_script_line_return
  );
}

// for checking if selector is xpath selector
function is_xpath_selector(selector) {
  if (selector.length == 0) return false;
  if (selector.indexOf("/") == 0 || selector.indexOf("(") == 0) return true;
  return false;
}

// for finding best match for given locator
function tx(locator) {
  if (is_xpath_selector(locator)) return xps666(locator);
  if (casper.exists(locator)) return locator; // check for css locator
  // first check for exact match then check for containing string
  if (casper.exists(xps666('//*[@id="' + locator + '"]')))
    return xps666('//*[@id="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@id,"' + locator + '")]')))
    return xps666('//*[contains(@id,"' + locator + '")]');
  if (casper.exists(xps666('//*[@name="' + locator + '"]')))
    return xps666('//*[@name="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@name,"' + locator + '")]')))
    return xps666('//*[contains(@name,"' + locator + '")]');
  if (casper.exists(xps666('//*[@class="' + locator + '"]')))
    return xps666('//*[@class="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@class,"' + locator + '")]')))
    return xps666('//*[contains(@class,"' + locator + '")]');
  if (casper.exists(xps666('//*[@title="' + locator + '"]')))
    return xps666('//*[@title="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@title,"' + locator + '")]')))
    return xps666('//*[contains(@title,"' + locator + '")]');
  if (casper.exists(xps666('//*[@aria-label="' + locator + '"]')))
    return xps666('//*[@aria-label="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@aria-label,"' + locator + '")]')))
    return xps666('//*[contains(@aria-label,"' + locator + '")]');
  if (casper.exists(xps666('//*[text()="' + locator + '"]')))
    return xps666('//*[text()="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(text(),"' + locator + '")]')))
    return xps666('//*[contains(text(),"' + locator + '")]');
  if (casper.exists(xps666('//*[@href="' + locator + '"]')))
    return xps666('//*[@href="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@href,"' + locator + '")]')))
    return xps666('//*[contains(@href,"' + locator + '")]');
  return xps666("/html");
}

// for checking if given locator is found
function check_tx(locator) {
  if (is_xpath_selector(locator)) {
    if (casper.exists(xps666(locator))) return true;
    else return false;
  }
  if (casper.exists(locator)) return true; // check for css locator
  // first check for exact match then check for containing string
  if (casper.exists(xps666('//*[@id="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@id,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@name="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@name,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@class="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@class,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@title="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@title,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@aria-label="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@aria-label,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[text()="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(text(),"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@href="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@href,"' + locator + '")]')))
    return true;
  return false;
}

/**
 * Extra TagUI helper methods
 */

// friendlier name to use check_tx() in if condition in flow
function present(element_locator) {
  if (!element_locator) return false;
  if (is_sikuli(element_locator)) {
    var abs_param = abs_file(element_locator);
    var fs = require("fs");
    if (!fs.exists(abs_param)) {
      casper.echo("ERROR - cannot find image file for present step").exit();
    }
    if (sikuli_step("present " + abs_param)) return true;
    else return false;
  } else return check_tx(element_locator);
}

// friendlier name to check element visibility using elementVisible()
function visible(element_locator) {
  if (!element_locator) return false;
  if (is_sikuli(element_locator)) {
    var abs_param = abs_file(element_locator);
    var fs = require("fs");
    if (!fs.exists(abs_param)) {
      casper.echo("ERROR - cannot find image file for visible step").exit();
    }
    if (sikuli_step("visible " + abs_param)) return true;
    else return false;
  } else {
    var element_located = tx(element_locator);
    var element_visible = casper.elementVisible(element_located);
    // if tx() returns xps666('/html') means that the element is not found, so set element_visible to false
    if (element_located.toString() == xps666("/html").toString())
      element_visible = false;
    return element_visible;
  }
}

// friendlier name to count elements using countElements()
function count(element_locator) {
  if (!element_locator) return 0;
  var element_located = tx(element_locator);
  var element_count = casper.countElements(element_located);
  // if tx() returns xps666('/html') means that the element is not found, so set element_count to 0
  if (element_located.toString() == xps666("/html").toString())
    element_count = 0;
  return element_count;
}

// friendlier name to get web page title using getTitle()
function title() {
  return casper.getTitle();
}

// friendlier name to get web page url using getCurrentUrl()
function url() {
  return casper.getCurrentUrl();
}

// friendlier name to get web page text content using evaluate()
function text() {
  return casper.evaluate(function() {
    return document.body.innerText || document.body.textContent;
  });
}

function timer() {
  // return time elapsed in seconds between calls
  var time_elapsed = (Date.now() - timer_start_time) / 1000;
  timer_start_time = Date.now();
  return time_elapsed;
}

function sleep(ms) {
  // helper to add delay during loops
  var time_now = new Date().getTime();
  var time_end = time_now + ms;
  while (time_now < time_end) {
    time_now = new Date().getTime();
  }
}

// return x,y coordinates of mouse cursor as string '(x,y)'
mouse_xy = function() {
  // use this function declaration style for sikuli detection in tagui_parse.php
  sikuli_step(
    "vision xy_mouseLocation = Env.getMouseLocation(); " +
      "xy_x = xy_mouseLocation.getX(); xy_y = xy_mouseLocation.getY(); " +
      "output_sikuli_text('(' + str(xy_x) + ',' + str(xy_y) + ')');"
  );
  var xy_result = fetch_sikuli_text();
  clear_sikuli_text();
  return xy_result;
};

// return x coordinate of mouse cursor as integer number
mouse_x = function() {
  // use this function declaration style for sikuli detection in tagui_parse.php
  sikuli_step(
    "vision xy_mouseLocation = Env.getMouseLocation(); output_sikuli_text(str(xy_mouseLocation.getX()));"
  );
  var x_result = parseInt(fetch_sikuli_text());
  clear_sikuli_text();
  return x_result;
};

// return y coordinate of mouse cursor as integer number
mouse_y = function() {
  // use this function declaration style for sikuli detection in tagui_parse.php
  sikuli_step(
    "vision xy_mouseLocation = Env.getMouseLocation(); output_sikuli_text(str(xy_mouseLocation.getY()));"
  );
  var y_result = parseInt(fetch_sikuli_text());
  clear_sikuli_text();
  return y_result;
};

// get text from clipboard or set text to clipboard
clipboard = function(clipboard_text) {
  // use this function declaration style for sikuli detection in tagui_parse.php
  if (!clipboard_text) {
    sikuli_step("vision output_sikuli_text(App.getClipboard())");
    var clipboard_result = fetch_sikuli_text();
    clear_sikuli_text();
    return clipboard_result;
  } else {
    vision_step('clipboard_text = "' + escape_bs(clipboard_text) + '"'); // escape_bs() for \n \t etc
    sikuli_step("vision App.setClipboard(clipboard_text)");
  }
};

/**
 * string cell data sanitiser, returns a CSV formatted string
 * @param {string} cell_data
 */
function sanitise_csv_cell(cell_data) {
  // Replace all double quotes with 2 double quotes
  cell_data = cell_data.replace(/"/g, '""');
  var whitespaceCheckRegex = /\s/;
  // if cell_data has a comma, or new line, or its first or last character is a
  // whitespace, then wrap the entire expression in double quotes
  if (
    cell_data.indexOf(",") >= 0 ||
    cell_data.indexOf("\n") >= 0 ||
    whitespaceCheckRegex.test(cell_data.charAt(0)) ||
    whitespaceCheckRegex.test(cell_data.charAt(cell_data.length - 1))
  ) {
    cell_data = '"' + cell_data + '"';
  }
  return cell_data;
}

/**
 * Returns a CSV-formatted string that denotes a row in a CSV file
 * @param {string[]} row_data a 1-D array of strings denoting data to
 * encode as a CSV row
 */
function csv_row(row_data) {
  // if row_data has at least 1 element, extract and sanitise first element
  // else start_element is empty string
  var start_element =
    row_data.length > 0 ? sanitise_csv_cell(row_data.shift()) : "";
  // concat each row_data with a comma
  return row_data.reduce(function(accumulator, currentValue) {
    return accumulator + "," + sanitise_csv_cell(currentValue);
  }, start_element);
}

// for initialising integration with sikuli visual automation
function sikuli_handshake() {
  // techo('[connecting to sikuli process]');
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  clear_sikuli_text();
  var fs = require("fs");
  fs.write("tagui.sikuli" + ds + "tagui_sikuli.in", "", "w");
  var sikuli_handshake = "";
  if (!fs.exists("tagui.sikuli" + ds + "tagui_sikuli.out"))
    fs.write("tagui.sikuli" + ds + "tagui_sikuli.out", "", "w");
  do {
    sleep(500);
    sikuli_handshake = fs.read("tagui.sikuli" + ds + "tagui_sikuli.out").trim();
  } while (sikuli_handshake !== "[0] START"); // techo('[connected to sikuli process]');
}

// for passing dynamic inputs to sikuli visual automation
function vision_step(vision_intent) {
  if (vision_intent.indexOf("vision ") !== 0)
    vision_intent = "vision " + vision_intent;
  sikuli_step(vision_intent);
}

// for using sikuli visual automation instead of casperjs
function sikuli_step(sikuli_intent) {
  sikuli_count++;
  if (sikuli_count == 1) sikuli_handshake(); // handshake on first call
  if (sikuli_intent.indexOf("snap_image()") > -1) {
    sikuli_intent = sikuli_intent.replace("snap_image()", snap_image());
  }
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write(
    "tagui.sikuli" + ds + "tagui_sikuli.in",
    "[" + sikuli_count.toString() + "] " + sikuli_intent,
    "w"
  );
  var sikuli_result = "";
  do {
    sleep(500);
    sikuli_result = fs.read("tagui.sikuli" + ds + "tagui_sikuli.out").trim();
  } while (sikuli_result.indexOf("[" + sikuli_count.toString() + "] ") == -1);
  if (sikuli_result.indexOf("SUCCESS") !== -1) return true;
  else return false;
}

// for fetching text from sikuli optical character recognition
function fetch_sikuli_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui.sikuli" + ds + "tagui_sikuli.txt"))
    return fs.read("tagui.sikuli" + ds + "tagui_sikuli.txt").trim();
  else return "";
}

// for clearing text from sikuli optical character recognition
function clear_sikuli_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write("tagui.sikuli" + ds + "tagui_sikuli.txt", "", "w");
}

// for setting timeout in sikuli when looking for ui element
function sikuli_timeout(time_in_seconds) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui.sikuli" + ds + "tagui_sikuli.in")) {
    sikuli_step(
      "vision setAutoWaitTimeout(" + time_in_seconds.toString() + ")"
    );
    sikuli_step("vision wait_timeout = " + time_in_seconds.toString());
  }
}

// for initialising integration with R
function r_handshake() {
  // techo('[connecting to R process]');
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  clear_r_text();
  var fs = require("fs");
  fs.write("tagui_r" + ds + "tagui_r.in", "", "w");
  var r_handshake = "";
  if (!fs.exists("tagui_r" + ds + "tagui_r.out"))
    fs.write("tagui_r" + ds + "tagui_r.out", "", "w");
  do {
    sleep(100);
    r_handshake = fs.read("tagui_r" + ds + "tagui_r.out").trim();
  } while (r_handshake !== "[0] START"); // techo('[connected to R process]');
}

// R integration for data analytics and machine learning
function r_step(r_intent) {
  if (r_intent.indexOf("r ") !== 0) r_intent = "r " + r_intent;
  r_count++;
  if (r_count == 1) r_handshake(); // handshake on first call
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write(
    "tagui_r" + ds + "tagui_r.in",
    "[" + r_count.toString() + "] " + r_intent,
    "w"
  );
  var r_step_result = "";
  do {
    sleep(100);
    r_step_result = fs.read("tagui_r" + ds + "tagui_r.out").trim();
  } while (r_step_result.indexOf("[" + r_count.toString() + "] ") == -1);
  if (r_step_result.indexOf("SUCCESS") !== -1) return true;
  else return false;
}

// for fetching text from R integration execution result
function fetch_r_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui_r" + ds + "tagui_r.txt"))
    return fs.read("tagui_r" + ds + "tagui_r.txt").trim();
  else return "";
}

// for clearing text from R integration execution result
function clear_r_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write("tagui_r" + ds + "tagui_r.txt", "", "w");
}

// for initialising integration with Python
function py_handshake() {
  // techo('[connecting to Python process]');
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  clear_py_text();
  var fs = require("fs");
  fs.write("tagui_py" + ds + "tagui_py.in", "", "w");
  var py_handshake = "";
  if (!fs.exists("tagui_py" + ds + "tagui_py.out"))
    fs.write("tagui_py" + ds + "tagui_py.out", "", "w");
  do {
    sleep(100);
    py_handshake = fs.read("tagui_py" + ds + "tagui_py.out").trim();
  } while (py_handshake !== "[0] START"); // techo('[connected to Python process]');
}

// Python integration for data analytics and machine learning
function py_step(py_intent) {
  if (py_intent.indexOf("py ") !== 0) py_intent = "py " + py_intent;
  py_count++;
  if (py_count == 1) py_handshake(); // handshake on first call
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write(
    "tagui_py" + ds + "tagui_py.in",
    "[" + py_count.toString() + "] " + py_intent,
    "w"
  );
  var py_step_result = "";
  do {
    sleep(100);
    py_step_result = fs.read("tagui_py" + ds + "tagui_py.out").trim();
  } while (py_step_result.indexOf("[" + py_count.toString() + "] ") == -1);
  if (py_step_result.indexOf("SUCCESS") !== -1) return true;
  else return false;
}

// for fetching text from Python integration execution result
function fetch_py_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui_py" + ds + "tagui_py.txt"))
    return fs.read("tagui_py" + ds + "tagui_py.txt").trim();
  else return "";
}

// for clearing text from Python integration execution result
function clear_py_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write("tagui_py" + ds + "tagui_py.txt", "", "w");
}

if (chrome_id > 0) {
  // super large if block to load chrome related functions if chrome or headless option is used
  chrome_id = 0; // reset chrome_id from 1 back to 0 to prepare for initial call of chrome_step

  // for initialising integration with chrome web browser
  function chrome_handshake() {
    // techo('[connecting to chrome websocket]');
    var fs = require("fs");
    fs.write("tagui_chrome.in", "", "w");
    var chrome_handshake = "";
    if (!fs.exists("tagui_chrome.out")) fs.write("tagui_chrome.out", "", "w");
    do {
      sleep(100);
      chrome_handshake = fs.read("tagui_chrome.out").trim();
    } while (chrome_handshake !== "[0] START"); // techo('[connected to chrome websocket]');
  }

  // send websocket message to chrome browser using chrome devtools protocol
  // php helper process tagui_chrome.php running to handle this concurrently
  function chrome_step(method, params) {
    chrome_id++;
    if (chrome_id == 1) chrome_handshake(); // handshake on first call
    var chrome_intent = JSON.stringify({
      id: chrome_id,
      method: method,
      params: params
    });
    if (chrome_targetid !== "")
      chrome_intent = JSON.stringify({
        id: chrome_id,
        method: "Target.sendMessageToTarget",
        params: { sessionId: chrome_targetid, message: chrome_intent }
      }); // send as message to target if context is popup
    var fs = require("fs");
    fs.write(
      "tagui_chrome.in",
      "[" + chrome_id.toString() + "] " + chrome_intent,
      "w"
    );
    var chrome_result = "";
    do {
      sleep(100);
      chrome_result = fs.read("tagui_chrome.out").trim();
    } while (chrome_result.indexOf("[" + chrome_id.toString() + "] ") == -1);
    if (chrome_targetid == "")
      return chrome_result.substring(chrome_result.indexOf("] ") + 2);
    // below for handling popup
    else {
      try {
        var raw_json_string = JSON.stringify(
          JSON.parse(chrome_result.substring(chrome_result.indexOf("] ") + 2))
            .params.message
        );
        return raw_json_string
          .slice(1, -1)
          .replace(/\\"/g, '"')
          .replace(/\\\\n/g, "\\n");
      } catch (e) {
        return "";
      }
    }
  }

  // chrome object for handling integration with chrome or headless chrome
  var chrome = new Object();
  chrome.mouse = new Object();

  // chrome methods as casper methods replacement for chrome integration
  chrome.exists = function(selector) {
    // different handling for xpath and css to support both
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotLength"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          chrome_context + ".querySelectorAll('" + selector + "').length"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value > 0) return true;
      else return false;
    } catch (e) {
      return false;
    }
  };

  chrome.elementVisible = function(selector) {
    // same as chrome.exists, except for checking visibility
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var e = document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0); var visible = false; if (!e) visible = false; else {var style = window.getComputedStyle(e); visible = style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';}; visible"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var e = " +
          chrome_context +
          ".querySelector('" +
          selector +
          "'); var visible = false; if (!e) visible = false; else {var style = window.getComputedStyle(e); visible = style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';}; visible"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value == true)
        return ws_json.result.result.value;
      else return false;
    } catch (e) {
      return false;
    }
  };

  chrome.countElements = function(selector) {
    // same as chrome.exists, except element count is returned
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotLength"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          chrome_context + ".querySelectorAll('" + selector + "').length"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value > 0) return ws_json.result.result.value;
      else return 0;
    } catch (e) {
      return 0;
    }
  };

  /* // backup of previous click implementation to experiment with Puppeteer's version
chrome.click = function(selector) { // click by sending click event instead of mouse down/up/click, then focus on element
if ((selector.toString().length >= 16) && (selector.toString().substr(0,16) == 'xpath selector: '))
{if (selector.toString().length == 16) selector = ''; else selector = selector.toString().substring(16);
chrome_step('Runtime.evaluate',{expression: 'document.evaluate(\''+selector+'\','+chrome_context+',null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).click()'}); chrome_step('Runtime.evaluate',{expression: 'document.evaluate(\''+selector+'\','+chrome_context+',null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).focus()'});}
else {chrome_step('Runtime.evaluate',{expression: chrome_context+'.querySelector(\''+selector+'\').click()'});
chrome_step('Runtime.evaluate',{expression: chrome_context+'.querySelector(\''+selector+'\').focus()'});}}; */

  chrome.click = function(selector) {
    // click using Puppeteer's implementation - see TagUI issue #212
    chrome.scrollIntoViewIfNeeded(selector);
    var xy = chrome.mouse.getXY(selector);
    chrome.mouse.action("mouseMoved", xy.x, xy.y, "none", 0);
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 1);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 1);
  };

  chrome.scrollIntoViewIfNeeded = function(selector) {
    // helper function to scroll element into view
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).scrollIntoViewIfNeeded()"
      });
    } else {
      chrome_step("Runtime.evaluate", {
        expression:
          chrome_context +
          ".querySelector('" +
          selector +
          "').scrollIntoViewIfNeeded()"
      });
    }
  };

  chrome.mouse.action = function(type, x, y, button, clickCount) {
    // helper function to send various mouse events
    chrome_step("Input.dispatchMouseEvent", {
      type: type,
      x: x,
      y: y,
      button: button,
      clickCount: clickCount
    });
  };

  chrome.mouse.getXY = function(selector) {
    // helper function to get xy center coordinates of selector
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).getBoundingClientRect(); var result_xy = {x: Math.round(result_bounds.left + result_bounds.width / 2), y: Math.round(result_bounds.top + result_bounds.height / 2)}; result_xy",
        returnByValue: true
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').getBoundingClientRect(); var result_xy = {x: Math.round(result_bounds.left + result_bounds.width / 2), y: Math.round(result_bounds.top + result_bounds.height / 2)}; result_xy",
        returnByValue: true
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (
        ws_json.result.result.value.x > 0 &&
        ws_json.result.result.value.y > 0
      ) {
        if (chrome_context !== "document") {
          ws_json.result.result.value.x += frame_step_offset_x; // add offset if in frame
          ws_json.result.result.value.y += frame_step_offset_y;
        }
        return ws_json.result.result.value;
      } else {
        if (chrome_context !== "document")
          return { x: frame_step_offset_x, y: frame_step_offset_y };
        else return { x: 0, y: 0 };
      }
    } catch (e) {
      return { x: 0, y: 0 };
    }
  };

  chrome.getRect = function(selector) {
    // helper function to get rectangle boundary coordinates of selector
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).getBoundingClientRect(); var result_rect = {top: Math.round(result_bounds.top), left: Math.round(result_bounds.left), width: Math.round(result_bounds.width), height: Math.round(result_bounds.height)}; result_rect",
        returnByValue: true
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').getBoundingClientRect(); var result_rect = {top: Math.round(result_bounds.top), left: Math.round(result_bounds.left), width: Math.round(result_bounds.width), height: Math.round(result_bounds.height)}; result_rect",
        returnByValue: true
      });
    try {
      var ws_json = JSON.parse(ws_message); // check if width and height are valid before returning coordinates
      if (
        ws_json.result.result.value.width > 0 &&
        ws_json.result.result.value.height > 0
      ) {
        if (chrome_context !== "document") {
          ws_json.result.result.value.left += frame_step_offset_x; // add offset if in frame
          ws_json.result.result.value.top += frame_step_offset_y;
        }
        return ws_json.result.result.value;
      } else {
        if (chrome_context !== "document")
          return {
            left: frame_step_offset_x,
            top: frame_step_offset_y,
            width: 0,
            height: 0
          };
        else return { left: 0, top: 0, width: 0, height: 0 };
      }
    } catch (e) {
      return { left: 0, top: 0, width: 0, height: 0 };
    }
  };

  chrome.mouse.move = function(selector, y) {
    // move mouse pointer to center of specified selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mouseMoved", xy.x, xy.y, "none", 0);
  };

  chrome.mouse.click = function(selector, y) {
    // press and release on center of specfied selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 1);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 1);
  };

  chrome.mouse.doubleclick = function(selector, y) {
    // double press and release on center of selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 2);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 2);
  };

  chrome.mouse.rightclick = function(selector, y) {
    // right click press and release on center of selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "right", 1);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "right", 1);
  };

  chrome.mouse.down = function(selector, y) {
    // left press on center of specified selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 1);
  };

  chrome.mouse.up = function(selector, y) {
    // left release on center of specified selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 1);
  };

  chrome.sendKeys = function(selector, value, options) {
    // send key strokes to selector, options not implemented
    if (value == casper.page.event.key.Enter) value = "\r";
    if (value) {
      value = value.replace(/\[enter\]/g, "\r"); // to cater for [enter] passed in as part of a variable
      value = value.replace(/\r\n/g, "\r"); // change \r\n to \r which is the enter key for chrome browser
      value = value.replace(/\n/g, "\r");
    } // change \n to \r which is the enter key for chrome browser
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).focus()"
      });
    } else
      chrome_step("Runtime.evaluate", {
        expression:
          chrome_context + ".querySelector('" + selector + "').focus()"
      });
    if (options && options.reset == true) {
      // handling for clearing field by checking options.reset
      if (selector.indexOf("/") == 0 || selector.indexOf("(") == 0) {
        // check for xpath selector and handle accordingly
        chrome_step("Runtime.evaluate", {
          expression:
            "var sendKeys_field = document.evaluate('" +
            selector +
            "'," +
            chrome_context +
            ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0); sendKeys_field.value = ''; var evt = document.createEvent('UIEvents'); evt.initUIEvent('change', true, true); sendKeys_field.dispatchEvent(evt);"
        });
      } else
        chrome_step("Runtime.evaluate", {
          expression:
            "var sendKeys_field = " +
            chrome_context +
            ".querySelector('" +
            selector +
            "'); sendKeys_field.value = ''; var evt = document.createEvent('UIEvents'); evt.initUIEvent('change', true, true); sendKeys_field.dispatchEvent(evt);"
        });
    }
    for (
      var character = 0, length = value.length;
      character < length;
      character++
    ) {
      chrome_step("Input.dispatchKeyEvent", {
        type: "char",
        text: value[character]
      });
    }
  };

  chrome.selectOptionByValue = function(selector, valueToMatch) {
    // select dropdown option (base on casperjs issue #1390)
    chrome.evaluate(
      "function() {var selector = '" +
        selector +
        "'; var valueToMatch = '" +
        valueToMatch +
        "'; var found = false; if ((selector.indexOf('/') == 0) || (selector.indexOf('(') == 0)) var select = document.evaluate(selector," +
        chrome_context +
        ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0); else var select = " +
        chrome_context +
        ".querySelector(selector); if (valueToMatch == '[clear]') valueToMatch = ''; Array.prototype.forEach.call(select.children, function(opt, i) {if (!found && opt.value == valueToMatch) {select.selectedIndex = i; found = true;}}); var evt = document.createEvent(\"UIEvents\"); evt.initUIEvent(\"change\", true, true); select.dispatchEvent(evt);}"
    );
  };

  chrome.fetchText = function(selector) {
    // grab text from selector following casperjs logic, but grab only first match
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).textContent || document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).innerText || document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).value || ''"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          chrome_context +
          ".querySelector('" +
          selector +
          "').textContent || " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').innerText || " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').value || ''"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.decode = function(str) {
    // funtion to convert base64 data to binary string
    // used in https://github.com/casperjs/casperjs/blob/master/modules/clientutils.js
    if (!str) return ""; // return empty string if somehow null value is passed in
    var BASE64_DECODE_CHARS = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    var c1,
      c2,
      c3,
      c4,
      i = 0,
      len = str.length,
      out = "";
    while (i < len) {
      do {
        c1 = BASE64_DECODE_CHARS[str.charCodeAt(i++) & 0xff];
      } while (i < len && c1 === -1);
      if (c1 === -1) {
        break;
      }
      do {
        c2 = BASE64_DECODE_CHARS[str.charCodeAt(i++) & 0xff];
      } while (i < len && c2 === -1);
      if (c2 === -1) {
        break;
      }
      out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));
      do {
        c3 = str.charCodeAt(i++) & 0xff;
        if (c3 === 61) {
          return out;
        }
        c3 = BASE64_DECODE_CHARS[c3];
      } while (i < len && c3 === -1);
      if (c3 === -1) {
        break;
      }
      out += String.fromCharCode(((c2 & 0xf) << 4) | ((c3 & 0x3c) >> 2));
      do {
        c4 = str.charCodeAt(i++) & 0xff;
        if (c4 === 61) {
          return out;
        }
        c4 = BASE64_DECODE_CHARS[c4];
      } while (i < len && c4 === -1);
      if (c4 === -1) {
        break;
      }
      out += String.fromCharCode(((c3 & 0x03) << 6) | c4);
    }
    return out;
  };

  chrome.capture = function(filename) {
    // capture screenshot of webpage to file in png/jpg/jpeg format
    // having pdf extension saves to a pdf file instead. only works in headless mode, visible mode errors out
    var format = "png";
    var quality = 80;
    var fromSurface = true;
    var screenshot_data = ""; // options not implemented
    if (
      filename.substr(-3).toLowerCase() == "jpg" ||
      filename.substr(-4).toLowerCase() == "jpeg"
    )
      format = "jpeg";
    if (filename.substr(-3).toLowerCase() == "pdf")
      var ws_message = chrome_step("Page.printToPDF", {
        printBackground: true
      });
    else
      var ws_message = chrome_step("Page.captureScreenshot", {
        format: format,
        quality: quality,
        fromSurface: fromSurface
      });
    try {
      var ws_json = JSON.parse(ws_message);
      screenshot_data = ws_json.result.data;
    } catch (e) {
      screenshot_data = "";
    }
    var fs = require("fs");
    fs.write(filename, chrome.decode(screenshot_data), "wb");
  };

  /* // backup of previous captureSelector implementation to use Page.captureScreenshot with clipping directly
chrome.captureSelector = function(filename,selector) { // capture screenshot of selector to png/jpg/jpeg format
// first capture entire screen, then use casperjs / phantomjs browser to crop image base on selector dimensions
chrome.capture(filename); var selector_rect = chrome.getRect(selector); // so that there is no extra dependency
if (selector_rect.width > 0 && selector_rect.height > 0) // from using other libraries or creating html canvas 
casper.thenOpen(file_url(filename), function() {casper . capture(filename, // spaces around . to avoid replacing 
{top: selector_rect.top, left: selector_rect.left, width: selector_rect.width, height: selector_rect.height});
casper.thenOpen('about:blank');});}; // reset phantomjs browser state */

  chrome.captureSelector = function(filename, selector) {
    // capture screenshot of selector to png/jpg/jpeg format
    var selector_rect = chrome.getRect(selector);
    if (selector_rect.width > 0 && selector_rect.height > 0) {
      var format = "png";
      var quality = 80;
      var fromSurface = true;
      var screenshot_data = ""; // options not implemented
      if (
        filename.substr(-3).toLowerCase() == "jpg" ||
        filename.substr(-4).toLowerCase() == "jpeg"
      )
        format = "jpeg";
      var clip = {
        x: selector_rect.left,
        y: selector_rect.top,
        width: selector_rect.width,
        height: selector_rect.height,
        scale: 1
      };
      var ws_message = chrome_step("Page.captureScreenshot", {
        format: format,
        quality: quality,
        clip: clip,
        fromSurface: fromSurface
      });
      try {
        var ws_json = JSON.parse(ws_message);
        screenshot_data = ws_json.result.data;
      } catch (e) {
        screenshot_data = "";
      }
      var fs = require("fs");
      fs.write(filename, chrome.decode(screenshot_data), "wb");
    }
  };

  chrome.upload = function(selector, filename) {
    // upload function to upload file to provided selector
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      casper.echo(
        "ERROR - upload step is only implemented for CSS selector and not XPath selector"
      );
      casper.echo(
        "ERROR - for consistency with PhantomJS as it only supports upload with CSS selector"
      );
    } else
      try {
        var ws_message = "";
        var ws_json = {};
        ws_message = chrome_step("DOM.getDocument", {});
        ws_json = JSON.parse(ws_message);
        ws_message = chrome_step("DOM.querySelector", {
          nodeId: ws_json.result.root.nodeId,
          selector: selector
        });
        ws_json = JSON.parse(ws_message);
        ws_message = chrome_step("DOM.setFileInputFiles", {
          files: [filename],
          nodeId: ws_json.result.nodeId
        });
        ws_json = JSON.parse(ws_message);
        ws_message = chrome_step("DOM.disable"); // disable invoked DOM agent from running and firing events
      } catch (e) {
        casper.echo("ERROR - unable to upload " + selector + " as " + filename);
      }
  };

  chrome.download = function(url, filename) {
    // download function for downloading url resource to file
    // casper download cannot be used for urls which requires login as casperjs engine can't access chrome
    // the chromium issue 696481 is moving well, else an alternative may be to inject casper clientutils.js
    // TagUI by default auto-sets to allow downloads for headless Chrome (otherwise it prevents downloads)
    casper.echo(
      "ERROR - for headless and visible Chrome, download file using normal webpage interaction"
    );
  };

  chrome.evaluate = function(fn_statement, eval_json) {
    // evaluate expression in browser dom context
    // chrome runtime.evaluate is different from casperjs evaluate, do some processing to reduce gap
    var statement = fn_statement.toString();
    if (!eval_json) {
      statement = statement.slice(
        statement.indexOf("{") + 1,
        statement.lastIndexOf("}")
      );
      statement = statement.replace(/return /g, "");
    } // defining function() with return keyword is invalid for chrome
    else
      statement = "(" + statement + ")" + "(" + JSON.stringify(eval_json) + ")"; // unless variable is passed into fx
    var ws_message = chrome_step("Runtime.evaluate", { expression: statement }); // statements can be separated by ;
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return null;
    } catch (e) {
      return null;
    }
  };

  chrome.withFrame = function(frameInfo, then) {
    // replace casperjs frame for switching frame context
    var new_context = "";
    if (chrome_context == "document") new_context = "mainframe_context";
    else if (chrome_context == "mainframe_context")
      new_context = "subframe_context"; // below backup original offset
    original_frame_step_offset_x = frame_step_offset_x;
    original_frame_step_offset_y = frame_step_offset_y;
    casper.then(function _step() {
      // track frame (x,y) offset so that steps within frame work correctly
      var frame_rect = chrome.getRect(
        xps666(
          '(//frame|//iframe)[@name="' +
            frameInfo +
            '" or @id="' +
            frameInfo +
            '"]'
        )
      );
      frame_step_offset_x = frame_rect.left;
      frame_step_offset_y = frame_rect.top; // set offset before entering frame
      chrome_step("Runtime.evaluate", {
        expression:
          new_context +
          " = document.evaluate('(//frame|//iframe)[@name=\"" +
          frameInfo +
          '" or @id="' +
          frameInfo +
          "\"]'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).contentDocument"
      });
      chrome_context = new_context;
    }); // set mainframe_context/subframe_context in dom
    casper.then(then);
    casper.then(function _step() {
      if (chrome_context == "subframe_context") {
        chrome_step("Runtime.evaluate", {
          expression: "subframe_context = null"
        });
        chrome_context = "mainframe_context";
        frame_step_offset_x = original_frame_step_offset_x;
        frame_step_offset_y = original_frame_step_offset_y;
      } else if (chrome_context == "mainframe_context") {
        chrome_step("Runtime.evaluate", {
          expression: "mainframe_context = null"
        });
        chrome_context = "document";
        frame_step_offset_x = 0;
        frame_step_offset_y = 0;
      }
    });
  }; // reset offset after exit mainframe

  chrome.waitForPopup = function(popupInfo, then, onTimeout) {
    // replace casperjs waitforpopup for checking popup window
    casper.waitFor(
      function check() {
        // use similar logic as chrome withpopup to scan through list of browser targets
        var found_popup = false;
        var chrome_targets = [];
        var ws_message = chrome_step("Target.getTargets", {});
        try {
          var ws_json = JSON.parse(ws_message);
          if (ws_json.result.targetInfos)
            chrome_targets = ws_json.result.targetInfos;
          else chrome_targets = [];
        } catch (e) {
          chrome_targets = [];
        } // following line scan through targets to find match
        chrome_targets.forEach(function(target) {
          if (target.url.search(popupInfo) !== -1) found_popup = true;
        });
        return found_popup;
      },
      then,
      onTimeout
    );
  };

  chrome.withPopup = function(popupInfo, then) {
    // replace casperjs withpopup for handling popup window
    casper.then(function _step() {
      // get list of targets, find a match, attach to the target and set chrome_targetid
      var found_targetid = "";
      var chrome_targets = [];
      var ws_message = chrome_step("Target.getTargets", {});
      try {
        var ws_json = JSON.parse(ws_message);
        if (ws_json.result.targetInfos)
          chrome_targets = ws_json.result.targetInfos;
        else chrome_targets = [];
      } catch (e) {
        chrome_targets = [];
      } // following line scan through targets to find match
      chrome_targets.forEach(function(target) {
        if (target.url.search(popupInfo) !== -1)
          found_targetid = target.targetId;
      });
      if (found_targetid !== "") {
        var ws_message = chrome_step("Target.attachToTarget", {
          targetId: found_targetid
        });
        try {
          var ws_json = JSON.parse(ws_message);
          if (ws_json.result.sessionId !== "")
            found_targetid = ws_json.result.sessionId;
          else found_targetid = "";
        } catch (e) {
          found_targetid = "";
        }
      }
      chrome_targetid = found_targetid;
    }); // set chrome_targetid only after attaching to found target successfully
    casper.then(then);
    casper.then(function _step() {
      if (chrome_targetid !== "") {
        // detach from target after running then
        var found_targetid = chrome_targetid;
        chrome_targetid = "";
        chrome_step("Target.detachFromTarget", { sessionId: found_targetid });
      }
    });
  };

  chrome.getHTML = function() {
    // get raw html of current webpage
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.documentElement.outerHTML"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.getTitle = function() {
    // get title of current webpage
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.title"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.getCurrentUrl = function() {
    // get url of current webpage
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.location.href"
    });
    try {
      var ws_json = JSON.parse(ws_message); // chrome returns below value on empty dead url
      if (ws_json.result.result.value == "data:text/html,chromewebdata")
        ws_json.result.result.value = "about:blank";
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.debugHTML = function() {
    casper.echo(chrome.getHTML());
  }; // print raw html of current webpage

  chrome.reload = function() {
    // reload the current webpage, then not implemented
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.location.reload()"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.back = function() {
    // move back a step in browser history
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "window.history.back()"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.forward = function() {
    // move forward a step in browser history
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "window.history.forward()"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.echo = function(value) {
    casper.echo(value);
  }; // use casper echo to print output

  chrome.on = function(value, statement) {
    casper.on(value, statement);
  }; // use casper event system
} // end of super large if block to load chrome related functions if chrome or headless option is used

// for live mode simple parsing of tagui steps into js code
function tagui_parse(raw_input) {
  if (tagui_language.toLowerCase() == "english") return parse_intent(raw_input);
  else {
    var translated_string = translate(
      raw_input,
      "from",
      tagui_language.toLowerCase()
    );
    if (translated_string.indexOf("ERROR - translation engine") !== -1)
      casper.echo(translated_string).exit();
    else return parse_intent(translated_string);
  }
}

// for live mode interpretation of step into casperjs code
function parse_intent(live_line) {
  live_line = live_line.trim();
  if (live_line == "") return "";
  live_line = parse_variables(live_line);
  live_line = live_line.trim();
  if (live_line == "") return "";
  switch (get_intent(live_line)) {
    case "url":
      return url_intent(live_line);
      break;
    case "tap":
      return tap_intent(live_line);
      break;
    case "rtap":
      return rtap_intent(live_line);
      break;
    case "dtap":
      return dtap_intent(live_line);
      break;
    case "hover":
      return hover_intent(live_line);
      break;
    case "type":
      return type_intent(live_line);
      break;
    case "select":
      return select_intent(live_line);
      break;
    case "read":
      return read_intent(live_line);
      break;
    case "show":
      return show_intent(live_line);
      break;
    case "upload":
      return upload_intent(live_line);
      break;
    case "down":
      return down_intent(live_line);
      break;
    case "receive":
      return receive_intent(live_line);
      break;
    case "echo":
      return echo_intent(live_line);
      break;
    case "save":
      return save_intent(live_line);
      break;
    case "dump":
      return dump_intent(live_line);
      break;
    case "write":
      return write_intent(live_line);
      break;
    case "load":
      return load_intent(live_line);
      break;
    case "snap":
      return snap_intent(live_line);
      break;
    case "table":
      return table_intent(live_line);
      break;
    case "wait":
      return wait_intent(live_line);
      break;
    case "live":
      return live_intent(live_line);
      break;
    case "ask":
      return ask_intent(live_line);
      break;
    case "keyboard":
      return keyboard_intent(live_line);
      break;
    case "mouse":
      return mouse_intent(live_line);
      break;
    case "check":
      return check_intent(live_line);
      break;
    case "test":
      return test_intent(live_line);
      break;
    case "frame":
      return frame_intent(live_line);
      break;
    case "popup":
      return popup_intent(live_line);
      break;
    case "api":
      return api_intent(live_line);
      break;
    case "run":
      return run_intent(live_line);
      break;
    case "dom":
      return dom_intent(live_line);
      break;
    case "js":
      return js_intent(live_line);
      break;
    case "r":
      return r_intent(live_line);
      break;
    case "py":
      return py_intent(live_line);
      break;
    case "vision":
      return vision_intent(live_line);
      break;
    case "timeout":
      return timeout_intent(live_line);
      break;
    case "code":
      return code_intent(live_line);
      break;
    default:
      return (
        "this.echo('ERROR - cannot understand step " +
        live_line.replace(/'/g, "\\'") +
        "')"
      );
  }
}

function parse_variables(script_line) {
  // `variable` --> '+variable+'
  // use "[SINGLE_QUOTE_FOR_VARIABLE_HANDLING]" instead of "'" to prevent escaping ' in escape_bs()
  quote_token = "[SINGLE_QUOTE_FOR_VARIABLE_HANDLING]+"; // token to alternate replacements for '+variable+'
  for (char_counter = 0; char_counter < script_line.length; char_counter++) {
    if (script_line.charAt(char_counter) == "`") {
      script_line =
        script_line.substr(0, char_counter) +
        quote_token +
        script_line.substr(char_counter + 1);
      if (quote_token == "[SINGLE_QUOTE_FOR_VARIABLE_HANDLING]+")
        quote_token = "+[SINGLE_QUOTE_FOR_VARIABLE_HANDLING]";
      else quote_token = "[SINGLE_QUOTE_FOR_VARIABLE_HANDLING]+";
    }
  }
  return script_line;
}

// for live mode understanding intent of line entered
function get_intent(raw_intent) {
  var lc_raw_intent = raw_intent.toLowerCase();
  if (inside_py_block !== 0) return "py";
  if (inside_r_block !== 0) return "r";
  if (inside_run_block !== 0) return "run";
  if (inside_vision_block !== 0) return "vision";
  if (inside_js_block !== 0) return "js";
  if (inside_dom_block !== 0) return "dom";

  if (
    lc_raw_intent.substr(0, 7) == "http://" ||
    lc_raw_intent.substr(0, 8) == "https://"
  )
    return "url";

  // first set of conditions check for valid keywords with their parameters
  if (
    lc_raw_intent.substr(0, 4) == "tap " ||
    lc_raw_intent.substr(0, 6) == "click "
  )
    return "tap";
  if (
    lc_raw_intent.substr(0, 5) == "rtap " ||
    lc_raw_intent.substr(0, 7) == "rclick "
  )
    return "rtap";
  if (
    lc_raw_intent.substr(0, 5) == "dtap " ||
    lc_raw_intent.substr(0, 7) == "dclick "
  )
    return "dtap";
  if (
    lc_raw_intent.substr(0, 6) == "hover " ||
    lc_raw_intent.substr(0, 5) == "move "
  )
    return "hover";
  if (
    lc_raw_intent.substr(0, 5) == "type " ||
    lc_raw_intent.substr(0, 6) == "enter "
  )
    return "type";
  if (
    lc_raw_intent.substr(0, 7) == "select " ||
    lc_raw_intent.substr(0, 7) == "choose "
  )
    return "select";
  if (
    lc_raw_intent.substr(0, 5) == "read " ||
    lc_raw_intent.substr(0, 6) == "fetch "
  )
    return "read";
  if (
    lc_raw_intent.substr(0, 5) == "show " ||
    lc_raw_intent.substr(0, 6) == "print "
  )
    return "show";
  if (
    lc_raw_intent.substr(0, 3) == "up " ||
    lc_raw_intent.substr(0, 7) == "upload "
  )
    return "upload";
  if (
    lc_raw_intent.substr(0, 5) == "down " ||
    lc_raw_intent.substr(0, 9) == "download "
  )
    return "down";
  if (lc_raw_intent.substr(0, 8) == "receive ") return "receive";
  if (lc_raw_intent.substr(0, 5) == "echo ") return "echo";
  if (lc_raw_intent.substr(0, 5) == "save ") return "save";
  if (lc_raw_intent.substr(0, 5) == "dump ") return "dump";
  if (lc_raw_intent.substr(0, 6) == "write ") return "write";
  if (lc_raw_intent.substr(0, 5) == "load ") return "load";
  if (lc_raw_intent.substr(0, 5) == "snap ") return "snap";
  if (lc_raw_intent.substr(0, 6) == "table ") return "table";
  if (lc_raw_intent.substr(0, 5) == "wait ") return "wait";
  if (lc_raw_intent.substr(0, 5) == "live ") return "live";
  if (lc_raw_intent.substr(0, 4) == "ask ") return "ask";
  if (lc_raw_intent.substr(0, 9) == "keyboard ") return "keyboard";
  if (lc_raw_intent.substr(0, 6) == "mouse ") return "mouse";
  if (lc_raw_intent.substr(0, 6) == "check ") return "check";
  if (lc_raw_intent.substr(0, 5) == "test ") return "test";
  if (lc_raw_intent.substr(0, 6) == "frame ") return "frame";
  if (lc_raw_intent.substr(0, 6) == "popup ") return "popup";
  if (lc_raw_intent.substr(0, 4) == "api ") return "api";
  if (lc_raw_intent.substr(0, 4) == "run ") return "run";
  if (lc_raw_intent.substr(0, 4) == "dom ") return "dom";
  if (lc_raw_intent.substr(0, 3) == "js ") return "js";
  if (lc_raw_intent.substr(0, 2) == "r ") return "r";
  if (lc_raw_intent.substr(0, 3) == "py ") return "py";
  if (lc_raw_intent.substr(0, 7) == "vision ") return "vision";
  if (lc_raw_intent.substr(0, 8) == "timeout ") return "timeout";

  // second set of conditions check for valid keywords with missing parameters
  if (lc_raw_intent == "tap" || lc_raw_intent == "click") return "tap";
  if (lc_raw_intent == "rtap" || lc_raw_intent == "rclick") return "rtap";
  if (lc_raw_intent == "dtap" || lc_raw_intent == "dclick") return "dtap";
  if (lc_raw_intent == "hover" || lc_raw_intent == "move") return "hover";
  if (lc_raw_intent == "type" || lc_raw_intent == "enter") return "type";
  if (lc_raw_intent == "select" || lc_raw_intent == "choose") return "select";
  if (lc_raw_intent == "read" || lc_raw_intent == "fetch") return "read";
  if (lc_raw_intent == "show" || lc_raw_intent == "print") return "show";
  if (lc_raw_intent == "up" || lc_raw_intent == "upload") return "upload";
  if (lc_raw_intent == "down" || lc_raw_intent == "download") return "down";
  if (lc_raw_intent == "receive") return "receive";
  if (lc_raw_intent == "echo") return "echo";
  if (lc_raw_intent == "save") return "save";
  if (lc_raw_intent == "dump") return "dump";
  if (lc_raw_intent == "write") return "write";
  if (lc_raw_intent == "load") return "load";
  if (lc_raw_intent == "snap") return "snap";
  if (lc_raw_intent == "table") return "table";
  if (lc_raw_intent == "wait") return "wait";
  if (lc_raw_intent == "live") return "live";
  if (lc_raw_intent == "ask") return "ask";
  if (lc_raw_intent == "keyboard") return "keyboard";
  if (lc_raw_intent == "mouse") return "mouse";
  if (lc_raw_intent == "check") return "check";
  if (lc_raw_intent == "test") return "test";
  if (lc_raw_intent == "frame") return "frame";
  if (lc_raw_intent == "popup") return "popup";
  if (lc_raw_intent == "api") return "api";
  if (lc_raw_intent == "run") return "run";
  if (lc_raw_intent == "dom") return "dom";
  if (lc_raw_intent == "js") return "js";
  if (lc_raw_intent == "r") return "r";
  if (lc_raw_intent == "py") return "py";
  if (lc_raw_intent == "vision") return "vision";
  if (lc_raw_intent == "timeout") return "timeout";

  // final check for recognized code before returning error
  if (is_code(raw_intent)) return "code";
  else return "error";
}

function is_code(raw_intent) {
  // due to asynchronous waiting for element, if/for/while can work for parsing single step
  // other scenarios can be assumed to behave as unparsed javascript in casperjs context
  // to let if/for/while handle multiple steps/code use the { and } steps to define block
  if (raw_intent.substr(0, 4) == "var " || raw_intent.substr(0, 3) == "do ")
    return true;
  if (raw_intent.substr(0, 1) == "{" || raw_intent.substr(0, 1) == "}")
    return true;
  if (
    raw_intent.charAt(raw_intent.length - 1) == "{" ||
    raw_intent.charAt(raw_intent.length - 1) == "}"
  )
    return true;
  if (raw_intent.substr(0, 3) == "if " || raw_intent.substr(0, 4) == "else")
    return true;
  if (raw_intent.substr(0, 4) == "for " || raw_intent.substr(0, 6) == "while ")
    return true;
  if (
    raw_intent.substr(0, 7) == "switch " ||
    raw_intent.substr(0, 5) == "case "
  )
    return true;
  if (raw_intent.substr(0, 6) == "break;" || raw_intent == "break") return true;
  if (raw_intent.substr(0, 9) == "continue;" || raw_intent == "continue")
    return true;
  if (
    raw_intent.substr(0, 7) == "casper." ||
    raw_intent.substr(0, 5) == "this."
  )
    return true;
  if (raw_intent.substr(0, 7) == "chrome.") return true; // chrome object for chrome integration
  if (raw_intent.substr(0, 5) == "test" + ".") return true; // avoid replacement with test option
  if (
    raw_intent.substr(0, 2) == "//" ||
    raw_intent.charAt(raw_intent.length - 1) == ";"
  )
    return true;
  if (raw_intent.substr(0, 9) == "function ") return true; // function definition
  // assume = is assignment statement, kinda acceptable as this is checked at the very end
  if (raw_intent.indexOf("=") > -1) return true;
  return false;
}

function file_url(absolute_filename) {
  // helper function to append file:// according for opening local files
  if (!absolute_filename || absolute_filename == "") return "";
  if (absolute_filename.substr(0, 1) == "/")
    return "file://" + absolute_filename;
  if (absolute_filename.substr(1, 1) == ":")
    return "file:///" + absolute_filename;
  return absolute_filename;
}

function abs_file(filename) {
  // helper function to return absolute filename
  if (filename == "") return ""; // unlike tagui_parse.php not deriving path from script variable
  if (filename.substr(0, 1) == "/") return filename; // return mac/linux absolute filename directly
  if (filename.substr(1, 1) == ":") return filename.replace(/\\/g, "/"); // return windows absolute filename directly
  if (is_coordinates(filename)) return filename; // to handle when sikuli (x,y) coordinates locator is provided
  var tmp_flow_path = flow_path; // otherwise use flow_path defined in generated script to build absolute filename
  // above str_replace is because casperjs/phantomjs do not seem to support \ for windows paths, replace with / to work
  if (tmp_flow_path.indexOf("/") > -1)
    return (tmp_flow_path + "/" + filename).replace(/\\/g, "/");
  else return tmp_flow_path + "\\" + filename;
}

function add_concat(source_string) {
  // parse string and add missing + concatenator
  if (source_string.indexOf("'") > -1 && source_string.indexOf('"') > -1)
    return "'ERROR - inconsistent quotes in text'";
  else if (source_string.indexOf("'") > -1) var quote_type = "'";
  // derive quote type used
  else if (source_string.indexOf('"') > -1) var quote_type = '"';
  else var quote_type = "none";
  var within_quote = false;
  source_string = source_string.trim(); // trim for future proof
  for (srcpos = 0; srcpos < source_string.length; srcpos++) {
    if (source_string.charAt(srcpos) == quote_type)
      within_quote = !within_quote;
    if (within_quote == false && source_string.charAt(srcpos) == " ")
      source_string =
        source_string.substring(0, srcpos) +
        "+" +
        source_string.substring(srcpos + 1);
  }
  source_string = source_string.replace(/\+\+\+\+\+/g, "+");
  source_string = source_string.replace(/\+\+\+\+/g, "+");
  source_string = source_string.replace(/\+\+\+/g, "+");
  source_string = source_string.replace(/\+\+/g, "+");
  return source_string;
} // replacing multiple variations of + to handle user typos of double spaces etc

function escape_bs(input_string) {
  // helper function to escape backslash characters and friends
  escaped_string = input_string
    .replace(/\\/g, "\\\\")
    .replace(/\'/g, "\\'")
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r");
  escaped_string = escaped_string
    .replace(/\t/g, "\\t")
    .replace(/\f/g, "\\f")
    .replace(/\v/g, "\\v")
    .replace(/\"/g, '\\"');
  return escaped_string.replace(/\[SINGLE_QUOTE_FOR_VARIABLE_HANDLING\]/g, "'");
}

function is_coordinates(input_params) {
  // helper function to check if string is (x,y) coordinates
  if (
    input_params.length > 4 &&
    input_params.substr(0, 1) == "(" &&
    input_params.substr(-1) == ")" &&
    (input_params.split(",").length == 2 ||
      input_params.split(",").length == 3) &&
    !input_params.match(/[a-z]/i)
  )
    return true;
  else return false;
}

function is_sikuli(input_params) {
  // helper function to check if input is meant for sikuli visual automation
  if (
    input_params.length > 4 &&
    input_params.substr(-4).toLowerCase() == ".png"
  )
    return true;
  // support png and bmp
  else if (
    input_params.length > 4 &&
    input_params.substr(-4).toLowerCase() == ".bmp"
  )
    return true;
  else if (is_coordinates(input_params)) return true;
  else return false;
}

function call_sikuli(input_intent, input_params, other_actions) {
  // helper function to use sikuli visual automation
  var fs = require("fs"); // use phantomjs fs file system module to access files and directories
  fs.write("tagui.sikuli/tagui_sikuli.in", "", "w");
  fs.write("tagui.sikuli/tagui_sikuli.out", "", "w");
  if (!fs.exists("tagui.sikuli/tagui_sikuli.in"))
    return "this.echo('ERROR - cannot initialise tagui_sikuli.in')";
  if (!fs.exists("tagui.sikuli/tagui_sikuli.out"))
    return "this.echo('ERROR - cannot initialise tagui_sikuli.out')";
  if (!other_actions) other_actions = ""; // to handle most cases where other_actions is not passed in during call
  return (
    "var fs = require('fs'); if (!sikuli_step('" +
    input_intent +
    "')) if (!fs.exists('" +
    input_params +
    "')) " +
    "this.echo('ERROR - cannot find image file " +
    input_params +
    "'); " +
    "else this.echo('ERROR - cannot find " +
    input_params +
    " on screen'); " +
    other_actions
  );
}

function call_r(input_intent) {
  // helper function to use R integration for data analytics and machine learning
  var fs = require("fs"); // use phantomjs fs file system module to access files and directories
  fs.write("tagui_r/tagui_r.in", "", "w");
  fs.write("tagui_r/tagui_r.out", "", "w");
  if (!fs.exists("tagui_r/tagui_r.in"))
    return "this.echo('ERROR - cannot initialise tagui_r.in')";
  if (!fs.exists("tagui_r/tagui_r.out"))
    return "this.echo('ERROR - cannot initialise tagui_r.out')";
  return (
    "r_result = ''; if (!r_step('" +
    input_intent +
    "')) this.echo('ERROR - cannot execute R command(s)'); else {r_result = fetch_r_text(); clear_r_text(); try {r_json = JSON.parse(r_result);} catch(e) {r_json = JSON.parse('null');}}"
  );
}

function call_py(input_intent) {
  // helper function to use Python integration for data analytics and machine learning
  var fs = require("fs"); // use phantomjs fs file system module to access files and directories
  fs.write("tagui_py/tagui_py.in", "", "w");
  fs.write("tagui_py/tagui_py.out", "", "w");
  if (!fs.exists("tagui_py/tagui_py.in"))
    return "this.echo('ERROR - cannot initialise tagui_py.in')";
  if (!fs.exists("tagui_py/tagui_py.out"))
    return "this.echo('ERROR - cannot initialise tagui_py.out')";
  return (
    "py_result = ''; if (!py_step('" +
    input_intent +
    "')) this.echo('ERROR - cannot execute Python command(s)'); else {py_result = fetch_py_text(); clear_py_text(); try {py_json = JSON.parse(py_result);} catch(e) {py_json = JSON.parse('null');}}"
  );
}

function url_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  if (chrome_id == 0)
    return "this.echo('ERROR - step only supported in live mode using Chrome browser')";
  else
    return (
      'this.evaluate(function() {window.location.href = "' + raw_intent + '"})'
    );
}

function tap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params)) return "this.click(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function rtap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params))
    return "this.mouse.rightclick(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function dtap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params))
    return "this.mouse.doubleclick(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function hover_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params)) return "this.mouse.move(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function type_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" as ")).trim();
  var param2 = params.substr(4 + params.indexOf(" as ")).trim();
  if (is_sikuli(param1) && param2 !== "") {
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    return call_sikuli(abs_intent, abs_param1);
  } // use sikuli visual automation as needed
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - target/text missing for " + raw_intent + "')";
  else if (check_tx(param1)) {
    if (param2.indexOf("[clear]") == 0) {
      if (param2.length > 7) param2 = param2.substr(7);
      else param2 = "";
      clear_field = "this.sendKeys(tx('" + param1 + "'),'',{reset: true}); ";
    } else clear_field = "";
    if (param2.indexOf("[enter]") == -1)
      return (
        clear_field + "this.sendKeys(tx('" + param1 + "'),'" + param2 + "')"
      );
    // special handling to send enter key events
    else {
      param2 = param2.replace(
        /\[enter\]/g,
        "',{keepFocus: true}); this.sendKeys(tx('" +
          param1 +
          "'),casper.page.event.key.Enter,{keepFocus: true}); this.sendKeys(tx('" +
          param1 +
          "'),'"
      );
      return (
        clear_field +
        "this.sendKeys(tx('" +
        param1 +
        "'),'" +
        param2 +
        "',{keepFocus: true});"
      );
    }
  } else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function select_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" as ")).trim();
  var param2 = params.substr(4 + params.indexOf(" as ")).trim();
  if (is_sikuli(param1) && is_sikuli(param2)) {
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    var abs_param2 = abs_file(param2);
    abs_intent = abs_intent.replace(param2, abs_param2);
    return call_sikuli(abs_intent, abs_param1);
  } // use sikuli visual automation as needed
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - target/option missing for " + raw_intent + "')";
  else if (check_tx(param1))
    return (
      "var select_locator = tx('" +
      param1 +
      "'); if (is_xpath_selector(select_locator.toString().replace('xpath selector: ',''))) select_locator = select_locator.toString().substring(16); this.selectOptionByValue(select_locator,'" +
      param2 +
      "');"
    );
  else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function read_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (is_sikuli(param1) && params.indexOf(" to ") > -1) {
    // use sikuli visual automation as needed
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    return call_sikuli(
      abs_intent,
      abs_param1,
      param2 + " = fetch_sikuli_text(); clear_sikuli_text();"
    );
  }
  if (param1.toLowerCase() == "page" && param2 !== "")
    return param2 + " = this.getHTML()";
  if (param1 == "" || param2 == "")
    return (
      "this.echo('ERROR - target/variable missing for " + raw_intent + "')"
    );
  else if (check_tx(param1))
    return param2 + " =  this.fetchText(tx('" + param1 + "')).trim()";
  else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function show_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    // use sikuli visual automation as needed
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(
      abs_intent,
      abs_params,
      "this.echo(fetch_sikuli_text()); clear_sikuli_text();"
    );
  }
  if (params.toLowerCase() == "page")
    return "this.echo('" + raw_intent + "' + ' - ' + '\\n' + this.getHTML())";
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params))
    return "this.echo(this.fetchText(tx('" + params + "')).trim())";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function upload_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" as ")).trim();
  var param2 = params.substr(4 + params.indexOf(" as ")).trim();
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - filename missing for " + raw_intent + "')";
  else if (check_tx(param1))
    return (
      "this.page.uploadFile(tx('" + param1 + "'),'" + abs_file(param2) + "')"
    );
  else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function down_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - url/filename missing for " + raw_intent + "')";
  else return "this.download('" + param1 + "','" + abs_file(param2) + "')";
}

function receive_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, it requires creating CasperJS event')";
}

function echo_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - text missing for " + raw_intent + "')";
  else return "this.echo(" + add_concat(params) + ")";
}

function save_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (is_sikuli(param1) && params.indexOf(" to ") > -1) {
    // use sikuli visual automation as needed
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    return call_sikuli(
      abs_intent,
      abs_param1,
      "save_text('" +
        abs_file(param2) +
        "',fetch_sikuli_text()); clear_sikuli_text();"
    );
  } else if (is_sikuli(params) && params.indexOf(" to ") == -1) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(
      abs_intent,
      abs_param1,
      "save_text('',fetch_sikuli_text()); clear_sikuli_text();"
    );
  }
  if (params.toLowerCase() == "page" || param1.toLowerCase() == "page") {
    if (params.indexOf(" to ") > -1)
      return "save_text('" + abs_file(param2) + "',this.getHTML())";
    else return "save_text('',this.getHTML())";
  }
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1) {
    if (check_tx(param1))
      return (
        "save_text('" +
        abs_file(param2) +
        "',this.fetchText(tx('" +
        param1 +
        "')).trim())"
      );
    else return "this.echo('ERROR - cannot find " + param1 + "')";
  } else {
    if (check_tx(params))
      return "save_text('',this.fetchText(tx('" + params + "')).trim())";
    else return "this.echo('ERROR - cannot find " + params + "')";
  }
}

function dump_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - variable missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1)
    return "save_text('" + abs_file(param2) + "'," + add_concat(param1) + ")";
  else return "save_text(''," + add_concat(params) + ")";
}

function write_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - variable missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1)
    return "append_text('" + abs_file(param2) + "'," + add_concat(param1) + ")";
  else return "append_text(''," + add_concat(params) + ")";
}

function load_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - filename missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1)
    return (
      "var fs = require('fs'); " +
      param2 +
      " = ''; if (fs.exists('" +
      abs_file(param1) +
      "')) " +
      param2 +
      " = fs.read('" +
      abs_file(param1) +
      "').trim(); else this.echo('ERROR - cannot find file " +
      param1 +
      "')"
    );
  else return "this.echo('ERROR - variable missing for " + raw_intent + "')";
}

function snap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (is_sikuli(param1) && params.indexOf(" to ") > -1) {
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    var abs_param2 = abs_file(param2);
    abs_intent = abs_intent.replace(param2, abs_param2);
    return call_sikuli(abs_intent, abs_param1);
  } // use sikuli visual automation as needed
  else if (is_sikuli(params) && params.indexOf(" to ") == -1) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent + " to snap_image()", abs_params);
  } // handle no output filename
  if (params.toLowerCase() == "page" || param1.toLowerCase() == "page") {
    if (params.indexOf(" to ") > -1)
      return "this.capture('" + abs_file(param2) + "')";
    else return "this.capture(snap_image())";
  }
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1) {
    if (check_tx(param1))
      return (
        "this.captureSelector('" + abs_file(param2) + "',tx('" + param1 + "'))"
      );
    else return "this.echo('ERROR - cannot find " + param1 + "')";
  } else {
    if (check_tx(params))
      return "this.captureSelector(snap_image(),tx('" + params + "'))";
    else return "this.echo('ERROR - cannot find " + params + "')";
  }
}

function table_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1) {
    if (check_tx(param1))
      return "save_table('" + abs_file(param2) + "',tx('" + param1 + "'))";
    else return "this.echo('ERROR - cannot find " + param1 + "')";
  } else {
    if (check_tx(params)) return "save_table('',tx('" + params + "'))";
    else return "this.echo('ERROR - cannot find " + params + "')";
  }
}

function wait_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - waiting for some time is not relevant in live mode')";
}

function live_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - you are already in live mode, type done to quit live mode')";
}

function ask_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step is not relevant in live mode, set ask_result directly')";
}

function keyboard_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - keys to type missing for " + raw_intent + "')";
  else return call_sikuli(raw_intent, params);
}

function mouse_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - down / up missing for " + raw_intent + "')";
  else if (params.toLowerCase() == "down")
    return call_sikuli(raw_intent, "down");
  else if (params.toLowerCase() == "up") return call_sikuli(raw_intent, "up");
  else return "this.echo('ERROR - cannot understand step " + raw_intent + "')";
}

function check_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, there is no conditions language parser')";
}

function test_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return (
    "this.echo('ERROR - use CasperJS tester module to professionally " +
    raw_intent +
    "\\nERROR - info at http://docs.casperjs.org/en/latest/modules/tester.html\\nERROR - support CSS selector or tx(\\'selector\\') for XPath algo by TagUI')"
  );
}

function frame_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, it is meant for trying single steps')";
}

function popup_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, it is meant for trying single steps')";
}

function api_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - API URL missing for " + raw_intent + "')";
  else
    return (
      "api_result = ''; api_result = call_api('" +
      params +
      "'); " +
      "try {api_json = JSON.parse(api_result);} catch(e) {api_json = JSON.parse('null');}"
    );
}

function run_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, as run output cannot be retrieved')";
}

function dom_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "dom begin") {
    inside_dom_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "dom finish") {
    inside_dom_block = 0;
    return "";
  }
  if (inside_dom_block == 1) raw_intent = "dom " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - statement missing for " + raw_intent + "')";
  else
    return (
      "dom_result = ''; dom_result = this.evaluate(function(dom_json) {" +
      params +
      "}, dom_json)"
    );
}

function js_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "js begin") {
    inside_js_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "js finish") {
    inside_js_block = 0;
    return "";
  }
  if (inside_js_block == 1) raw_intent = "js " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - statement missing for " + raw_intent + "')";
  else return check_chrome_context(params);
}

function r_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "r begin") {
    inside_r_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "r finish") {
    inside_r_block = 0;
    return "";
  }
  if (inside_r_block == 1) raw_intent = "r " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - R command(s) missing for " + raw_intent + "')";
  else return call_r(raw_intent.replace(/\\/g, "\\\\").replace(/'/g, "\\'"));
}

function py_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "py begin") {
    inside_py_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "py finish") {
    inside_py_block = 0;
    return "";
  }
  if (inside_py_block == 1) raw_intent = "py " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return (
      "this.echo('ERROR - Python command(s) missing for " + raw_intent + "')"
    );
  else return call_py(raw_intent.replace(/\\/g, "\\\\").replace(/'/g, "\\'"));
}

function vision_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "vision begin") {
    inside_vision_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "vision finish") {
    inside_vision_block = 0;
    return "";
  }
  if (inside_vision_block == 1) raw_intent = "vision " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return (
      "this.echo('ERROR - Sikuli command(s) missing for " + raw_intent + "')"
    );
  else
    return call_sikuli(
      raw_intent.replace(/\\/g, "\\\\").replace(/'/g, "\\'"),
      "for vision step"
    );
}

function timeout_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return (
      "this.echo('ERROR - time in seconds missing for " + raw_intent + "')"
    );
  else
    return check_chrome_context(
      "casper.options.waitTimeout = " +
        (parseFloat(params) * 1000).toString() +
        "; sikuli_timeout(" +
        parseFloat(params).toString() +
        ");"
    );
}

function code_intent(raw_intent) {
  // code to support dynamic variables not applicable
  return check_chrome_context(raw_intent);
}

function check_chrome_context(source_code) {
  // function to convert javascript code to chrome context
  // specifically for live mode, as statements in flow file are already converted by tagui_parse.php
  if (chrome_id == 0) return source_code; // if chrome or headless option is used, chrome_id will be > 0
  source_code = source_code
    .replace(/casper\.exists/g, "chrome.exists")
    .replace(/this\.exists/g, "chrome.exists");
  source_code = source_code
    .replace(/casper\.click/g, "chrome.click")
    .replace(/this\.click/g, "chrome.click");
  source_code = source_code
    .replace(/casper\.mouse/g, "chrome.mouse")
    .replace(/this\.mouse/g, "chrome.mouse");
  source_code = source_code
    .replace(/casper\.sendKeys/g, "chrome.sendKeys")
    .replace(/this\.sendKeys/g, "chrome.sendKeys");
  source_code = source_code
    .replace(/casper\.selectOptionByValue/g, "chrome.selectOptionByValue")
    .replace(/this\.selectOptionByValue/g, "chrome.selectOptionByValue");
  source_code = source_code
    .replace(/casper\.countElements/g, "chrome.countElements")
    .replace(/this\.countElements/g, "chrome.countElements");
  source_code = source_code
    .replace(/casper\.elementVisible/g, "chrome.elementVisible")
    .replace(/this\.elementVisible/g, "chrome.elementVisible");
  source_code = source_code
    .replace(/casper\.fetchText/g, "chrome.fetchText")
    .replace(/this\.fetchText/g, "chrome.fetchText");
  source_code = source_code
    .replace(/casper\.capture/g, "chrome.capture")
    .replace(/this\.capture/g, "chrome.capture");
  source_code = source_code
    .replace(/casper\.captureSelector/g, "chrome.captureSelector")
    .replace(/this\.captureSelector/g, "chrome.captureSelector");
  source_code = source_code
    .replace(/chrome\.page\.uploadFile/g, "chrome.upload")
    .replace(/casper\.page\.uploadFile/g, "chrome.upload")
    .replace(/this\.page\.uploadFile/g, "chrome.upload");
  source_code = source_code
    .replace(/casper\.download/g, "chrome.download")
    .replace(/this\.download/g, "chrome.download");
  source_code = source_code
    .replace(/casper\.evaluate/g, "chrome.evaluate")
    .replace(/this\.evaluate/g, "chrome.evaluate");
  source_code = source_code
    .replace(/casper\.getHTML/g, "chrome.getHTML")
    .replace(/this\.getHTML/g, "chrome.getHTML");
  source_code = source_code
    .replace(/casper\.getTitle/g, "chrome.getTitle")
    .replace(/this\.getTitle/g, "chrome.getTitle");
  source_code = source_code
    .replace(/casper\.getCurrentUrl/g, "chrome.getCurrentUrl")
    .replace(/this\.getCurrentUrl/g, "chrome.getCurrentUrl");
  source_code = source_code
    .replace(/casper\.debugHTML/g, "chrome.debugHTML")
    .replace(/this\.debugHTML/g, "chrome.debugHTML");
  source_code = source_code
    .replace(/casper\.reload/g, "chrome.reload")
    .replace(/this\.reload/g, "chrome.reload");
  source_code = source_code
    .replace(/casper\.back/g, "chrome.back")
    .replace(/this\.back/g, "chrome.back");
  source_code = source_code
    .replace(/casper\.forward/g, "chrome.forward")
    .replace(/this\.forward/g, "chrome.forward");
  return source_code;
}

// for calling rest api url synchronously
function call_api(rest_url) {
  // advance users can define api_config for advance calls
  // the api_config variable defaults to {method:'GET', header:[], body:{}}
  var xhttp = new XMLHttpRequest();
  xhttp.open(api_config.method, rest_url, false);
  for (var item = 0; item < api_config.header.length; item++) {
    // process headers
    if (api_config.header[item] == "") continue; // skip if header is not defined
    var header_value_pair = api_config.header[item].split(":"); // format is 'Header_name: header_value'
    xhttp.setRequestHeader(
      header_value_pair[0].trim(),
      header_value_pair[1].trim()
    );
  }
  xhttp.send(JSON.stringify(api_config.body));
  return xhttp.responseText;
}

// custom function to handle dropdown option
casper.selectOptionByValue = function(selector, valueToMatch) {
  // solution posted in casperjs issue #1390
  this.evaluate(
    function(selector, valueToMatch) {
      var found = false; // modified to allow xpath / css locators
      if (selector.indexOf("/") == 0 || selector.indexOf("(") == 0)
        var select = __utils__.getElementByXPath(selector);
      else var select = document.querySelector(selector); // auto-select xpath or query css method to get element
      if (valueToMatch == "[clear]") valueToMatch = ""; // [clear] keyword to allow selecting empty / blank option
      Array.prototype.forEach.call(select.children, function(opt, i) {
        // loop through list to select option
        if (!found && opt.value == valueToMatch) {
          select.selectedIndex = i;
          found = true;
        }
      });
      var evt = document.createEvent("UIEvents"); // dispatch change event in case there is validation
      evt.initUIEvent("change", true, true);
      select.dispatchEvent(evt);
    },
    selector,
    valueToMatch
  );
};

// custom function to return element visibility
casper.elementVisible = function(selector) {
  return casper.visible(selector);
}; // use casperjs to maximize compatibility

// custom function to return element count
casper.countElements = function(selector) {
  // use casperjs in-built function to maximize compatibility
  var count_result = casper.evaluate(function(selector) {
    return __utils__.findAll(selector).length;
  }, selector);
  try {
    if (count_result > 0) return count_result;
    else return 0;
  } catch (e) {
    return 0;
  }
};

// custom function from casperjs v1.1.5 (not yet released)
casper.waitForExec = function(command, parameters, then, onTimeout, timeout) {
  "use strict";
  var killTimeout;
  var utils = require("utils");
  var f = utils.format; // custom added line from casper.js global
  if (utils.isArray(timeout)) {
    killTimeout = utils.isNumber(timeout[1])
      ? getTimeoutAndCheckNextStepFunction(
          timeout[1],
          then,
          "waitForExec",
          this.options.waitTimeout
        )
      : getTimeoutAndCheckNextStepFunction(
          timeout[0],
          then,
          "waitForExec",
          this.options.waitTimeout
        );
    timeout = getTimeoutAndCheckNextStepFunction(
      timeout[0],
      then,
      "waitForExec",
      this.options.waitTimeout
    );
  } else {
    timeout = getTimeoutAndCheckNextStepFunction(
      timeout,
      then,
      "waitForExec",
      this.options.waitTimeout
    );
    killTimeout = timeout;
  }

  if (!utils.isString(command) && !utils.isArray(parameters)) {
    throw new CasperError(
      "waitForExec() needs an command string as program and parameters separated by space to run or an array of parameters. if program is falsy or not a string, it uses default system shell"
    );
  }
  if (utils.isFalsy(command) || !utils.isString(command)) {
    var system = require("system");
    command = system.env.SHELL || system.env.ComSpec; // SHELL for UNIX(?), ComSpec for Windows(?)
    this.log(
      "Casper.waitForExec()  is going to use default system shell " +
        JSON.stringify(command) +
        " - command is falsy or is not a string",
      "warning"
    );
  }
  if (utils.isFalsy(parameters) || !utils.isArray(parameters)) {
    parameters = [];
  }

  // add use of a escape char like '\'??? (e.g.: '/bin/bash -c {\ ls\ /\ &&\ ls\ /home\ }' becomes ['/bin/bash', '-c', '{ ls / && ls /home }']
  command = command.split(" ");
  parameters = command.splice(1, command.length - 1).concat(parameters);
  command = command[0];
  var fs = require("fs");
  if (!fs.isExecutable(command)) {
    this.log(
      "Casper.waitForExec() is going to call non executable file " +
        JSON.stringify(command) +
        " - maybe runs if is in PATH",
      "warning"
    );
  }

  var spawn = require("child_process").spawn;
  var stdout = ""; // VARIABLE TO STORE PROGRAM STDOUT
  var stderr = ""; // VARIABLE TO STORE PROGRAM STDERR
  var exitCode = null; // VARIABLE TO STORE PROGRAM EXIT CODE
  var realPid = null; // VARIABLE TO STORE PROGRAM REAL PID
  var elapsedTime = null; // VARIABLE TO STORE PROGRAM DURATION
  var childStartTime = new Date().getTime();
  var child = spawn(command, parameters);
  realPid = child.pid;

  child.stdout.on("data", function(standardOut) {
    // keeps stdout updated
    stdout += standardOut;
  });
  child.stderr.on("data", function(standardError) {
    // keeps stderr updated
    stderr += standardError;
  });
  child.on("exit", function(code) {
    elapsedTime = new Date().getTime() - childStartTime;
    exitCode = code;
  });

  function __details() {
    return {
      data: {
        command: command,
        parameters: parameters,
        pid: realPid,
        stdout: stdout,
        stderr: stderr,
        exitCode: exitCode,
        elapsedTime: elapsedTime,
        isChildNotFinished: exitCode == null
      }
    };
  }
  function __onTimeout(timeout, details) {
    var __onWaitTimeout = onTimeout ? onTimeout : this.options.onWaitTimeout;
    var signalToKill = "SIGTERM";
    child.kill(signalToKill);

    killTimeout = getTimeoutAndCheckNextStepFunction(
      killTimeout,
      __onWaitTimeout,
      "killAndCallOnWaitTimeout",
      this.options.waitTimeout,
      false
    );
    (function killAndCallOnWaitTimeout() {
      this.waitFor(
        function isProgramKilled() {
          // HAVE TO ADD waitFor() TO MAKE child.on("exit"... UPDATES exitCode AND TO child.pid BE UPDATED
          return exitCode != null;
        },
        function onProgramKilled() {
          this.log(
            f(
              "waitForExec() has killed %s %s (PID %d) with %s",
              details.data.command,
              JSON.stringify(details.data.parameters),
              details.data.pid,
              signalToKill
            ),
            "info"
          );
          // this.then(this.createStep(__onWaitTimeout, timeout, __details()));
          __onWaitTimeout.call(this, timeout, __details());
        },
        function onProgramNotKilled() {
          this.log(
            f(
              "waitForExec() has not killed %s %s (PID %d) with %s",
              details.data.command,
              JSON.stringify(details.data.parameters),
              details.data.pid,
              signalToKill
            ),
            "warning"
          );
          signalToKill =
            require("system").os.name !== "windows" ? "SIGKILL" : "WM_QUIT"; // "WM_QUIT" SEEMS TO BE THE WINDOWS EQUIVALENT TO UNIX SIGKILL
          child.kill(signalToKill);
          killTimeout = 1;
          killAndCallOnWaitTimeout.call(this);
        },
        killTimeout
      );
    }.call(this));
  }
  this.log(
    f(
      "waitForExec() called %s (PID %d) with %s arguments",
      JSON.stringify(command),
      realPid,
      JSON.stringify(parameters)
    ),
    "info"
  );
  return this.waitFor(
    function isProgramFinished() {
      return exitCode != null;
    },
    function onProgramFinished() {
      this.then(this.createStep(then, __details()));
    },
    __onTimeout,
    timeout,
    __details()
  );
};

// dependency function of casper.waitForExec in v1.1.5 (not yet released)
function getTimeoutAndCheckNextStepFunction(
  timeout,
  then,
  methodName,
  defaultTimeout,
  isThenRequired
) {
  var utils = require("utils"); // custom added line from casper.js global
  if (isThenRequired || then) {
    var isFunction = utils.isFunction(then); // Optimization to perform "isFunction" check only once.

    if (isThenRequired && !isFunction) {
      throw new CasperError(methodName + "() needs a step function");
    } else if (then && !isFunction) {
      throw new CasperError(
        methodName + "() next step definition must be a function"
      );
    }
  }

  timeout = ~~timeout || ~~defaultTimeout;
  if (timeout < 0) {
    throw new CasperError(
      methodName + "() only accepts an integer >= 0 as a timeout value"
    );
  }

  return timeout;
}

// global try-catch for catching unexpected and unhandled errors, eg referencing an undeclared variable
phantom.onError = function(msg, trace) {
  if (msg.indexOf("Error:") !== -1) {
    // clean up and format error message
    msg = msg.substring(msg.indexOf("Error:") + 6).trim();
    msg = msg.charAt(0).toLowerCase() + msg.slice(1);
  }
  casper.echo("ERROR - " + msg).exit();
};

```
