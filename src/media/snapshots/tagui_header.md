**Prettier 1.18.2**
[Playground link](https://prettier.io/playground/#N4Igxg9gdgLgprEAuEAdKB6DACAHgBwEMYALbAMwgCdsIAjAKzjBmwEsATBGN8tsYm2joAboRoEAzgDZZ2ALzYqcAI4BXNsoAUAcgGT8cKjoCUAOklwANsxgANAArESAbnTos2QpMlsA5lDYRFSEALZw8FSS2DAQQQCMALT4AJzYYlRshHQ2kqLiCQrY+oZUZmBWbGYhAO5mfhFaAAwmLukF+ABMRSVG5ZXVhHUNMFrxre00+ADMPd6l-VW19Y2drflTACxzBn0VS0Mro9MTGUEArDsL+4PDjZunHdJXewPLI1rn61Bn+ADsLzKN3ejWkjymAA5AYtbkctH9wUE0opekC3ocPhDvh4cJJCCI4NhJDBxKweOEYnFwt41MpsHBcMw1DxoDE2OENl5mRBQoJoAB9Ymk-nkwmKAAixDgZigEBqWgmqLMzBIEF0qHQAGUACoAQQAStrsIkubFeSzAkKqPAOMbsDpsABqbCS+AKsyxAAyEAENk1MEyUD8CuxmBwbCgbB4hEqljZFMoNFFVAVFDUUBYQignOTgpJ1pF7LFLqlMrlCrc2bD7CgfEjMAAnsVoELYBRqNg1HGI+2aFYIBB8HkfgUI3Wo03FPEmp1NpWcTWo1lY4SuORCGorKw-P26DHJlkcnBh2d1GwIvzQhAuEV11ZLG0zniCSKGTB+ZB06xFE1HwVJFAhD4Py7KEA0H4QF+RS-u41afrARjRImMQhGAADWEZ+Ng4Q+GBx41koAA0QQNqQ0DEb4aGbmwxFgCQVA8oSEbwH4IQWieBRUBBUE-n+UwNtxba8ZMRJsFRlSCd+2C-iJdEMeEIG2rxsGeHJjHNghuCsMh5AhBSJCEFAHCVEGXhGTE4gjJwvZBIOaj4NgBlGSZficmpCmQJpUk6BwPpqOEsA6HxxT0YxIqWRE1mKDoQUqTgGSHjYNneGhRLwA5sReGAYBwPgrBdkYNb4MynIpfyyiSJu3mxVWngAFKagA8gAcge2RJZlRA+G1R7RMxcR0AxNSWDQ4qNQAspyvmhPyDCSKyijAAAvsF03lceVVFDF87Vgl7WEshhAcGIGaEl2eG0OQXj4GwaW5aVN0QbW-hFMA4RkRwSA6AA4gAotqOjESQcBHUYSAANoALrEXQ14Nkgy0rXFPW5MlN1mbaVDpndQ70oyYDMlmSgbVuD1sOtlVbltQUiUB5NzQt2DLcFWNQBTm3RTTZys7N82BItSO1fF4iJfhyH6hj2AOKRqqBMxcCsXygQMkyFrE5TMCclxFUc-aXOcbzjPMyJ+ACTrVOc8FpuG-zTOCwuAaEOh2B0ArEaJOOkhkDkPpoUhHby4r7H0lhJqm8RVAR+mxEiGwvjkdgc3EdNnIRr4XD8tbPvO8JZxp5wcDlfy2epbno5QOnhc8yX0GVnnFcF-ysfx2zNdlzQ+cZ3Nxf9jn0nBZ3hdrW3-fI1wkShBGhKqjU2GGU2SqkAgOPRJlkgYfg6DkOmmasvANj4NQ74cHHJKnVo++5Ufl7iGhRgmEzUD+a7XGxPyqoOcpkZXRf1hXwWvIqB3zKBGLguBGrkF0ODAAQvqX6uoADS-JNQAElvrNV1J6SGphsAAD5jTjCZshLQ0QUTzD6MSXKkgzA2CDKQRI8Q2jRFwcJSQiREgP2AOgXg2AtBKkoUOcGkhIYeggP6QMwYH7yEUFoVAIBt4ZjVqmYAiZ+T9kHIKfwgErBbTkY6S+h8AG3yMI6ORQUlpyJMCYdAwAn6hBfiKCA79BxFEkG0QaIM0IuCWitJa2BPCWHEHRF2Ts0I1HELaE+yhd6BGQh4wgqUBHoGsN2H+Bjr6AOAWYUBDIIFQIAMItW1Cg5qABVX6yC0EYKwTg-BDDOHENIcUchZQBFMOwAAHjIbsVp6VqG0L8PQxhRJHSOk4dwn+-C+lCJEbEcRmFUzSN4XIhRMTeENOoGogcwFfABH3NFPR6SjFAJMWY7xljrFQFsc-IwjjnGfyJO45QCTvErX8biEGVBgmJnCVQSJmhbBE2Qp5HgT9CRJO-rwuxDi34fwUD+DZNASHQgEf0hAgySAMPaSw-uRJ2GcJ4XwlpFhpnCNEfMoMizFDoFkfIneSjEVbI0bs7RuiQD6L-oY98mS+jKHwFYJ2cAClFJKeUyp6DMHYMIjoGBcDEHiuqdgkwpiQDmIuTY6FtzYUuMUG4l2zyvE+Nee8xyhljKEm8Pqzx7ArqyhxtgGw5AyRxBBRGNQcBkn3kJMoGAtJAgyUJVoTVr8nFwpNFM3KD98EtGJr6qggQg03JDfcu0Eb8ATBSd6iIfr+4WKFjEFUcRVlq2Qk5YymFsBngiLQPKWYt70qJvAOiapC15gkQSn+ABCKt3LrxwE4Sa0IzILWw2ZEgHIhk0LEQVjZLg69YgOQ3GaJWEzeFaFbcSCR8L7TZEgjAcdAqoCpRNBqKAOCAA+57eEboDBWpZOhT27rHROo9dpTAPyVIW3QphKyZptbwkkfgNBqMMkBvCojvQ1CMPk7wQqpHRXRbGEgODP3NvXc2ttmFvh-uAGcR2FcBU2kw6ZRQ+HJCEaFTeiR0rYiA0A8Bw9YGGgQblNB2DIY2iodVBfEIBGpQcGI34b4hKyMUYE5uzC2SjK5MgToX6+p9SNQliaUTSt6RBinjgztSz6nNJ6cqXAUYKw+NjX685+bkJDtBVhQtBF4DElNDyNTkgwCZDysOYtRMOD+VCAJL9Vm4DidvUGThPqzN5oXMhZ8Fb4BaRrImc0jai1sBsPWxRRNnyF1i6MPgNh+SAXCIRMcTjsucLOBwPVhLyD9hqJnZwUmwF5J0BgLTOnCEVa2i1tof6OsHI1KgGqhLO25cLgV-tTNMuvi0pJUZbQRv5bCMWarco6ukCdNgDrzodDZYdM6Sb2XJLkuC5I9bOgPRaTVSOGg5AmnKDPNoHQN2f0UGoTUTIbp5tjeIsVqbMBiI6BqD+iL1ZDr4EMEZGLb54vUES3vZLqXawNtZEBcHAnstaE+4tortYStvjKwUCrbQqs1dWyQBrMndAtYftpxQunev2i6-SL1G2mkPv64NrtmPwgdt4ftt8klpExr59N+CMBZsmojK5uAAVWA8KaNO5nBUiSLebFBTKKOEAcC3il0bKvFDLdq0QNbzpNv2h2+t4X75RdHYkamLb52YCXbODdood2NAPaexMG7Zg3tRiFVzuA32ce-dOxqKgp7AY7qB8jKL+IK0ASAl7CAMBogQCulBugvh4CUgoDrtLayE-AVAg0ZR5XKs-wN6T8n4DZNU+wDTghD96fNZpj11n-WBuVkLyBXk4FRfi7C-G3hlejdkBN9ELbhfdtEkAkX3vhdrdzOO3b+0Zh8BBmjxZjs0XTIkiPBQeS2AM9Z8JJlEb+e1b7f2hjnXC3CuWBsCwag+OaCE--Rjkno-q9Nbrw3unrPGc29dF2dKwhsA9OFLcZtHQ5tb8xtbxP9nB1tTdtt9pp9IDF8xFl8H57cwBJARAndOIVsOBiBCAig5E5Fgo988scorAdFqU0AQBgoXdFA3cAVdBPc5tXt3t-dYCsc9Z-tAcJhPAYxwkGxogKpq1z9IUtBO1P1DNiRJASE-4n8qAH5L1edlDYgygl9bdzAcka9dACBECH9bBqAkB7QTBpF6kH5B9YkYwHwTUGQox-0IwxBKgtdpCTCVCbcFlzABk1sll4gwQiRNCOxLYmc4wvCtDXFQjtDMDdCLA1BM9l8gihCcARg8BR8t4OwL59pyo5R5BhkqCq45QulpxZw2hij8iahRlQsiCSCyCGC5sciqjIArBCjKi8i2iyiZw5wLIjwIIrBaimZ0BWjrA6D7QtApi0DYjTssAAwTBwZp8qihpTtIZ5iSATBp8dBz0aZPA6ANArBbQaCdEjC1soiOxMpJcrA1AuBRiujxinRoppiLdZitt5jVClj1sVi5Q1j5iOArEvjnRWiIAdEttsE2h9jk8yAYBbQzUYhbQ-4ZdhxCU5DT5FCpBZBpBciBiTirEbD6iSRXdCTSCts5FCIzF1slRyAIg6JtQ3wtBMTZAcTqDxirEPRMhQgKxPU4x4lDUJcrpAkvkSAK1kJijihxjogL4yB4TYSH445sBZRWBKpspjxJBt4rBiJsIQYK51NbQ08lBfiFTnk6JAtV0tAhp+RiCSREjkiUx5c1ht0H0QBpU6jatrTSCWCSTbTN0tA1g2hLSPSnj7QzlrpUdfsb88svtAySDWg80-1bCUJ3VjVPAeFnTpV2BoglT2x0wOBiJqRdTNdLp+ikpjSQZTS4TV5gY6QFS7UTiczzIewhoY9LjeNyNBBTIh0tw2BEhGM1ALoDcpTIBQhkS7M2yKM18SB00L9G1xypQSFXM2A8o1Ep5CIolAVyI+y8IX80phQ74GwahqB6d0Adj9h0Jz0SR8Bz0rwCRz1VQCQqALyGxDBz1uAjBz0ojz1m0IBLBz1nkOBz0aSYA6IPyZ5z18BAwYAPz8Q4BXzm1z1vNQgrzfd4APzZ8Lz9przIJfz9zYYIldjTEz1wkoxz1KhbzfIagoB+wjpz17JqKAL6K-zmA4A2BbzdJFtwK7IrzRQ91z06YEKeRz05pz1m4sxXzmdeBxLfzJLExz0agRSbAvzgZzyao8MnFLBghiBNl9zDy-lWcmKaKgKQLMtSKIAaLELkLuC0KgIMKjwBLKLGLokWK2LqBdjSpJBBRcpxAtKuIdKjz9LGwXy3zHzPzvzfy6KzKAL9ZrtqB1FgI-K9KtpAL5Jdi65-x8wrdoAT52J+QErm8pKmJyBz0ZLXL5KdclLmA0JUqRIrR3xgYrBShcq4ADz-KkrC0EL-JLK-dUq3IsqlwWwmqWrEroosK6RSBDJaAaBVB+z7xKRRrT8nJJr6R1B9xYhz1WIQZIgYhFqOxpr7C5qNqpQkwdqpqVqdE1qRS-BqztqJrdqzrV4IA7z-BrrxrAg7qZq5rcgqzbrTqZqHrSK1Sbq3rfrVrHqvrCpXqlq9rZq1rwbjqfrlqPrYbWN4bgbEb9rkaoNUaoazq5qrwxqnJ1rnktrXqnqrqIbCavqgaAafAKbDJTKsbqbszob-rmbca1qWa5roa5rsyQVCA05z1eboASQIwvzhb+aK4xbYAJa+KjJz1XLVKCh6rGq8qAqowbAFRaKqArBNb0cTALyiwUx9bRdNaILjxuBNbRKjxNarwCp+QdBHQdBcAGwbbsLC4HanbXa7aPaXb9a9icA+TOwHJbbLB+RHJrBSg0x0sWwc98QIBrJJ4hQ75Ahb0-AGgt06Amx6NyZghLBJzF1ohKJqIggGIcpuooA4BAszSrsQjPIKtBrdL8rLA67JAPzmAsrqqnwMrPKW6G7WqRriKoKeLmQerpDO0XM3N3wTJCR1CJ6lyp6p4nScFEztpzTO11y1l1CN61Z71l7s0h85MFMlM7RVM1Z0VF7t6iZNL3pCpE7fAN9QCu0tyGhsB1Dn6xROYbD97AhD7FNlMUJDJ2yz6NMK6HVQN+yX7r6Ihb64576-AOdedFzlzp6l7X6r057kHF770w8I80GiQkGF7QHsGTyv641LQCGVyK60rrsGJYBBQKHp71oyHqYicf4MHCHpQ6JxBdRRgY1iGz0H5dJhb6HJ7KGq5v7gCz1qGQl0IRH56xGmGc1wjCV2GxGfSAwtBdN+GcE9xZHVHGHEy+spH0BL7GZTGoAWMsaYNLBuTpDzH6971aNsAAAyZxjbAFNZBvR7eSPe5h3+4+lTOc4BvwC+jxtWIdBzV2HPDsIR0IGmc0+x+9WJnBXDAoNo-yNmWJooYZM4dJ0INmTKXiPxHDXJ0EjJ-kLJ9uZsG4-JxxbJ8zd+ood+yxtjGxxEd+ySWuKacvYfBA0gb-WvVrWndrAA1vZnZvDvRWvscBvCCpnXLad+yQafU3RpnAvA6Kl7V3aatgx7JZ4TTnahJwhQrQDpkbKxUzA++TP+k+oJomc+0B6fVZ1fXAkQXPJKO+zCMZuMLhGujp2oW8ahf8k5mZ8CM51h3hP5w4fQprHBkhhx4Zy5M4DpoMxQSFuoAwSoUYDAWFzAcwXkfADHJHKAE5qeULCR6eiwflIzQGIHbDZnJFkFoeBo1Fxl8qQ4DFozbFjwPFoCQl6O4l6esl5hiljl0YGluM74Dp0XJp1lj0mhdFIZR+3hTtZFkg8GKVyCWASGcGJoSGPB1VkkdV1l0XbV3Vpeh+DVr8dhczfRrB+0cGHUA0bUfkRqAAMX5E9BKV+mwUdFtYro5PZAVEdvBl+manFBdfdc9eam9Y2dqv5Ebq2nBmakamdd1E1FQXQV+nFAhOyKRSleUtLmwGGXzcqs6RZaDAgYX01ZgDaBLfQmGJ+ZUe7tVoGd0AIoNcICNYrdmdNPQlNchkdt2Opza3GU8O7oTa8aTZTf5DTYzejezZQ2FrdTgCVamL9elGhdkwdb1ENAjY9a9Z9Y7a7aYwXwLe1bycyfkgHYdCGcbzwZpXXdbZlUdd3bdf3ejcPdlbVbrbQnPbKdqdievZDbDb3ajZjeHYRcuTjYTfLZPatO-eNbPZ1chmkeUAaFwCKArtnn1AVl+gIHVH623addA69Y70-e7fAg9OPcrY-CQ4vYqavcdvtGlXge+HXdcQYanmqFygFRygtIVgZGlSI9fcjYPYdqPZ-b-ZqYKYgGvYsNQ4E4w8UCw+wBw78Dw4JbZw1GE+dbfbA7I-E6-cNck-Bno8A8do72A-Db09I-6ylR0FY67046IfwdEYpb5V46FTQ8E+fZ3d09E4-cM4o6ZeM8Q8qqk-KdiCA9Des4C-A-Mz-VRL6pypbc3bbaC7g6o5M91cHdvd00bbYfHaPKdN7bQhSbOHEBCAEnY91Wc+lFFfS++G5kU8w7gGw9w-w5vcdAk7C77dM--cvZ5Dk5pcc-QEq8IGq7q+Q6KHG8m7c6nmQ+4-5UFX4-Q4zIy5o6y969-f6+k8cWG7Y7q5m6oCq7kcwf9YYHjuJZ2M30S5-hISK7+XhfteTdTfTaqSzaVRcbcYe+FDrv6orj7r0qfYIug6PNy4g8b0uVSZoG86U8VLa9U4680-tG66M87ZM7M8Y5vZY5-XQBq9c-kfc545W7h-W7R+C-g9C8p9K4i9qai6Y6B3jIkrYfbqMg8tS+kwMJu4p8y4Q5p6Q5y5u8h-y-NN+4LAnfvSnbe7nc+5wVcd527ubqyo5+asbuoTS557B7+Qh+e+sJsWa-Q9a-a-U869R564F-C92-KfM609QCs5I+jYM9x8O-m5c8fY89J8U-J4t7g9p+t-p9k+DZi8d-i58R5MKuH1iu2SB4qxB429ma28t766F6Hb18IQK8V+FBg+ikTFMAN84ha+U8R7U4090HN-R+o57bo4G4Y6G8Z5d6c7d+LA95J747J66995o-9-o4Z5vbjOZ9SQhcr+y71ccYgBSbF+19tEnde5nfe8zYXYfgV4vnUq8rYm0rV-8vj99ce44F17-3GGh8N4ZGN6R9N5R4T8o-5795r729t+Y4c7x4riO9q+b6W889W584r8p6T9v6t975B9++ryCPu-i77V8reZre9N4En7SFxe74SXtFGl7z9ZeS-b7rwm8CeVNKWhWPhry55NZQee-A-iO2P6F8jexfE3mX074j9tudPQbqEGG6N98er-Qnud2lCe92+3vagb-xv7d87+kXIAfJ3D4V0WevCZWrck56NZZM7bGgcnx26p88uGfMXvAPjbFdZ+07Wdh9zQEr842-3FLlv2B6a9CB2fcHsL3T5WJ0A6hNdnv2e4yo5+mgxfl9x0Hd1xBvlAwXHyMEO1p+xAyDpYKvQLl3+mveQIoIsFXIT+8PFTqX3w7l8r+IXDHrQID70DIY5gDgUKh0C6BpUHeXQCkLb5pCti0qUwEwJf7N8OO7-VIV-1wCEQYhvPTbrwIgF9dAByQj-it1MA0t30ryPNAT1b7Lc+OvnYjjZ0C4FCchPQtIQ7wGExshhlYRMkIzobrtFG8aX1nVwDZcllUujNCGdw4bzCoA5mSLB2FK4VoeEFxDuNEDOJkAjhM5VkHHH5CnDPKj+LQkoTuHP4mYKjWIvKzoRkAlkMaaYfYRXZT9XhmvOvJ8LUL+CjhT7bIduhaCkMc0AYZMhczsJeodhIOGJqAgrSuwHM5ob5B2BCYEhAgvcHyhcJTq4ATmPoHyjzi0BXCbhRw4kQIC0LnNEyTJbEniNpGrs0SxzJkc-ihFD52RVASEjgFK42RcC0QbkZFk0AOZ+RyEBkE7FYAYiYSwMQIOKL2Hi0Iw8eY7OaVZEp5GSQ4LEpTgwAAAqcGAAAFOA8gMxN1xJFaELOIAJVHSIkYMidR+oo0RwBNGqozRNI6gJaKVQsjiURzDUXaOax6j+u0tNOFoEdEUkXR3Iy0SYGtGcjAgforAPqL5rBjQxpoiMc6SjHP9US3o+Qr6K1HMl-RDosbM6PE7mj3RzpaMXCMyIyA8x8Yw0YWJTEliqAHojMZMizHolNRVY7EvmMDEi0K4IYr7PWLdGNi0x5Y+kbmM7E1jExvYg0f2PDENjIxnotUa2OOZxiAxBoioN4EkBFjXRPlJsfiQrEriHR64nwFuNTFyIFx0hdURiTHH2juxEtRQmuIFQ+AwxxYwcfOPfQxjKx2orsZOPvFHjJAz47cRaOHHNjeEl49sV+JrEGieAMAGwCeLnFlj3x+468V2Kgnq04AcE18QhP2agSlxOYjsTeJ-EhjoJNgACaeJADpi9xo4-Cd+KVFTjiJgeAcTuOAnYSiU+mH0VeOomQSRYhAXstkGsAYSmJZ4xCVRIgmrjuJvE12O0UYlAShJLEsCQeNvFJjxJAqSSaRPgmWIRxto5CRONon3jlJfEzUtJNLEaSQJrEhYOxPAnViAxetASTJKtHCStJnE6yQyUsJGShxskr0WxOzEcTRJCY3Sb-C0gKg1JmEkyZRMcm+TFJvYvWsFMEnkTzxmYryW2IUkGj6IcAcgLZOMn2SwpzDZKalPSluTdxnk8yd5MsnjiAxhElKcoHIAxS7JFEm0TlO0nlT-JlUtKTVMykUSph4U6sSQBgChArAm+XYTQH2GmQeE2I5eNyMzINkPCnmVkKVxFBEjuRZIikaPluGmEUwi06HglOKlJTrxG0j8TCJXYREs0zDO8A+DzRbS+gFkjaRWIOm8iQopbYFN1GFEg5RRrABUVNVwBSi54wFWUcvHekaQexKoiRIuMSnLjGpDo40QVKwn1ToRWMX4ReNwk+SrJfkoMVOM4BtT3JcUhycw1ukgztpYMpyQWMWwZTMZmknGXDKKmXSSpCkiqTOJfGxS6p+0imXjKpk7TCZhov8STN3Ewyh8uMhGaDLwkRSKpf4jGW+OymwzkyLMsoBZOSn0SuZ0MpmZLP5n4zBZyMyKfePomizmJPMlOszOVmsyCZEUg0fpMknyzZJOspMvDIunSzqZ4M9WSGJNnWAtZoUi2XzOtkGY2ZEUmyVDPNmKyrZLYgWUjLKkoyexihaKT7KxnizeZes92TLLtktT8ps4kKVlNdkxyA5KsoOQROal5TnZkc1OUrO+EIjgceo3UegGwC6jsAeHR2NgG1BgRSkKCcOg1VvoRBVQFWMubqOxYWZMgmuSoIVDgKZQlcc0mAESPlJywroegomD2ANwEiS65tWAOuhsAy4tkg4skZ2iRLcBl5pIisadMOnmkrhRdSoAvOlwbzrpMPLwJnjqx6QZuF8kbEfKXmLSmCt2bZh7j2arthshzEqdkA8rX1zmwALjGqH8b-0BAUAbMnWFtDF4Do8zZCGbUsBtgBEpgD2aMDjLmkD55MARLShgXcBsAcidbF-MvlhB85h0hMhIx3kJdmciZIeUSPXl0MH5xcnALpHPDORzwNAfuS6gLZM5j5bYK2ilgnCdg4GHCmXAADU44bAa2pchmmBAraGtahVPQbGryZFm82kdvJ+Grt95YkaiHfJPlyKdyeC6+tfI8q3yFFD8kSMwWJj3Y0hHBNet7gsm6LvKoQX+f-N0BXMAmzSEBcnlzyNl58bzA6B2CkXgp0oCCpwkgvMwqN1FEkdBXIj8XYKQAuCi+T-L9ndZyFJClRYP0JBnyjF5owLEUGHmaKaFci4KAoqiXdJzJi87gMIt8DW0MlNIwLN8FTJXQclMYk4dpJ6l9ScEBZb6mSGBgCKsFtZdxZQFzIUQ4glgVgIUpEX74z8Pw80lUv4w+FKU8GT8d1N6n9TzAOhXwg-FGUVKko+uFRRWI2WiKbAIAruYwvLR9yVcmUaVjIuiBdgK0ouX6KUtgCKFxFRLVXPPOmVKLgAQ2N5U8MTIwQa6byrJaRioX3LZFK8gpcCs6bFK9g1bO5Zwo1H-KASlYOpTEBHlwimlnElpcsu1KAMbqnSwkDIsmmgLNWeZIkEMurQKLpWmUJoFMvBVMjAssyk7EsjjEYqEFqyuZesvBXSthIiZcldW0RGeAGFPc5hYqTOVxAMiGeIIBdHol8KK0IwbUGhIVAzz6JyiChcSllXyrkFRywVacopCZQxVcAOgBKpfq0gdE1y0yCMHyS0hlAsAUpNrVTAzzjVyqiRkqHNWWruANqnWhqsizdymF2q0-KKurTiqiAL9bLADKwWmqbMbhfsm6CeX8sC0gUoVjmk-SRr5yEix1cw18gEwZcZgWGBwAbBSYK6VAeknFi3p+Qs1OavNdlnyTC1uA3iT1YjljXJhlEJqRMqKCZyJ4slPYZXuzxdgRAoMf0mMPeBzBFh+Q1gdtUpDXSuhpQsoeUCYESC5g42ooEwBgGnBNAWglRQ2nmGFCtqJQpYadRWBunDrR1Q4QLIiIkVEgbAuULQKEEkADpPArg2OhwEiSjqmw3mLdHFQ4hJhh106s-pOvdBqrwg+6vDIevMikYv1vxZ0NesrBlUNaoofLL8Q6TxhC4muThLBu-UUCSw0ao4HKoA0D9kY9IwiAvAHB-IIwUoVPFdBDqEgCYUQDsJagkymR0hlQhsFsXQAUbrhk4KOjEibWeAlcpABUmeq4Dri2IGWRsElCixhLbo48DcnLBTpgRgMudaUPgCnL49xNeYS9ToFEqshnal4N2t6BpFExFAv0H4EcHGg6bzRWYfddPhPJab4eWmijbpqVhHA7A+6rTexts2ma9N0AI4AAE0LN62dwCAD3TFR3wqCiMukLQIaNrN2BR-hbgi0CQmNp2LYusHInSMtN5sKSEZRICaJxI5MPWpxhsDiAst1ECMhMHpFmwSYNbOhfuObBHkSN2eA0hRuKC0h5oNAS1IHD7lJoWNbta4beCJZcacAPGkUkhGeUCaBUQm1kMSAbCibt84mjbNAzWQ9hs6l8vOops3gNxstqmzThptjECQ7NZmxmIZpEDGb3NSsfdYFuZCFaJI6OX0m5oKj2aLQjmkMK0Gf5nBcA7MC2BKqiBwAUE88jLRdpy0uTFQ+WriCFty37i3tFWvDRI0I01bAIdW8jW7Ua3UaWtfUBCOnUVIdaoArG9jamtvX9a4wvGobbGpG3eVL8ImnxTQFQWzam0asBbbJpzriBltSmtbUVvQXqaRFmmnbcdp3qVyjNIwEzbdr23EsJgZ24LSpqu2xbtNAujzRYxGA+b8SLgZ7QUDK0awig8m77TllpKZaQdAOvLZ8j+3FaAyUO8HXyt1GlzAgFcujVhHrJBk8Q9YOOEYAjjf1ogpBfJJqEEW9hzQNoNKMDPN3YADRei4AJbr8QnEqehAduZ3LPW26lwodF5h+HGJ8Jxioe0dtgBT0mocOIwrwLQQ2yQR986gZPPhBqBRgyA3QXyEkSSh577MZc1PSHpRYSlaCoe5oXx2xYgAMAfgf7P1jQAahVUlyVPSJDKr2YiAOUfJAWzU6n9FAXLSQJ3N71Iqa9DRAyM7ubAjlCAxEDsCp2nor6O4KeXPFEFYAdhHxb0gyKhC2oKkw9gQVPZ4H73HhB9gebasvDexARb96mHgHSAZAwKW4BEUvbnrUD57hwvewlFXt70p7Z9NpTXq6TwQ-gADgB9QsAcIBPsI8UaCA2fsAN4NL9BgQVMPsqqj7cAHoY8KMBgPlBD9PDZoKEOQMp71CqB6-RgfQhYGcDxIBPfXrlZcMqARB-A-4TIAmgj+kB5PaQZgPAFKSzoXg2SS70PokD2APNL3ooWJ6PS6AYuabvblI8yGC+13YIo9gw5iAXuy3Titm1Kl8IpBVYj2Bd1u7vF8h-3XYomzHYoYfiGMkSVIJJBxQXgE7hN2LKW7ogXAJUhWiDKxB5DCASADeEtSGH3dzZc3RHueWx6hoFpEktwaRXWHSC8+rwKwHy0OZ4g3S2ANOi0hH7JYUengHGD4A76UjmsM-Z4D-Rxt8VCpaXHlCbCW6q9XdYUPipkQxG3hGKPBNJB72p6AA-Mrjt0x68Cce2ghEfdIkELAIpJ1CGEgPmEYoVe1SNABpH0gnYZAGI0fiL1eBF9vIKvYmQaPKBvMfHVNU7EzWbgfKtEV1bAEEUxh3U3BlPYmV2P+R9j0RLbBmT2yGRo9C+HoycT4RHGYAJxm4v2ir1LQKI3dGRZckq3IRlR0YWMAcNR1jbAghe84jNubgfUl0TmC0DPJC1lovYCSODEzBNRNpuMMqTyBXUzC74hlM2iCj6DVLniy84LD-Cti-wAiQhLOTrF81XDt4QCxQIHfrty2chTFrBF+c9m9woU0h2dCwOJodoVZHai21BVJjaHSpBCwUFE2ajRN3wWGVij+W2JQJAYqgqCkU5IDFN06-tZgPdO+hew+5uCugQU5qcdCim1TwGCUwaYKHSnn+vkCbBeoJbnBV1EwOU+zwMiKn9cgLEGBwFNN06hT2WrUzqfVN6mDTKyzksZnQDQbCQJCFTaia9OEhJ2ZrF9gDDSIFo0MuJ6APia91rxiTpdMk8-yBMdguo-C3NQVn4BFRmQD1USNlvSBxx4T3IWHFWDPVbaNtWgds-LFgBkiuzCEWAE+y20WFnuLQUQOzrZjdnvIQ56fH2fgCwAmEKm9BbOe4B1r+VHYcNXWeLpwn9wCJlszWEoRHRiyqIOaMicXPpR4z62ycxARU395oCKCm89W23SEIPTFWJM-urvXymkztAWJK9OaS0F7zl5-szACfbd4IFCoWpHe0D0qbJzriaC0Bcb1pDQL8+cC4RCQt4QOMeaCk+-hHz1ZaTIvEZgycSVxgJmIBTk0-PMXsFX5Rp-kwGfVNBnqIIZq02gvE2SmhOXgh81+HpVBsdAerdi4BbnN-YAciuinSprS0sNs9Tpyui6bdMLn1tYln09xyOi0WNA9FyoIxfFMsWIzyw6M1AFjO85RL5Wp9ksV9YcWBzrKyRI7V4vzL6kq7ELWlqfaahSk+SfJL9HTZ0mW1FMo6coqLktlrsmuyHHFiyaU7BwPAX0CFG8osBCo0SCAAEAB7YL61ayX7drvjVMwsLxOak7hfwGDN8LTeUZkRaZN8HO8ZFrZhRd2bPYqsKp45kxdUtsB1LupiU8PMdyhDphvppS9VfNOWmNL2Wh3CyqjMZoklfjS7INNZOfIAr2kQ-MFdrRhWmDUoqK+3VitImErasCoHruStILUrBOHplScNyZWpBlOOk83kALjNmTGoKZpsxYLPyLFVFvkyafavCmLT2ppi3qcatSmhLq5+hdvgiDWZENe6AiJTvkrjSBwGEUyMhA0D5HTz624eqMFg0Rge6KvHcm-nSs7X+meF8wfSeihHXiLJ1oqzXS5OXXKL5VivJVY1F3XgzD10M9aZYsRh30ym9bazqHPDLdQ3IAAOr80YA2GuAHunL7Alh1sNrtXH3Msr5WhbHM82pqHOD1Cw4QX69FG+K822Y-N6hILasR8qPrHcO3TGBEUjSITamaE2QH1AzyuIiZ9E31szM4nAxuZmLHEAlgkmy6wiYSyzkpM4WUbWV-azlfRsM5GT7tu3jTBWsFbX4Lk6RnjdKscFqLt1xbcYHJtPWQEZ6O029ZZjvxPz6JpU2PWsUlSo7dVsM2UAjOCMuCfuZS+TAjudXdTWd5kK9ZlMmM4gge502MBktKAE7nppOwpaBbp3I74d-U6XcjOBsNVeli0vXdfNJ2UzerNM89k8DYmAF5t2wFksyjW3CzPgc8ZVoliBxITs6BooZBjCkR+Azu8yLyDoiL0gdkYIMAbY7NcQrzzwn+Cffgua8aAt7L4SBCAtbRr762C+wJYDJQFV2XETlVOBsJ92FTcGO6UbcVOshcjYogdd00dt9MycqNw-rlcIteWSLp1wO+RfdxXXeTudt0C3aLuZ3WLMqB2h-erZcXlUPF1Hs-e4D2mmuBsARODvEuOmq7Ulmu2urruUP5LRp5u+HYzvAYS7TV7S93YUpxngd6UcHUZdweHYlbll4cyO3fsbbBHmvRy85dcuah3LEjW6V5cLlnTfLFAfy7vihxZNF72ts+vjEJisg0tM837f7ZStnzEbFeCB0+1-wjsvbmNgq31gQfFWLrwdqixVY9lVW2Hrd4uz1easkLWr-pjB49bbsvXO7Kw-KxWO2glmhpQOsawfh5CqcawLEZeyrAJhqxjHS1omL7e1jFaNrr+La07cgcu2W8btw657fgc43ncSDnZiHZut53gnFNguz1djsymYni4UE5rawhL2dbSx6WGRFbPPLrYADjE8ACxNfpszICwFISalgyxWQNtos+Q4KfgOMrztva6U7RvlPInlTn22yetgcncbNTnk17jQcCndTpsdhznTzXU3Wnz2X4AJBGfJ2wCxNxQk9Yuc+Owzpsdu01ZzvGmGni2955g7k15rbTMUMh5WBofkY6HK6iYMM8TvemWHfp-O5nAbCXOUX3z3q13fMw924XDdxU4PewDD2MzY9qBHicnu2hMo-T2WCXVJNz3izyMKl5cL0dAoOwQZNe1YA3u4FJYO9kUqA33uYQZ51sdBdbFPsfKf4Iry+yU9NjDmG8MaCVwJa2jSvp88rmtSRDfvmlrYn9otg-Fxf927475nAI86Ae-nfQVgMB9hesdQO7HWzuB9jbOtB3kHBNk538-QcAvUXHz4F9g+Muav8Hojohw7RVepG47nIIVwI+YfbQJLtDy9TC7aChvcoVDpu0i7efuugXVzjF+E50s4vquYbwy5r29cCQMCFKCy-6+svjBV2cb4CPZZkdOWXLblt2x5dhHEKTpKS9RxlvidZNGX0mlJ2pjSeGPAgmTs9b9v2cuT8nDti16s+KfrPbHCLexxU7teIOSrjrsqxMA8cWTk3aLr52E8uQtXFLQTt1xu4rUXYM3-VuMCvSGtIjYno1rR4FcPydvknCsVJwY4yflaZ5OTlF3k4seFPLXJT6d3extdAEnHVTgoA69qfXXTnyLwFyE-OeHvHctzutaiVCgKRrI0aXHUSHsiFRRtL9HhDXEyj0UQo8kLNGJg43BweE7kQkB2GBhHQqaIVyeVcssAeEyPikWuM2vNoH6CPTHrJskbWE54mgOeM2sEHJ0dPlwf5nRAaUY8QphrIJ5cF0-vdBwiYut-D+pHFWDQ5QI0V94h8LgjOTbJLyZxbZmdkej8+q+aOhAiDkngPRzlB865otPWyP2DmljKdkgaef7X5y2Mqc8ck3Fttn7O6Hf+e6mvPpduDxC8rtQvo3tdxj488TdtXPPGn9N9w+xe8PQJTnx5wS6Jd3SdPE9yKxS7YUEfDPmeX2KZ-pf5pYFtoY-Pl+lFqlJV2X9SCp+GiFQNzBnrgCIFiCglogJJ2IG0QXArbG5kdBZ91Gi8Ef86SgdMAfawiZQy0HUQbRpCo1WqYJDYdT+x-QXvRW5hEa+jeqZiMfOAs2NUU56ihf3FPCkLTxmaNc-m8jprtyDt-vuKAGoLUElBIl4Au1gAOgTgDoHMIbfiVOgJb9eBe-akPo-2Vb999W9LQ5JTn-MFZBn670P0F3hV1d6ajNRbvmEe71oEe-PfXvO3975944DfedAtcqgCMAsCa5xoFXhoNqAgA4+RgkeHQP9-MKPfLAPgLMCgkx+o-2PoPyKOj6J9wBvvG3oCz4gzPFevA0QHCHiGDVxAWfsucedWriwKlD4xUVbdU8XegfUHLrs52Gds83OcHjoN7wQ7EcO0ufAl8F+d-Y-huaYkL6uzG-2-iMVdkXvd355i9aXb0ETvND3cY9VuSnxlzX366svbobL235nxFB4BKRP6FY534Zcqh2kFkwfjWE+ysuOh-SJqSSb8VLRmoXItkGX6AOAABgmwZ82oDbEExFBrvcPy3Yj-z9r4GdQqCP1VHUa25y-W4KPxYRj-slVvZgQX9uUN3MNs-DMeW8dgsCVA+O8QQiPUgQtaAuWHe1vZkO72D-h-HeDwG3vIL9ZswyW4PcQDojroE1B9cxMIIXAGf6ATAFgDZHG-gnu3asBT1v5oCUfzU3UMjwb-UjobGojAWwPuts8Nab-d-lgLY038aefvrc53dEFRCf-rw4hXIRlwBRD-x6dFrWz3YketflgeE1pVDxPhyAGkhm9TUJhRBsOwU4UlhBRHPEqgwcI+BdhoSP4UeE4iIt3dA2DcAyLZgiHQVeElbSv2aBCIVIidI0Ao4XGNQhMVw0ICAgh0aMAiKcGCIjhcS2KNZiXVEoD4iXwkr8FkVImkZhoS8HZ8egJz1Z19QL8CLBlQZNXgBAYYAFf0KoFuHGMM1fyG4BFA043nJTrLwViILOAbGlQNfJzxBQ3wR2kIgn4WgkIhHAZwBw5I-JTHFB5MLNn5Bk2FwOQQMEBwE1AAACWnZtQLzQcBfoawM3ArAcwELwk8GAE9AFWZDCB8yFOMDOAJA5vxfoUQGQPPMdAOQNgAFAuACUCOfQiFUCCAdQKzAmfMKAsCtIR2jMB1AIwAbBNQWIl1A+jAwN9YjAtnAQU2DHQHiDRiKgEz8kgjyg788-WHxL9PtLQGSD2fFdx-gJAjv245I-ey0jVCQFDxulPLJtxzRSFPNBpFl-cbGABVHFdiNRYIcAOBVylfZSWxetI4VQ88QCkEtRwA7yTSMcoPKGADKqCtG4VMWObzgFQRKgJICcUOgIoC2AqgND9fSeXDoD70BgNiImAzaVZ4fgoQLmUOAj4S4CH4HgPCI+AggJiIIQogIiCkiS3TGAwQcQI8oUg4sHE8MgrINFBdAm4ilAVAtQLVISg+0DOBiwLQKzVcgvQLdAmgo4WMCaWMwPY9ygsXEBgbAzUnsDSARwIr9nA1wPDYPAipE1BvAvwICCggkIO5CIg2fCiCUEeAC5IGHM4CKUKAHZU+UH4VUNIUvLM+Qm0tlRYyMg5QI4CrUkKYdA4B-QSbUoxTgMZX1C9QwkAV47QswBPgMWJwwbxTrWUArpTrdAUdCng3hTdCBsEUkfUEAL0IdCydfU0H0-QpZFOsqVTvDeQ-FDoI1U-0XoMkDcIVIPN8OzTIPkDwgYkKjV8gwoLf1KQ9TQKBiwHX3MCJfTkKqD3UboLqCCA2RAGxDAggJZDEQLUPVCu0cbBbCERHUK7pLQooEL1DQu4BgATQoLUCwLQ6RWtDNlFvjJ1vQsMOdDluJsH9CdAD0I9QBsacMtCzAX0MbBnuU60DC3DEMLcZHQwcCdhIw6lAGwYw8xEfAbQjn06DYAboNHdJgvmAGCbveTRGCcQsYMpN7wzzXstZg04w-pLZbdwkYPwixi-DDLOYMidtg8zHWCSAFfyZhwI3YKrBbPW5WBUmkVNVODMTAJBVxLgmL3Ykbg3KBGVgVF5VlwAAshmrpA0N4MhDJEaENICvgn7jIjUQ6gIBDgiIENHwQiAgNBCbEF4RRCsCSiMCJuA-gL1hIneEJYi1pdgL+CUiLEM5BRg1MLxD0gtTUJCcgvILJCigikOgBNA0tR0D6QkkMZD6w5oMbDWg0wMY8OQqwO5C7ApwD5DDLQULgRhQxqE8CxQ3UB8D-A51kCDgg0INoJZQxPFVBog2IITCEgwkGTDcQ6QIW8CQrMOlANI3MMUiCwlSPTDDIs7GqDqw+oMaDtI5kNaC-CLyOvCM-O8L6CHwmHyfDS-F8JTChfftHfDMoz8MMtvwr42aNRzKAETJAI6YIr8yoxtwGsc0X8DWCl-KCM2CflV5B2g9ROP1CR7IYsjNpY4bClZN+AVKHZB+UWFTUxMoV-SMAiwNsAU8HAeyEMB4AIwB0BogB8hbh0ABCJ79C2FCNiJUPM8lShM6EIghxTIA6PpAcRWXArh4AQ83q0EdCikwB7IDAAOjiIJeFiQ-IVPGVhgVfAOEj3g2IKojyAmiMEC6I0SPtJaAxiOihgQ1iIsIwQ1gJ+jyI4gL+ieIuEL4iI3RELWlkQuGOBj0QsSO+B8Q2SOCicw0kIKDyQun0iifINSIHNQo-QMSiWg0630iywryCMiwgkyIcDzI-UBcDLI9wOsjRQ8UIcj+QJyOlCwgtyKHAPIhUOlxiDRYHQhwLeIPTDZAgmKpjlA4mKUjSYqAFUjM1dSLyC6wmKB0i1pFkPpj2Q8sKZjbA3kJIB+Qmvwsi3AkUK8C7IiUMcipQlyPCCLAOUNFjFQiWMoACYR5W8jUldbxkjNOOSOzCFYvMJJiNAqKMNiYoqsNqDYiLWIbDdY5KMli0IaWNxjfY3QH9iQohSKViIo1WNDjGY8OJqCawtaWjidYlQibCzAd2K7BE4zqPLlO5TaJi8zo-XBOC9otCL5Fto6VVMgFosHGgYVovqCQpgVNTBNBLAQkFrk-AeuUzJKoQkAABiToHiBOgGuIG8J6UEisB1dCAGEU2uFBHIBmoSui4B-TU4OChnaAKMYgm-N2kc0fNHeNniD4ijTMApRczQ+83aEzQJBMfQiGdozASoSfiGwaVCXDAYNdTPjswi+KvjoAXQAo0HAdQMCxAYJ+Jfi81N+J0BHUWDzLdzfQ+IKhL4zjRviCoHDkSMQEx+LzVwEswEgToEwGDLdgcWz3njaCJeJXiagNeI3iq6cdV2iCA1D3vUz1NeFcwF4-I2Sc4gWODa5vo7wl+j3hf6OX5AYziISIQYmgMBCIY5iMYDoY9iPBDMYriJICkYoSJUJeA5nEEjaIriJBjRA8SIzBk4zMOyCA49OPzDigsmNpCNYhkKFQmQ2mJMDSwg2JziHYlmLMinA9mKFCuYmyN5jJQ5yJlCnY9yOTwxYpUIiDGE4hNgBl488DIT14zeMCwK472L-lNE1OMJjFYvROUis4gyLDjKwvOKjjTE3SNOsfEhiD8TYgUhPISQk-0y2J4gjfw0SBvX+LWR64qAMCpA8RjUIgDiGAFiAoAQiAOiq1L8FoSI6QqHoTSVcyASghohrVyDuAYcDxjNOb7SC0nQuOCNw6IfnUsBfoC6JUDKk8wkqTiIXAHMJKhbAHhhVkmGGZB6k8wlqT6k2iG2jmk2AFe99k6tkKSdoR-yPiRgOwC81IAzjVQixnO9TaTrsZ5V1Vq0PeJygEIIaSI0T4WHXwgDSc4VeCgY6RL+jPggGNhjOE+GLRC7SIRPBj7QSGLWk2Iq5A4ipEhIhkTYQuROiIEQxRL4jlEgROxjbcMQIkjXwqSP3iFIOWO0S044xPCj9ErOKLDYecrWLgiVJpEMTKYzWNSTY4umIsSygsOOsSTYs2OAsLYqyKcSbYvmIFiHY4WPlDXYloCOBoEIlUwh8kXuVgAcOV-0RA0tNjVeglk7AHGh6sBiFzJ+ODWAZTcyNFCdQn7elNHR2eH3E4A1sHADWBiINZK1T+mHVKMg9UqqANTzUhdBNT9Us1Lj5gYZ6lYBrUkwDeRVU52kjxbCaBAbBPjd1HmS4ZQpNAE-IqQLSDAo-GPJTokoOOViQ42lPVgXUr1NZw2QrlJzikkuKNrC2U4uLjiRgGVNzI5UhVJgAlU4JREgg09jWAANU+1LJxHU-01VTs0+VmNTnQdtMZSLUjgCtTsAG1NWTzCZtOqAiVZ1K3BXUgWxcRu001N7SfUq6j9TB0gNMN19U4NMd0yGMNIjS4AKNPdQ0o28LPlAIx8Lh9nwySIKjxg3hBqjgIyPzmDn4iqPQEr00qJAifw7BIqj-w5hkfSZg59K+MwIiRkbTzCeXGHTpIXxGaQfpaCK2C-0jVMAy1kpoF8R7YYpIPiRgGtJuSLQaAJUJWkpuSeSG1f1VYBokM+B3BCQL1PEBodYjR+SyNdFOoAOErQnYCPgtFO+DkU4QMESGI+ZSdpREkEPETEUyRPBS6I1FLIDkYpEMxTIibFMBTcUsP0pQCUmujPSLoBNLCgyUokMDiqUuJPGNmuT1MZSigZlOAtA4wuKSiOU3NI8huU4yN5S2YjmMtjuY62PsiXEwWNcj3EkWM8TJU8wDLTZUoMHlTGFatPv8VU+lLwzXoBdBHTtU8dJ7TDU0RHTRiIaBN8yHU-zLnTAs6BJMBiIQvX7SSAMLJbSIs1TMCy4s0gBizw6X1MSyx03VICzzUhdJ6kV0zNMnS8MkNO-ot0n8N3S4AGNJEFEggoCky0wwZJTj5Y3RODjCwlTKzS1M6KD0yq2fNNijI4otJpi0kgbAcyIgctJOi-AFzO4Aa0wDUL59UrzMWgfMzVL8zcsyLLdTBwDLNCzls8LNWyUs81OizYsy1ISztspLN2zOs1LKOyMsgrP3QTsnLKdS8s71JYpF0orNVTSsjdL9QKsr4yqyZY9KMPTio22GL9T0olPPS7pfkR4Q0smUnMhrshw18iNbW0FdhEwY6T9QblL5Nq1jwc0k-S6o79PdQ+0tbGjQH0-7Nqia-eqOlBochYOqjCc69Ir9QI0AUTJgALbMAylswDIhyAMoGCeyepADJAzII8DLpyGcl6MHBWcxY3izBc67M5zOovYJi8L4m8mOCoAo4QI1UPaXOwgEdQ+HlgkwF1GCpnDQwDABeAc8FtAeA0syu5WANeni0IkueN8TF4-xJyTgkyhLQzmRESD3iZMn+IuSIgK5Ntzn8HyPtyG0jVLlygMhsDeRPADIkgAYdUjSyhIAUjJ3AXg85IQS-467go0749BLASME7BPfjoAfILXV4MqPLzo644j3M05ck3JNQ39SWGUA0E78wlIPkzXOYA+ALJX1ypgQ3ONzOEQhPNySEwJNySbcneM9ySU6UAvjLkk+L2iPcl7S9zzCH3LWS-cu6UDzUcsjNDyYdCPO-iu8o+JjyAEt2iAS1SBPMwSk8nBLSkYExUElz58pBIo1UEkGHo9QEtfNfjpUXBNoC4yM5J3yEEz-UfwW48pNuTYieXKbjs9MvUJBC8+EmLzD88j3lENcv5NmIDc5iHryfYs3MySLc7JJbzrcreLdzVCXePY1M86UB7yYCxMPpYCgB3KZhvcp-N9z-c9ImrQg80jJDzdjafI5dZ8+BLzoF85BMsBl82mgfjE80-KgTN8wGFj8ECxBNQzKCuAAPzYMWgpPyIEs-MYLCIf0gzzr8vOkyBF07POoS1pZ-PuScAUQp6lho52A-zzIL-NgxS895K2p-8pEMALYAYAtNyD4ohPAKAk1eKgLQk9vIHzO8sgsQKXc3vJoT+8tAsHyKMyOGwKx8vAonzCC7KGILI84QulAKCwBOATuC5+PXzpUWQq3zOMLwtYLr4-fL-guC4-ICL6C4IrwTL8iXJKSj4+6JQzc8p-PzzPAaBNnluoWaT-zBSLXJ1zq8gAtrygCsehNzG8sAubyjCihOgLTCuwvMLu8qwuQLbCiQHsLh88wlHyTUcfODz7MKfPDySChDKdzo8vfKXy-CmIqwSN8p1ASLvEK-OSKEEvqIfzUMvPNQ9si5QrjA8i8vL+TCiqvL1ySi2yDKKhsCopi99C6oqCTaikwr7yO8x3LnyEEpAp3jvYswsWhMCggNtTOinAuwAeiggr6KiCgYs8L5i8gtGKUEqIqPyk8yYr4Lpii-NmKkivQs1wEEZqmQiG414rmDCIGjxbAzgosn3JvdCADvhazH3LRLdSbMjGjgVEiJ-g5g7dCVAg1NOJ0D9yMwEM1IgTUJ-DgCYwFXY5g-HHKjFAW9PKEuWcGGCoNQdYjb02cYwGJcXUI6hsheSj5L1YyzDtUCBLUYIF30roUgj2gjwfIA5L2gL4wn8cWUfyFKR7PkScgX6HFhzww8I-BFJgkBUiXgn9QqCxLgUD-xq81PEcDVKuS3ISH9T0bUrDwgcE1C4YgwQkFPQjS1ABoAyqM0qrI8VcvOtK9hW0qGh7S0iJEzhA2jL4z0BGApEi8U6FJYy4UlQgRSWAxMq4SmjWRMEjUYrFIEyHCpMrEzgwCTKaytE+TNay00wsI0yU07TLMTWQhJKsTDM0yNNjjMhxKtjbIizLtjXEoWJsyJU8WKlSy4z2Jqy-0csqiSFMjOOpTSg-TL6yI4-OJUJ6y4bIQVhyiuPNICS6IAV4Ny6YOrQlkA6QfgPzZAKwhgUOJxBtzwI4hdgF4AtgrRtyiQgKNMyxMtRsgRPBkfKSncESBEDyvUoelUAtjKRD4ScbwtR3Cv4psRxylrMpSpypTKpD-wOEoRK5mawHHVayrTOLSZJcxJ6ynobLCNieQ1sr5SzAAVMcSeY4VMsyxU-spdjBy90xgqxCOCqOJ1wpkpPDWggpSa91MimOAspcKUGmSLaU63rl2Kh5XSTusJrykwowLiouitYr0oaA6Yy2Rei4ZciqMh4SyiqrzqK2cNajuK0YFyCYAJ7VHLmcUCuTTJy2JJVjlM6CpkrYK+SvHVOU2cowrc4wtILjkK4yRGymECioMVzyjgBoq1S06wQcRIVSqYr1Ygc1Yr4AZSq1ihK-pN4rzo4CxBMAq+eVOtRK5cMjwDpSSrOM7KwyrkrHK0ZLQMfpPytUr1KjVWIRcmQ-VmsaAH8BCzEY9Upxy2DUIoistqBDRKrwrI-RMQxkEYiGLC4VnWGTmQZKvGSSAWSuUrZk58h3T7QJg2iq3wcwjmDTOHKsisqASGEKShCueM0JGoWtGgBPs91DSL-4uXLmCSfe1LogMSu4Q2wGIfAFSKCS3hD3ANi+URaQ5oUePmrx4+IGmAUgSqPADNYx7F60dyQSOsr3JTvBEhlqiAFWqPhbBW0jXq96pZCmCIlVvBWwtdFBE0uU6y5YcEZ8qsFgal21OstY+ZUhEaqTQk8rtAllOMSYC-WLzTzKnlOwr2yzmM7LnEnsqszHYyINIrvEyJyfBEa7rKbLzKgtIGyC49vMJRvq1qO3RTrUziB1IYdJKKq4AFaqZq6Ktyt1BHDPNTa9k8LqtLjqAX6DmNygAdVtyCDFLA4ArVYiFTUQrb7FXl+lcyC3K8oZypxy0uRmp+k3bQPU0J8fO4UCxvtMBCKA2AZolzJslCmR58GKqSFrKfKuAD8q5EMKpTxLEPipCr6wF2tpRIq8kgkq-wuyruEWqpSuEr0q7xCBw5ig+Iy0i1dLSRKYAl-MVgDVENSCtZiSgFoI5QG5SOqhRGK34ANk7cBCADVaAA5dt9dEVaiqM6gBozgUujL4SGMqEKYywY1Mt-L4UjjMzKcU2MsRi0UvMs9slEmMtrq8UtRKWcj8YHOkzZYoKO0qqyzOLVjkazTNZShs9lNQqqaywK5DmYozLsSTMwVIIruy-mPti3E4mrsyyKnAy0gq1e+xLUvK6etRrHqvWNMreszGpbLWY1eo7KzMrsttit63suszd6mAC8SJYiMALVo6vBkQqZ67WJ0z56hmJvrl67Gvvrcax+vxqX6wmvFSSaiWPJL1CVyvrCNKurIDKh6xrMiSwKzSNTSJ67OOpr+shcvuEL6uOMrVq1NsHUIr69CsXqaaohuoAlyueoQVv6owF-rKGtCuijaGlJNnqS09JM1qZ6K9GQaYofdJ6D6s-7OPShgmxgazCo9-Exzic7HO+MqogCMpyn0m9J-Df0wa28RQMjYNX8f6dfwjrswgTT7QFq4lk3RUPBRDVhzlaAAfJWAfargBpAbYE8MBoEjVvCqjasAKhwFQIB6kYAIcCQAsAEJlIAkicoB5AnozOpCaekOaAwAfYOgAwBeQShCoAYm68E3BjwJ6KrTCYe8DMATzMelMaonf2l2UkKTcM0NDhRiBnh0dLPXJKpfDcRlLOQaBDTZfoexv5AXAwpE8D8kXwINBNQIoHBh0ABhH78+-bpr6bemgZp6ahm-puGbBmkZvGaxmyZtGbpmiZumaumqZtmbFmwZukBOgGZr79pAaYEIhzgVZvOBNm84E2Atm84C2bpALZr+AtmiEC2aUgQiGkB5caQAWb7mikigBum6SGIg+-QdOIhNm7AAObsAI5uwATm7ADObsAC5uwArm6cFoC+-aeNoDNm+IAOb4gI5qCJaAs5viALm+ICubOgB0j79OgVZs6BNm2cAEKjmpZqGb5mgQpObOgM5s6ALmzoCubpgeXGmA+-aYFWbpgTZumADm6YCObpgE5umAzm6YAuaLqwiE2B5cTYD79NgVZs2BNmzYAObNgI5s2ATmzYDObNgC5s2Arm10y2aHm-ppQ43IN5rABVm4oE+awAb5tuh8qh1GXhdUAMGhCV9ZkEaIKCE0vmZyRTpGNaoAUdhocwAZI0UAamzUDqbNgBpt+gmmipBaa2moRDNamDKtS4AiDNgGGI3GJoFwB4AlDj8Qe7W6Aqrl4BXhdb4UBFkpMU26RBndgAPknMxnW7oDdbam+psaazM-1v1BNQQNqBBD9ENrgAw2iNukho28gFjabWpKDtbE2wIGTb82iR3fxtW1Nsgsc2vNF+tHQRQCLdS4+SGH1xAatr4RkjDpAQ1ugfwR7bI23ABpao0fBAeAgvdb1mBTWytona+0WttqrF2+APTbN2pZDuadG2gGZBNGsAE3bsAd1s9bvW31v5BS28tqvbY2mMwS9W2h1vQEr23tpstu249qzb+289tYAh2wly79YmcdqoBJ2vhG6BI2uwFdYH4Gdq+bX6UCVmBF26YHyQV25dPXa-5bYC3aCDHdtDbRgcNv3b62w9u7bcOk9oz5EyPdEvbcOm9sLavW4tuabWmsttM5NgV9t0t32hNs-bk2ijrTbyOn9oz5AOwduHawOsdqra+0KYm-bF2poBOBOkBDWeAr0fVrjIKxGjomqD4gQDyhaQGXM40RsMbH2igIONHBQpcBACiDiyDPCpKc8EbAIh18PwAwAGAfADs6HOmdASxiABcAMhY4UyG2qroN8FM6MsGClrNSCbzu8V9za6KcrvzIut0o-YAiDP8qaK8C4AY4S8KVybwIwAYgogIDs5M1DbyFs6NmM6l4VFACEBkhnceSE1BaQdcBygra2ESfATOiuA8jQ9cS08ANyxUncViS2FVJK10PTsWxqAxIBOAWmSDvYwWMhztY4XyzruzDBExIAeA+u6xgxN70ZztY5BGLLq2g5uhBkjIEALrvG7eur0BRppuqlHtBvOnBDjTiUm4ozCnAZjAgpmIEnwcBxQV1hUDzu2AGgRQkViCJVvsuljQbB6-KOHryy07s4ZDO7Ts1AauqIJUDXOm7OB7iIPLsbBzCcHrfiEnUIFK6qAcru6rYmOHoR7hGjKJthxGoHI+6Ggd0wB66u2vVkbgLD0kvbWo8DInpK6WruTx6uy2EwtzPeX2OdOCJX1W6vsWz0MauAAIXJ6ogpPWlM6AcOpUgK5fYl6iHIA0gGihALsGaQtO5QDoaO4HuImiLGuICVxvuyWol64Af7uUBTOjyMWM1sfYDBwPDMJkGKEI37sl6+I1NVG7A8O5M9LDe4zrV6KehUocK+PIMHs7HOx3pc6sukUVO9Lep-QBRXOcnpei5RPhUo1M6-xCCAnIM0GOq7SiGhdQtq9gC8VbG0vJ4CT4AKBbgBk2uMt6mexbERAjhdaF38bio4Bmz28gJBF8DIXFRrIsyOIDfAQgWbVRwfDF4KRSVCLPuAsIc+9IdDYievrMAycloxNQsmDc2hIMPURRCBu5VPCGliaCtAxVXFMQGiBNo4lFejpqhAFW7+QB1VN6MsnHXW8WkbADMBxeozrT7CsE1DQMy6Bw3+r1+9XBEB46TGDb4K0GxCWzM+vDKCyCqp1CHyW+6-ugTDs4XIcLW+iHLZyss1-uv7rs68MXg5RGfuu4n0fdBfQyuCVlmKWPYZWD7DIUPuiBw+inRJBs8DuRhLswzTqM6pe4xq36zexuOkKN+7Tu971e9xQ0L0YzqAd6hu53uPLXemuiv7bAcwqQz7-emq4ycBa-sb78c5voIDW+9vsqiz5YHsVcH6ESCh6igQrqYISusrsFRKuw6Wq7rezntr0I3RrpmrCSlrpl6ZcdrqmJTe7rs26IASDFaYZu6KCG6L0fwTUHxuybq26rGAbqdJlu85h4HdBwwHgZpGbXvVSkAagZYBO0v7GHSnB4CwXRn+0gEcGH+2wFxySAD-sXSfB9ge-72c1wZcwYwHdPiBBYQ7oKiyCeqpO7wMVAb+7ce5PCB6su8wlB7K0GagnBIenIcbA9kpciOSlyBWpEH4ewVEyGyhlHu+Bfs5MP6Dsok9NyipGnHqkG8e5lne6pg+yyJ7F-MDM2CyeggePh2h6JxcczFJdzqdwPU3saSYvVnqFR+hm3q56AcHntw14ImLwipDzJYvSLXixfpfy1h20A6Sg6PD2s7OoBiFjgt4hwrLrCAoFO4SQU3hLBTqM34OTLmM+gMbr0y5uscVAFO0F2H7UBUkLqmwVruUG9hjsFd12mngPhJsyE2IcLn+d4ecV-6YFBbBT4avs16yABwBD6eQBqH592AXfSopKjRaKPgrlflEiokR7AGBHIRlAvx0D02IeHryCRgj70xGgWCg0MG6SMTTNOMaHGgjgcUGYqVA68KPSGhiRqFRmhhkax6mR2TIyDWRzhoICVA2UC4AGfcwgJ6x05PDLBpR4lTESjhbkbpHsAQHKaHGR74CkbO8jMLFHhlV1h1wmqmACNHcgIHp1xJAcwnBhTe6GGa6lR2UeUbI-KUa+0OANUfR7eRzHtxCdRxkb1HWdMUedDUCDM0DH98VwhxKslVka8AGgNsCyZWYEb0lhcjCtD6SeKqAB6HtGlfrYkszGEc+HAIcZXl6CRw8xmIkQrbAxHp8RfvFyVhgb3ui8PDYf-jjVQiG2GcB6scJHB3VlzlAqKSKgrRjVdWEggvkP1WMM4IVfubHDzYBWzIomdxpshjVaIEDL5jS6yzqQmWUp-9A++5gD6z0VgF2NAaS-2rALS9yDYB-IE6sJBpAFIHsaIQZIwVIbyCtCgxbArywmoYwSIFh1WKQkF5AmwKJiuIoAHfzelV+-YG4A0m6hGOqFwIeJHijotcA3AqYBE0SBhlQLrTrZ4YcY6xS0P0ypph9HLy0Ae+qgEL1uwVgAGj+k7PQcpIqG9Un7MxnE2zGTQeCao9AaeEiiUkJxiGTh2xw4fmYNzWUCoBeQHRAs6LoVXJjzeeysYPjA4jAfIBO-KUBlxCIDSJthUPHibaymXfVFU9CoaaFDUtId-xy9WYSsuMTJpOAIQCsFLJmPNogQOJomSVCkF69+FTKE2M1ACrr8AgITkCFBFQrBX1x+JyybMsIUykzXk3CESZsQLJ2FVcQEB2FW79+AWYY8ms1TXke9lUPv1cms1ffRNqKcDoPaF8eXyasndyWyeAtuSxMm1KPSzwDXBlREGzuqiRxMjypJpVwjhzgAgj1AFgpmKbC0YtASawUtsLYlOxubDUcGDC-cgBdphJjvyi1WhO6XTAqaZUtLJWvSpo8az8XAEJShRv0dHqlJnBsUy9K2KdhUZYgJGimHlVxR7UQibASyUjoysFqHRGj0Zqmco4YIFGZGp0axzVGr43fSc0OUZJz1GnNG5Die3obPazpuCNILdbV1j0gdO1DPYpwgb7UoBCIV6NQ9UhPTFKBjqp6cE9JAaE13sQbe6dkmCjM4Cw5qGuLGUZJkEBqhx70DTJwRwZjkK2heQMcHumIZx3F-RRBPhBhnIZ6KBRnawNGY5CEZtrnRmtoUP1+n0ZmqD-7Z+s9Q7MG8rBrHrwK3SpDjEZsOKRq6QgBqH8MAX6fPQsAXgHunFiacWJlTRX6ZemIAS0SWpHRLcVFmccD0V0yF6ioKXrjY8BoFD7EyBqFTN60VJ3rnYveu8SgmoCw5HT67yPwbYZhHlqwOQ2tTulIB-GYpmOQjAHJnCZ8sI-0eQAiYWBXo6UgQBFQKfrlE+WNZDpmz7RL0sSQ1e9AdnFsSmfpnmR5rMZmRpiCrGnVopIltmnZ5TjCDjZhWe8gbZx2a8hzELywQ8g52GbxmJaROazmI5kUaTThpsKNjn00jObDmkZ5OdoJU5nGe8h4Z15ESKuJ7MMHpXWagAcAuKDAel97IMWbem5RVEqgAObPdA+nchL6aMBjqwekTA+5hyBtKHgrzp7m+wiildm+gDufoaz1UrhNslcXwEnhRtB1GzqwADEYM9dbOecwDgFbah1SrqB1FPhiyOAYshcfCIA-UppTOB7ntlTsOyrffJ+a31FAKGGChdR47tZ0yfCICw0-fJZgKDUev7LWnNRzae1Giom2CJyPBv3zFm1vRj1F8mkOUdF9UFzGbjB0F8BY6am27nM2D8Fn+aaR-5vxDXNoJitBQYIhlOlCg1AG+YwWrO0BG+k6IWfPCgyF0WqoBxa5f1TVRfMkVF8zAY1Xx8gkKCLnmxZt21VqBMc+dIxra74GmEiVN+Zl9vEQeYQBh50eeZBW5m6aL1u5mX17muKAefemX8z6c0mkR8+cT8jylPz6iV5uUDXntCH2dpn0FVDwyJYwW3owWFa1hdIIZRYiHUM5jHPAtLRfTIzwKQfP304BMu3Mk4WwfcSy-mwoZhb-mUOWkYGmgFjIJAXgLWVXAWuRmoYpHVp+ofWnGhuBaFGL0vKM6HDLbBZxw0F0JbIXewnaZr9ylygDcRQBUhZGByFohZJ6SFqpZaXCFzRqoWasGhcXo6Fq+cggmFghbPxWFmUQ4WMF7hd4WoI-hb99BFv32EXtaUReFItACRZxwpFpRdF8ooR+bx9sFjgEtnzSaRaiXWfWwXK5Vp-yJSW1NNJcvi6kuYxJ80l2ZJQXPoV+e2W3R7JZEb0GmBcGCvRt8O2nEF+y1p8W4BnzOXxFLZbCXx1OUaBX6fA5a8tjlt5ZYY0xtqI2RIlhFc5hfESZYhXbwcFZ-nOAS2Z36Ql7+eiXfhrwCdRCoPxcBnRvItH+qgllUltsNSfXu9nZ+96c4wmV4licXzzMkWaXTlrxhwQUpiIH8WsmIJcIAyV2HmG8YsOUQL4YqVFaxXjut5dCKiV05fCJyym5fHg5jO6Z5BHlgoOhXoAGUdeWIV8au0X6qo4F8DtQcaE9AMBlxerR-mUfrE93jXLypL+py5ZHqy5+SKZnxJmlNrKNMmFSzU90IwFNXzV7yK6DPljoayj8lvkbyjvRhBdKWv0vabON0ACnIBWVG6nLUaVHCRmictG5FZgj01vRuQHLC9mzQlLV+OurQpVO1ZO4sFVibErJM30auW-Y7BornmZmsuYqPQNCSDWbwkNZ5Hw135akjilo6fkaDpofD7W41ohUai1-c6fTGIMjRuunjVl1XLXrVbWiLWcBjIm7Gy1xAMrWPUateSWXVutejmG1j1cnqQpwXTb6qpNtZWmvlvJdgXJG+Bc9KP-WwlgHrAX4nJLWQco03CuAQ82NUMc2pfin5Gp0g9IkAbLAwAMVKYYI8M8D0hwQh1lNbVKdAIAYPRJ0Fbog2a-NkorEEN4C1Ai01qdczWecnNYrHSCrgAOI-AANYtXaxoXQzHzJNDFs8RgQjYws7pO7twyhgRyCWUjze1fXW817jhrGc8-+PHm8PHceY39VKkt97l4IkqUG3yDwkpHMGyOYrK3VmOcbWDE5taZEswNjcio1y9tbR6L1n5a1Gil6Nb5gkFnTbZKE1pRqTXY1yDYajT3bDaRWsNqdfU7sw7j2I2TbRXO49SCARAIgH5wbS0IXgsTeFHSUoaak2916srJjbFuoFc3qAPNTWFlNs9dDXGYS9f5Hr1wlBQ2+GgdahMv13TdTXlgsdfM32oszas3pQH5AiRF1wdAgACQXsF+Q4Sb4cCAXN0+GC2nV+NO3Wo58uaJiZNmlIC22+ire6DuF4rbC2cl89bDWotyNb+XYtpLZJyEtiLaAjk1xDZS3R13RvHWs1ydZzRonLLeVBm0DAaQ2-5b0TQw2S8Ae408F1ftsxjh5iCA6gtVjcZhU1FEqKmezUjb6B-4k7emm1Kjbbx0A+npHOisFSQDEJFQ2CEoWcAIsj+T0PaZifn-0HDziA8PAz2Lz+MDjd1JSPD-wo8EJwGl2qFSdxvUcyKJ8aMa958aI+1+FA0mzoV4FhMTgf-PtEVVznXKOz8IwILQWWwzZphMHtB3bp0BEMOOGQwPxeTTvsBLC0iGA77YndwW0lPDCCZAsXPzkXAGCjCZ3asIneZBpUZJjendTMnc0HtugbpYlT6Lnct0n2YiYAY+MYJk0w3bRxRl2gsdtEQVbGVLcCB6dycx4xed-jEExlh4awR3kupiA+SzaBAaJg-k9KCx2zF3ww3Wz1PXaAsSWF8EFY6qhHbEYmmR8bUZ7ffdUJQvdlBgh8cmysCD27WenY6njwN3cLhBWMPd93g92+fd2uOf3eKXw9ohkD8z3LvABmyALQBGAGdi2nT3+0Udn0BCQHQGNVvvRMmNUC9+eSL2JgHNoImy9y8kr2lHICBr3RgOvaeRPESsFL37Qa0CAgW9tv0vJ29mPbEZ69g1B72VCnyGb3zCRMn7S29-Xc72rUF5Eb37Qe8hWjZ9iRnX2SHWvYT3SWLvZX2MwKfcqTB96ES6qR9pfYb2j9uMFWjNCU-aHwoiC-b32K6cfe73V9nQH-J79-tz9Mn95PZf2D9rxHf2k8QHE33mGYA9-3Y9-feX3AD6-bL3dhr-YOHIqCA7H2ADyfZv37ohA-ujkDuPegO0DsvacpHxhA4IOXwRfef3pGq-d72qd5tAQPW0Ug7-3yDifaAOYKBA8mw6DyA--3cD9-YspMDzqmwOoDig6n3+TBA-5M+Djg4EOb9+igQP6KUQ4YO392A-tAp8UA5zRQLV3cv3GD+Q5QIjwBA6qI2DlA84ONDwemEO2bGQ9f3D9yg4R2pD33d0OcD8Q7L2UoBA7KhrD-g-UPKD3CjMo-kBA7cOIkEw9QP39ijQQPWNJw7EOXDqfdK4EDuaSCPZDsw+P3cDbQ9wMfD-Q8oPfphA4pnIj0w5gPKDueYQO55hI9sOd0G6AcPHoNI98OND1mCIP0wXI5CP0DnkEwOeQSo7kPKDuaAQPu4Yo8SOp94wCUOh8HfY72yD9I7wO9u1F06PddgSFaO8jtnRbgED5c1336Dvo-f2obbQ6LA90eo+iOb9x3fCO+0ZY5gOQJqqCGPolAnQW2iJo+iAVDIbMlzJEIM+D1y7dnBWdAi9if2axBSqf3rCotMxGsRGCIpOd3S-JuG4leoAISJ5SWF-IAADKPYBPjQRIHwQHaKPYs4oACvSyxwx22FNFrW0ezhPY6LcCMAfk4mBGFRyZCAhPvjmwChPiEJg0khCoYSEJPRcQqAQ1H2SqtJPq2GqtHYVGJYSYMWDQ-SJPVCZmpAAATyxDqquhJYTrrqTr8Hvh1sGE8cRk6C3B5Pkyvk4+THQMt3NIhT2IBFOowl0U5PZT5E-oJLRSJ2VP5T6JQdoKCEzETJ12FWxsgzd+LrOhpMHfTNQD-LBQNIUGYKmroz1fPf13CdoCx3IrAMADZYBdy7yUBmdycym6Bu1RQbgM4LOF7hUoWVw-FKfVF0pNB4IuBrgQzqJxZK95f06rgKj6M+fKV6Mo4jOEzpuHHMe4X2BHNQzrbRW7Iz7uGTOEUKJyaP0zyuCtI6j4s476V6aaBqhzSF07dP29+iMIgEQJ0i8b8AXxpax9WV08dOBLFs6xB2zupJ8asAXxlm2K9rqPoVfzSAbE9kuLMB-92FZCDcJrIVWiJGl4TQA+1FsSIBRJ7uRs77OdAuuoeAnSS8mHMrBPc69P4LOuphS9AFuMNMV6ZvdXYTmXs4vP+zuuq+AnSfvYch9BiFmfP3T188eHWzljK+Rbzi2Q-2HzsXnPO-zg84Av3zuGZPPvzp86bPvTuurbO4Zs6LvP01+ffwAVuxC-3OBzK85Yzt908-8FIL5s7fOWMxXIwu-GbfZwvSL5C5guWMypOIufzpC8vOAL6841yqL2bZP3Hzui7YuoU+XFQvooKImYvcLl8+guBLwC5K5VQH8jL3QLqIlovfzsi4YuPzv01Eu+L-88kvrzjLWhjYzv00UvWLzS-+CtmljOAP1LpS-outLljNo3dLlemAODLvC+As66uTvvQ+ohC40uJL4y6Ev7QL4a4uD6eA94uLL-i+MvYL6KFSL3LoK6MuNGeXBSAWM2CdsvML9sZW6PL-C4AvBz+9GIO5LvS5yhCD1dhSunLlS-vRbMMc4PpC0ZK8ivPL6K5MunSTLGHM7L5g7yuKr1K8kvQr+0Aso6rzC86pyrwy8qvQY68-5MOrvxiEPGrnq+auQrljLw8Srn+kkORrxy5bPWr1aNnxBr2banxZr8S7Guqr68-FIprs3FQI1rqC42vQYha8Hplrg+kMP9r5S5auJrx8dOvpr3K4bOmrgq8kujz6AXXhbrndHXhurua7rrYrp0i8OnuHa50B-rzHwuvLL4y+vOGtQG-8PQb4K82uWM-kUBuwjmG6iujrxi9wN3r7bFiPkb3q5oDtL4GcBvkj7G8Ovcb6y57nAbrI6Junr4y5evooOmAxu6YL6-Wuqbqq5pu+97GEBu0zh69Gvmb0GNZvyY0IAxu6zym5bOXL3QeiBAbss65vvrgC8dIMrjG7jPpCfK5FvrLpsHJvwzqW6ZuWz7y-GOiYQG-zPhbuuvSvooKGwxv5jyc9rosqEIlt6J5GOn+llz20FXOFPD5i867FaBiiAILx6+POB94ERYvHLkrm2i-Ln+nAu4BfK4-Pm9n27EuDr78GihgLkaMDu+94O8DRQ7uC+9uXy5O7CuDo+O+n2B9wK+5v2zgrZWiI79O-tBpcrO5ovc7v28cYuqiK7zuirj5KzueLj29rvhLu-aLvPb+9DCoOfeS7v2K7pm9UujoGu8rvc+TXSzvP93u6juarmeEHu+7+9Fo2s7+y-Hv29p0nshp7ie9cuCxzH1AuArpu6Hu2rpK7bvm7ve9wmB70C4wPKb1S5yuCQDm+Yp7rxW-buEMag9DOyr8+5DnmD0M8yxGbte7Cuur0M+4OX76KCEPQz4a41uv7+0EkPQzma5Ael7kOdnxAb1a6geYLRxiDGonYok-voHgB7ZtAb864QfLvaKAsOIH2+8D377j69AGonew--v7QYG8BuqHih-YKobt2jQfEH6KDCPQzpG5wfofY29iPQz+zAxn2Hqydz57pgm8EfaHrI9DOKbvh6Ehabgo9DOGb2h7KPQzzm7vvD7-m8BuhbiR+jv7QJo9DPJbpR93uP9jm8YfcHgY7VvDHjh6pDxzPW4sfaH+Y+4fFj0u3Nu6wfcH+lorWKwAAvLJUd2e1RHLhEkxk7kozpCK4Ud3+d9vdAu1jk6dKu-HlkuBwz1QJ8k7HL0dhSn5q9XGe2EM2UDF7B6UUl2pgVb7HIBuZ6gAwA9LS+ai6bIXOnjxMIJKAhRGupeAp13kkWB-JZpqJg3FtArLx7UPOi1CuUoAeTVtAGAfEG8ACGAiAd3ywh2AB3q0XgDyf4mvSwArsIKqCXIKnvpCeijGgbTSVJYPxFRQc8VKdAYS4MXmlvnrljLOAELnZ+MvRbve4SvyZJWUDRDnqq8IR70AKZfLLn0GOufooJaHju3Ze7jmvGT0YDmu2DLRmihbnqwXefCDT581vvnx5-tBnnwhUfP7nmgOOenvK6AOfNbw85YzM0F57Tk10KF8FaWM7E4jv0X65pYy9LFF-Oe3nhF4Avtb-6ajBgkeF6jv5r+G6n2IX7Z+JerLp0hzbKX9B-tA+SAl-9k0Xhl+Mvfrju6XYwUBXWxeZ75h-5f3UDl8hfuXqq+1ulQFl7Buqrha-2PxX80hxfpXmLx2vlHVSAh2X-bSHDKcvUALrRpCHF9avTTWI8qDxXk1DjprIVISACFPHh5rRFrC58lfQY2W4xs68f581uPn4J+9OQXljMFeElZV6deaA3l9z5nldV88t+VYbTSkpPYQGrAmnikEUAT9OnwCAgA07dcHgbYglDzcI-aAxGCdSaVK4slYgEf0HyJsE1wA3ql6CEILXTAbdDpWCNghB3W-AdUv5MpngA5mWhHT6X8uhOeS4gDXHMgRsLs-6LvkigZoBBwBABoWSRHRBGwdz5VibebiFt9N68GGd+HRW3tbvjfM97DfNJF3ud51wxsFs9BeNnFej7fRz2JXmhZ3wuFN7V2Td7Pft39buTKIWljK+hQzw96PfnQS9+XexsVvxzRX389+ifnlPBVvlGxk1E7fsMisUvfvFMbCOXr31d71hQz3JramxIU-Hx3PtQb2zIuATIE86sIZiKCt+nqPYg+23sboAu93uvGmFIPw6U8BEyHewwATINQAw5QP+d+3pBiqrBI-qAu96dIH37eSY-uSjvG1KqcO6WqjQEVT3PkT34dDA+Vcej5r6f4WJ96Lo9xfo-Fz3rEziApngG0tAZtRkmfz8C75JDyJpKXxOGC4UTYKBepYCCKd4CCdzulUJ9CbOgcjCB1m06wGUs+KEAIwBB32GHPAOJZawT+bfIFPD43XhCWGEK3N0daAz0FSV2AEBB5UJsU1oBnkGOrHTbMgHiBbteFxHrQT6psgAtrqdIB-xDE884iRnAEygou80gM+Kmb9yndK3whETIL4JCny+J3OYjLGSP4YU-5J-bj+f4ddmIDK+jPoQy9DnQb97rff3x9SegaREhF7GcoY3Zfz5Nb3QrR4SI6FtBnbrCAENpjKUFh1-H0iP6+GqrvxBrVUTk7qRCEHQUW-BMOA271mjfXkUbmGMxAV3JceEcoQ2wGE5R041R3AoJQBFRi2+5dlb7TE9vwhFPBv9Ft6Yv6CZ0julUPm65hOYgLqv96PCO7l5x7v5b5KcXj578ZKaAWU4B+DkVVDJqCgGH8MBGiJcJu-JMovVhs-vj+YcJ5oWkAG-NDXVFB+JEOLyxNOSGyG3gjOmlzTxc2XnC+RD4JpBkhJAOn-qeKTon8kxKqpn7AB6fhthQU2foMHw7mDUYE5-6f+ZSR-xsXW0x+3v4sE7QRgjH7ZgYTliVl-eNeX6l-t0HeVuG+vvH6W-ifz1+F+fySwmdFolUIVx++x7nZJUtf7b9UTKUeXD1+1vZ0D0Rrj839N+5dq3+DBbfqU41UTf-H+OxXEPn78BNS1AFMRA-jUCD-Q-7Usdp3TP399+LfuXc4-g-+P7D-BSiP67wo-wn5j+u-OP9D+Q-8P+ewvf7X7vQnf73+J-M-7P6T-n+PU79+elmQrP7OyGZ5R29oYOANJgSBT6T8LPiGmfJ6ng0lvzwUa-S0ngKTr9jVjwTTsLhM8ckU6fztS3QwzI6fYaH+gIQjNCR2yL2Cqrcqrez2HvVNuQroIhwwA12C-wXeC0M-50rq+Hjx45GyA-+48yEp-GKBq+VuLlkwBj-+AwD-4m+--9Ly-iRln-t-7b7j+YAN0v6wuHOP9yfn-uQAEFHH8RAD-8NQPgRr-k3oR-M-8O9ANIsnJcIPKOp80cooQ9-vgpr1FP92kl297pM7BDhD78FSKp94tEgCyMmLxUAY34Pgl80NfqQC7FNQg66nu9wRCvwqAXpAaAcmUfnhYQcEOgAGAeP93wI34GuOKxuIooA52lehGAWEAaAVSwxWK6R+AdgA5OhwCfuJ2hhAdeom-CT0MAODAeJK491iGwAo5LrITNkjkh8KsEB-vNoPKKgox-kFo0AWt4cBkB81kOcp2FDwg9-pNICyDq8RLPWZtzDohdzCugAnlwDTAZRFV2ugJ5AcwCoUhN0VlBLtTBm0wnSGvgN8Akod+vF9MJqZB4SHQAkKLd8JPh4CyAcCkkOgrxfAd11jBkECKdixls1EhQw3krJgfuSJEAa4V7MMYDztKt4IXuhsVgi25BnLGpTXH9oyge+BJzNjgTAat5UStU9+QDHkzAYB9HkqDsc8LvNYTI2YdzM2Y3AXL5XHGMMqLJtt38qiNQgD9MkIPMxntpQgBbvF0kmrHRVSN1BJ3pLBt6NQBzwB5hwPKTZqIBgAurNRBWLPwR7QA556nK65AzKgojgfVZNLAF4zgcG4U7C8587DVZbgWGYJTNTYLZHIh9jhM4FdqOMWuurYVwBZAPgVTYBGGj9nnO55XnGaZxNO8DKbN1ZvPImQfgYNoDjgAp-gScdAQUuANbPjo7gQiCO7BCCu0KhNOgTEg1vESCugQ10svi39nIIjsQHLT4TSkYByPB0DyQb0pMJt1MP9LSAM6v+YDvjmhIlLT1xgQr5iluPRRbJpw9EKgDJzCqhDTJCC13KKCkgdQCJQecxrjv5pfgVmMjjqmgMQdpBWFhAoQujKDWgXKCXjm0BFQfP4-0MqDDjtcxw0OqCPFLaAdQeUC9QTEpxtDV1nsI78yQSSDT1KEYB1OVBGgSE8O3r0D9hkrhdHIf4WXK-hV7NohOXKv854IDNCQPy5D7Ic46epZ5WpnGAwvv4lZgUhB5gRU8XttLhkuqsD1cOsDUwboZzINsCB+lvB9geHY4Qc04bnI8CLgcWDi7KWDyoBi5-sBT5y7M8CoQci54mm3YvgR+JkQXHBUQU4pVQeaC3FJdEsQcCC2weCDGCG5413CWC27IiCJGJ2DDmCqCzQa4oiSkCD7dCCCOHOm40fkiCQANrBytOJYhsPw41NNaCmgUBZ5QQ-ATQWiDewQuD3FL25s8BLBhyLyAnUjepnsDhgtwZb4NHD9Ii4KDo33GY5a0r9kuIGpsNpjYxnwVVAVOsQtQsN8t-wWkJuQkzwdTvoDlrO6DTYJ6DRXD0DMMn0CB5HGA73Pq8gHKy5gwevZQrGGCeXHvZPkCN4RhtyY4wSaglcImCYBpsxrOosDFQpmCOoN28cwd4owwQWDdgUWDGesm4awV85ywWC5zgYr5rPG65OISC4HgTxCngVKC07AJC3XJKZvgSABTwT2D5wQCCBwZ04cQZ85rnCOC35KnZVTBJDoPOm4OwTJCUQX8DzwQpChPNiCEPipC1waODuQUPg5ENbAjfA5MK3OqB2UGKCjwS8cTwfpC5wS4ojIVeDCQHe5bwWagSEIlpInMAAbIduD9cJrp33B+C9nAJBQdL9lrYH+CCljYxgoRrBgIe0tOELFDutupthgouEU5rho3jjBCiYNXsHTkzdQsDPdzojGBaUM6R1sO-8R-ooR4nn5pVvslpIgdgEEvhWYwgFWYo9lO9sZux5dvDWdpwXpCuwQZD5wU5sSVlgEuULZ8jTos9+FFRMKQHAN8+BZDGvjOC6ysv1gAE1t5Np5o8pGQQu9I78-bvb9O9HIggfNBDagZYCF9q7taoVsESoRpFyoY78qocXAaoUVC6oWmIrZlECNsA2BKzMfN2oSG5qAUUApiNtD7QBYRmPo6AvXvfYSxkw0SnNDFj3KopDAeJo1ltQDf5BVw4lJ9DFAH+8dcNDCmAYiA8FIg9PTlS9yhG0DbFKjDOpMwx6gUYD0YUBZCILjCRASp0pgZuZKgA2ZKoMMDl0GrBLUBXRKEhq4EYWu9Dvn1DZwaaCXFEEtJvjZAtoX3cdobNC2dt20C2PNIUYeTDdIfscDohfAiRBVDnQKt57oRYI5oRNs9jm5CuYccd+wZaDolOtgFYYLDXjq6DY1J+cR9qdDK7qVCdaGYgroVv9qoYDCBLM8d6obz4noS1DJ4G9DcTujka6ArCZEDbDypr9CEFIIl4gADCfof3wn2GDC4vHvJIYdlpxYegCdFPDCmAfopl3pHCb1MFBiYdD5MYc2dsYdQDSYTHDyYfjDE1O6CiYRfJmgWTD0AVX9-elTDboM4DHMHuZGYXkkWYbHCQ9huDZIR8MVMH75sILAxMnjQB+YRPc9YWj9CgZQoE4dJD9jhfFgitLCclHLDNztepFYfrDacr1DG4eiDNYWAptYfLDPod3DcoYdC1YFhdjYXdCzoWvczYZdCYlM6BroaP9aoYLC3ao1CuUM9DXoSjA3Yb8AEYVy8u4T7DIUr6R-YV7C2wMDC9CKDD3xKHCAnuHCNFBUDo4d-Jb4UjCNaBUCk4QXCPTnNd04UwDM4QAi8YfpsCYXnCoYcnDSHEXDE4e9tS4ZToK4a4CGYVmQa4dIQPYWzCeQRzDuwU3DdltWheYchBO4UvcV4cLCEPJVQxYX-CKxAtCL4t38R4bLDHfrrCtTkrDhYQ3C1YWeD5IRaCF4ewjl4ZwiDoTPJt9pvCo7sVCd4RdCLYfvD6QFbCboS-C1KvdDT4QEhHYS9DWoS7DMgPtAX5h7C74VQiH4f9ClEadg-oZrwQ4ansIYQ0CGEWfIUEXHDb5CAjaYGAiU4RAjnSjjCs4cXC4EbnD69PnCPKIXD3EagiyIZERBgbTCXASMDsEQjxmYXgjWYdB9GEUQiBodzCW4eQiOwJQiYLNQiEgYl46ETkoGETwiuwVLkC7jLCHITrDhES5Ce4SrCFofEiNYaApWFkIjY4dQif3g2pz9oVDJETBFzoW4Q94ZVCFEUfC7oSfCGoWoimoawAnYW1DXYbojb4d9CBYYYi-YQHDxkUHCzEZ-CLER9C9IK61eEDwCALo34zEZag5kX1ZpGNfR82ssjqAdQFNgI6A1kaDCNkfiQv4YSg1FBHDr6Bt83GDsjQVnVU4YTAiwgEsigEUKhrkWjCnETFMXESMJI4X34i4dKdLIYdVvEYgjPkakZ-kRTC7tmXCaYU2Z6YUTBq4ZEjA0NcjzWC+U7kRD5JYbwi5IQkif5kcCocEkiO4XIifoS8dSkUPxsZpkiiRO8iH4BIk9kXpBOgEZYcnF9xnypmUdkdCFcEG2dUUePDaUYIkEQJE52UdSMe9myZjKo0R9jsV5ZKmHI2EXIikUXrC7TBBlhlC90DQW8cvLG+5BUfQQCQdSiwgLSi83MFQGUTO4KFAKjHKnVDhUfZUCkWPDJUZwix-EUiaUYrDiUYSAAkIUV9wPv4ZnHz4NcliVkxq7UrkOyjmUXH8JSpEB+SqP4zEAUE74LlBO5h7E5UdtQuwSKiESsaiakc8jFYY0liUFSVFAjSVmqHSUPkgGipLMGiuwKGjDUQlUxUYUil4YsjY0Q9DPEUPglUfqidodmiOAKKio0RKi7FMkYpUSai7FN0BBYWmig0e9E5UTqdvYjkjOYXwiPIQIjqkTWiC0XUi8oeNpNCBIivQdvDoHrvDZER0jh-oojj4VqdVEbiB1EZfD3oe7DRkcYi34UYjA4aYiP4Wcj5kWuiC0TIgVkZJdjkes5SxnuitkQsj1UV9Dj0b6RDkaejwpuej2SPuiLkT-DD5O8ifAW+i2AJHC1gKOxHkWgCXkTfJkYe8jQEb4jwEZrdIEc8joEQBiB6kXDdka8if0RMAkEUJBBPmnDXEY2joMTsiFFk6oEERHDkMX9hwUSXCBgU4ChgaEjYUcjgcEQij7uEiiQ9lYJUUZ-R0Uf1D3If-RRfBgBdqnijF4anDUkSIjlYSSi+4RSjYkeTU7hIoowiMio80ePC60ZwiIzh5RKRFHFH9tyJ2AuUJWMsYR2Mm0I9xPJiGxBjEWACJjLhqJkMQmIEw0TQCpqvIM5qrMNR0dyJzUfmjr0XrC3ALxidAYEBykcxi1QfPD+0RaiY0UOi14UTB-yGOjRXKbCZEfVCZ0XP850d0iF0b0il0f0iL4Zoir4SMi64fojuMUHDJkRujDEbMiL0Vi4r0aEAlkQnCWzg+jueDnhNkWliD0deij0fsjBEvej9kWYjMoPliInGHCrEbWiNfjlimsHlio0FDwdhkEiSMSEjK4Wph4UVvFSoO4jAMQ5VgEXVjQMZOjvkZ-xrkZhihscWigUVYAGgfhiJsYsiVvI2iTEaFC3wWtYH-GyY1sU9oNVIija0T6cQgbPc8IPLwfuHcjeVhbI7kTtDslCiDKNmatPQAqoLITtjD0YH46MUti0UbEjZ4eeDWMVHtW4XT4UAviin7OMiiUXZiRYWSjfkWdilsRdjFAIZjS4prpo6tWi3MRljJ4dw5rUW9iMUSQijIYIiB0e5ieMQbCC8DPAfMU6cWkdIi2kdOiD4Z0jboc0iekQ7CIsYMitEaLAYsSICvoUliEsbe8pkffCZkbujn0Zejv4bVjUYah5iMVuZSMZ1jwkUzCesTXRbEYjCgMYNi8YY4iwMc4iIMehioESgjsMfAjgUXhjQUQRj-ETRgMUUlYxdDroRrAVpNsYK8QlOK59keTt+uvtjooFSUdro5icTCkigYVqcTESaBtiB3gz0N8QrsREAqNlwja4Qzj64TPDUcQrseYW3DfsZxjCUd3pkcbQjZGFkiYYYxju0dKQuwVHUGSKPDo0RPC9Yce59YfNC4kU5i+wVUjzIMniJ8Njj6kWshdhvjjbYYTjJ0f5ix4YfDycV6DKcY9DqcRojnYdFj0sU0gxkWzi-oYljt0SDCz0VVjbGDfDD0WqiFAXXUGsbJgn0eDD0sbsissaVijkeViTkeLdUsdVi4BDRinsf4J6MdB8Y8cQiFdvO8OMXbiFXGkjaspHxSUZHjyUXVj18QmjdhmaMhUEnjMcQjj60Y78EMVhirUUDiu0RvjDIX2jc8dfjJMYDiccevD2xiXiVzGXiMYRXjLYbOiukRTjQsVTjz4TTim8YViJ4Z7DO8Y-CNGM-D4CcHCe8QPUaMQPi-AcZdh8eXxKsfPje8R0AXsRgSDkdPimAcHDcCZziCsQ9iY0bRiV8S9iGMSjimMerDPhtrRuZiR9vsfwoKEQSiAcWHin8X7iuwbBNxMaaj-UWPD78Y2i7YULDC8c+5L7oXAmkeOi-McTiAsaTiQCdXjT7LXiz4TgEoCaujn8RUi7QE5tovlECxoTddjTt9hcMnONigMP1TINYxSgOiNXURITh0crAMMLITEIVMYbwHF968Sujhkc111xmDge-PtBm8YzjkCR3jpkTuju8XgSWJPgiYkdoSs8Vd92Ce3CQ8dwShYdPD2YbJC78d19PIL18KgXVD9YZIT-OiQcToVvD5CWVCScfIjlCUojxCYui0PO4Sosaui+8T7i4sfbjmcVCkkCcESu8Y+jUCdsja0TeiSsasiZ8WejyCWPiYCRPjb0RowysaQSKsXEB2iTVijAR+iV+NgSHQLgTIfnzi2sQLiOsVgi4UZRjRcf+j0CaITFkR8jZcV8j5cT8jxsYRipsSJ5Zserj5sVBjVojBQIyE0EdieqjCHHTEdcZDY9cW+5DcbdwsZpcjf4TDCEynMSmsV74j+A8iCgOLjUMfYiYYcNiMYaNiVuG4inkR4jAUWcSfEe3tLiRljpUJbgtYk8SwoZtjAdKtZdcfGojcedJqMabisgebidBnt1DsRHdrkXtjSSZT5ySXScTcWMTQYQsT1vrpC0SSITJcW8ixCfdDB5l2DrseatRjLwT2YayS6MO7iYAJ7jsid7jYCQQirIZnimCc3Cf5rETg8TvjvYV-j0kVljxicOZmSVSjD8esIo8bsSWSTcT0cGySBsRySaUeITuSdQgE8YFIr8fDjP8d3o08cjioibKSLwRqD38TaTH8R7lMyvxjo8bEihSeaTocT9JYcdaSrMSnjOEfaSBSYQj3sfwiXMa6Tgyfniv8e8dhtLwcnCQTicBp483CZASG8UMjtEb1AvCWGRfCSqUYCS3imce3iWccWTWibljJiTATMscMTQYn8T+iV-DaiaEAhid0SoUqMSRAWQSJiWETy3NEir-gwTY8SQivsdviuCffCVSfvj38HWTOyZD9TiXIhWSXfj2SYhiuSakSBMOkTiAKDisida1M0NOSQAL6SlyT19VyZkSdoeKTPMayARDsmTS8amSjGumSNCZmTacTojcySjh8yQjhGyUWTAiaWTkCSliKCQvjGydWSWyVgTeiY+j6yfujGyc2TSCVPiJyeYiucYSgIib2THST2j-6IOSg8UO94iSOSeCTQj6Se2T1SUV8htnIge3mjgGSEaT44Q-jm0buSVyaMAP0YeSNyV6gtybhTQtIDASKTN8yKT8SKKavCZ5NIczyf-iLya4ShlMujqiZ4TsyA+T+AH4TCyQESWiQgSUwM0S28eWTGsZWTvyV0TQKT0SGSX0TOyZ+T8CVMBCCZPjkym2SFAZhSuyRKTSEFKSHMTKS4KXaAt8YhS+YcOSDEaOTCgeBSsKVuSxgaMMBQfKj4cU2jtYVDNh8C8CCKWCTdiZPDOMediU9DgorfOJj7iRljxCeDCvLJGTe0dGS9hvMxk8baShYUdItyRFT4Ka7CFSUhSlSa-CC8fYSZ8MdDGdibDWkUUTFCSUSgsaASa8eAS68RmSPCdmTcgP4S4CaJSt0XVSPyQMTZKcVj5KSej-ybljAKVzjgKXJT2yWBT2qY1jOqZQSJPl+i1ybMT+qSPimSS1ifmFsTOiRLjjSaDiISeBisYQrioMScSxce4j4MfOSsMW0B8MXHDvTpBimyciT-SKcTCYSCj9iWCi+sRCj0EcEiYUYiZ1iREjRcYUCvie+ifiWNTFKQBTJySQIgSS1p-EXYjgMeCSZcSNjDiWNiM4Uric4SWjcMRopdqSWM14LPge8OhZ8hGDS0EVM87UCLoRPhyBF8USStBiSTKdlbiKSbtizcTt1rLrSS6qlBTxqTgTJycyS+yUr1N+p5T-qaaT3SUkSIySiDkhtoA0LCXguEQSSMCcijYKZiiWMYkizKZwT-sShTEiWOSyae9SOqZTTG8FqSvSXqTqaazSVelHE6aVLiHiVySgyRJjJ4da0madKSkqc5ic8VaCP8e6TwkhHidScfjecfLTLelL0SEHDSwLDFl1aRwiSkeGSdaf7jX8VFTfKcUjUKQmSG1HkR2KWdsJ0YASFCZXiycWUSVEWFjKiRVTeKVVTr4QQTYsa3iDEY0Sn4azj46SES2ibpSqyT1TB8QpSMKYyTlKU1SY6UViiCX1SJaQNTc6ecj0KZKTIiXwT+yQHiBaT9i0qRZTuMVZSsZjZTmsfUgZaaLDdSc8jpIVfhraMrSTSarTm0fbTOianiHSVXSX8VGT9ae7TB0ZlSxyZ6SO6WbSJYT6SDSdfgwXEPTakaGTR6ckSXaRPS+lK5jYyUbSciSeTjDr7TlEf7SPTkAS5EVXiQ6WoS+kRHTG8VoSx6ToSTQBk9g8fNAdVEWACVO4ov8idBLokntEdlwA7CceTcRFYd8ic0iz6SnCL6YFjDAMFiwCbIiICdeTKqXTjEqdvSXFA2BIIDDlM9P+Q-hsAzCtsYT-vsj9fIKAxMoGeAEjEYS+0IAyZ5I4dQGXIT8qebDCqVfT50XAzyqQgzI6Ugz4STbjjKf3E7diyDiYDYAf6QRBxoQl0rbvz51hGJYxPhQz4AYEBgbn-i-aYUS6GUHTSiYwz7YcwzmoTeToCc+SRKZJSxKWMAk6fFiU6RWS06eLSfcQZTVYYwTOGdgB9yLWYmLkOThaZZTUKdrTpsQ0DHLoti8YYfTAgIEdqGb5jaGe0ilCcVSVCQTib6eFi76VmS2GRozaqVoz6qREzGqWXTuab7it6WYy+aXaBUiv1pg6ILTkkQ3T7cU3SSUY35CaWYM4Zvvcg-JDTD5M4zyYpRQGvs3SsaZLsLcT5dsLh+JTqRHCSmSvdXuvZjTGdXTXaacdTTq2BLjrlBkKXYyJGVvNRYSfSpEeXjA6cAS-GdfSyqeoTVGYgydEcgyEmSQi9Ce4oRoUfBDCbgy+0AJsS+s10NINlR5zmAxguKjtC7qIjJGQWhiQDIzT6XIyfGUVToGSVTVCZMzb6Swz76cMi5mW0z5wUrgrCUYB0Rjw9b6Ik16ITS4aSCrEB1E2B0qcB1olC7jjvjjh4jAxtvGl2cM1NQhNJvqZcfBgAEAJR9SNN-8VgbkAcUXE02+ksowWeeDlmQl8SRjXkxMZMxzhOzgFujQAIRjGA-AANAmwIBMUEP0znlKkdPGSmSLmcUSGGSFimGVMyBkWoyH6fEyXmS4pFmcqQDCR40-6ebsTCXYCdSA4CUIA2AynkGA5nlQgGWbGocjkMyACefTRmZfTg6UoyHoVyzIsY8yo6cOBeaQsy7dvoT+kasz-6TfpnCOeNJWTZAM-LKyCMivBFWWsg6YGczhmQHSCqQozxmVqyKifizuWTMzeoDVT6ibviJkW+SGqRziBiUYyK6TBTH6dES7Ig3JSkPqALVjYzu0gkSp4WOSNwc6zbIddAC7CFCziXTBBCR7THQfvClQQelnWXFCI1hmzytMlCLpkzBS2elDwIboBIIcgoWKccyeYCqzwGTFNIGb4zrmf4zS8YEzw6Q8yQmbMz2GUZTEmVwyemSazRoSKzBGTfpLUKzB9tpa0jIVEwfUN3J74o6yf8TNA22Z6VLydxSqiXqy6cfeSfCYJSCyYSg5rrkzqmfzce1AuMUmJGdh4EGd6mKHtvYiezNbmezqSTJNPYLTtnhBmdb2TmcuVGZt4zhWdv2TnA9vKbCL2dPhHLh0TY6WWTtGRJTk6VJSR8ZWSI2fpTK6Xyzx6QKzrtqlTzKbYzG6fYy02b1C1oJmz8OTmzfgZrFU1GtAmpiMRr8XGSQAL8Zs9DNAmpkcyz1C0dmWeeSt2VxT+2dMzWGXeT+KYeyBAMezz7M+ziSUTTzBvesr2QSgMzkWc72VOAP3mltVSaezBOXkyxbh4oadtezxOR5QR4DJAs9lzSx-hWcJOT+zgOSVCdAMdUwOUzcIOXUS46XozfYSGyomWGyYmQnCeadGynSam8MOULTk2SLTU2Y185pGnN+4d-ivMS6yX8mmSd2cEzbyTmTuOVSxeOQjgn2VS8X2ZTsaAK7BROZ+yKzlxAR4MMhNObJyBOdjShOXLd32SpzEudmc+4Bpy-2e4DcuW3B9OTvCP9r9DXOe3tTObATA2d7CE6YgTdGQ0T9GdJTDGeXSkOVGyUOU-SknL5D7wQ-Ak2VxjMmThyPOe6CUwFCSoAf1gwAZf9IAUKgWsJNyDAsrY3GWq5N2S4T+xj6zdWYOyQue4oBKeFyN1pFzmztFyVbpeyvgQlzG4IGcf2UWxpOZNtH2fxyoufJzz2dK5suWJyKzmdz8uZdz+IlpzIzi9zS4KVzJ0WGcKuQNyX7AGzzOU1zLOU0TGuUGz2caESVKeESeydbiR2SQifITyA7wdvE+uWky-sZVzsOaLThufXp4IWNyZuVx8YAWSy7jnNynjnWo2zFmdluXyJt2exzfWZxzNud4SwuUJS9ud6cDuU6QhzHFzjuR8oMzu2ZkuW9zhhmLSbufty7udSShzI9yTuRnAeeZJzcUKlyiuY3BJeXpztXADziptOYsOUBZquS+S6qUETrOVDzw2W1z7OZ1zoiZqAZtD1yUec5z0maryg2VkyWmfUyNFHjyXShNzCebw1uSuf87ePNzhdr4pxzDjA4AfQk7HoeDcqQUTvGWyzNWRyzlGTqzNCU8zhKeEzYOdBzweXVzmufBzWubEyTGRwzR2Yho-rGzwOsP1zQ8VjyVYZ5zG5t7ViUNuVB6JospII78UYZYBXWNRRGKajDdRCuopUkrY6obJYitFDZaUBaiK+VXz+4QQ4sibZiyeaEYNjpTzmwGxy1ueHz9WQezGeQWSKFKLCvOfE8fObNIp+fny8-hBAuAGY0sAZ5BrGonBenk58Aueb4QZguBdgNrk+AKa4mwMhBp2b4tC6NdtLvgbgQuuIALUFYAsGRpBrGotMs6Ih9GdKtpc5mFBuoV8IJGIvzHdndJwdjl5IdmRNcivINJpO41aIGj5FjFnoomNGh8eFt9PHmn9Tfo7sJ-KiANQFCDtSlcF0SMADD-gTpUBexJ0BVhFvJM-wf+UY0EBQN8kBdyUUBagB44vgKBvJndpuUP4cBVQKDojQKNOgHc2OHAKSBYX8q2FwBkBS0hUBRRoWBcMVLAFgKfkUcDBtPwK3aIILbisIL2BRb94BVwKl+ewJD-pQL8fDmipBaoLK0QiURBbV9GBRoLRUeoKI0WIQiBRwKbwKQLuBUoLRBSoKoiNNULQKZiDBcZjbBeGkfwtoKb-roLrBSZinBV8Z7BXcIbBVmBTMcYK5BZwLiBTwKKBXwKmBdCokIuoLEIrCo9mBP5dBdELkSFEKIhTEKAhYgKghSYKLBbV8VBTIpDgkeB1BTkLLwi4Km9LoKChROF8hQcFChbIK0haYKFBeQLlBWEL-SXSQ3wOoLLSX-9sBeIKqBa0KWhTDi3wKkKyBekLAhSEL6hT0hUBQrSohZb0ihTNz4hZb1xhcr0+heYLo-tULMhTf8VBQrSperMK0BrERJhQwKOhTTS-urEQNhfsKJRlUL+hTULghcsKm9Jf4qBY6sqBefidcOoL4DvQKwmqUBUBTcLhFhvcL8Q8KN7tsKxBXHBXhXhBUBXcKbAF8LwHin9BhS3wMhbwKRhVQLYJuoLYJj8LdBbCLBSiz1aJpFR5hYoLFhacKLhTNzshXkF8hQpEnhSUK8RciKsIgSKwRUsLMReYKoRS8KqBbyTPQOoK6RQiLdhXSKGRR7ibseiL5BecLqRUYBUBWqoYJHABWRQWt+RUyK-hbSKIgHKp+RYKKJRTYAORQMKlhdyLw8GKLBwu8Z3VIKKLVHOsYAO6oRRXkAlReqKZvKqKSRQN5Z1vqLtaLKKzhZCLQhdCKnQvqpGFoRs4RTaKCNuyLCRbsK8NraKbsfaL8NoRszRRCLwRQqLUBcXlIqOoKAxSfc4hbsLgxRwAgxQ+sT7uSKsRZSLFBX6KqBWsJ1BWsJtRagKkxYaKD4imKThQsKzBfGLLRTSK2thEgWhdQBitqmLOhSWKixRmLswjlsPDsrjlDhkLoSlvghpAOoK0BVBvCbdBuxik81IGk9yMC8Et5u6C82W2L5+trRUPEdAToBV0CoOl1L5hs8LUI9BPIHwAkKWOLDIBV1TXMOBR7F0pnWfOKXoF9jtjluBazG9AW5NeAvoH9AAYGzlQYFQAIYHaNy1AjBhBC9oOzmfw7AOatfAsOccONUE6DBMBcAB2dwwrP1NxdAAFxU35DxcSohxfWM1Ql6hvgFlVRwIqF5AL+A-cKEAOkL+LnoP78z-H0ASqrBKG2AXlZ7NEBkJe7dpCAhL-xdhLwYLBKx+IH5XUAK8d+hvB-0NhLP6QMio3hXQ9Pqf4-TLcg5gnVgNzojC5xX+L-AG31GJVQBCJYqERELwCH3ndIeBgqQdAL4FuJXfhuqthKvjl8YRDJ+Lhzvj43Mm+LRSdxKtAFJLmJUQBNAItxU9oRA1JT+EWJTxL4gLMg+rBqo5Jd40NBVoBi-HVMXaHhLOJeWplbPuIvxRVBD4BXAuam+ADTh7EzQChCqQeahNqoOAdqvIN7FobVbAL4LZqp4L5qrZsfcjrU1qi-khPmrB6fl7oewGYtYGKdVzqpdVRiPpCSObHUVCDHAfwtzVdaqO5pFgDVOwp4B4ukUUWngOpfiGgE+RE9IGxB1DXyoV84ahHcoaus53ygigofuikigPyB5+jwB7wF1KjgD6tuAGGkTYi0VY0tBUNqooBayoQ05MVcVhCNyAIJojU0Ah2B+ssUBuoBj4c8BkQZFOaQopTCF7WPSiDurlK3qjzV+IiahWap8g9WNlN1cNBN0UkmN8mk2AA6IehUoASV0APzUquGvgGILEBKktMsJaqa5parvYjiPLVQdihM8oMrUX8nFQhlowsyAG4tMAojUnpSnZ-qurVUNi+ltagdL3qnrUoiEFLMvGFN4eObUppOIMW5tIwPKhNLm1g7UnaiAAXankAw6YpUfpOFZvSo9s2wIlKVCtU8mIGtE4cm4DVKgJVNRSghSZT7UXSH7V9ygHU-BlTK6IGlUmvHGQKIFgVtpUatVIF2BPJfsNuVPhENwpHlvRBUKJwhgM7kiqp9MH4oWimgiQvuE1azLyBDMJPB3HovojcKIoeFI2BkYB5LEnHLK3-vhFRcIFKEhdhMIpdgNAkfdtvpijpEgC58qYPsMDZeyA2AMbLhyKbK6AObL3Nmkxq2Am5J5tLJMpbLlsBomQupb+M+pWAoGgjrRTgtCFVFqfEVNp6Tw5WJZyck6ps5eVpwnv6gpthZsmojhs4IDLLrZYyzD8GYsRAPEAzAHXLLgEGh3FA2BrViCUalIFKN5jwt8YMY1QJEjyzUMRAoGNucBNg0lvzCXyXor7zzjNEpd5regWAGj9e9GcAMILQQS+ZWB55QUBfxrGDdAL+M7nMB4igL+NuFuaBQchXKBbuN8slCgwNJsShjqjuB6ADGBIDISg95XHAXpRNwL4BPLJ5b3pF5VYAS+bvKepRrxJAM1Ak0M-KpbMyBwYIZKH4B0Z-1JzZmQLqAjIFQY0IBvEtIP6Ag0b1oobMAq7Rq9EBCGzZO5l3LmANFUUQUXy2bCXyH4OYRwFXugoFRwAYFXAqYAAgr8AK6wkFb7zkOMPL0FVGBMFXhxsFb70uwXgqowAQqV5aQYTbooBiFZAroFQWwKFVQqaFRUk6FbqwGFecCMFWLV8YDgr2FfINXsPgqJ5dwqU9MUxmcD8xSDD9ZLWnwrxRb7zSFeQq3wCIraFYArXBmgqpFUwqZFawqocRwqC1iYrvgJor35Z-LQNCYqVFWIZYIH-of4Mqx75ZIAiAibzzmCvxO0N4rH5S7RB5YhBzmNgBX5anpSAKsQVOO8yeFpE9aUJ3KWFWABUwCLit7CsZ4SJoY5SgxBFYMfLzIKEr0uhpQSdE-yiQNfoc8HOyaNLKUBav1FXbtud1+jwgSTLkrJpKdImwKvotuSN8gwOKyCoK4Y0pKBNlSOmCBbl7BxiG7VIDOIZU9HfLv5dkhJAK6x7CC7Q-FXgxAlZMq44L4q+5UZBf5JAZV5RToBlRvLVogMrn+JoqTeV9CaIdLhlQEZo-Ar9BPQBatZ6AMrTlYdoTQpqAtchmZzlZcqbIKUhmoCggnNG0YMsvcqtcjZBmbPx9hoFoAvlRsqolSiD+wMGAdAHEqfcNIqsFSkqH4JNJqWZbZS4buL+lUsCiQPVQdENPhLJcdhEfPMqSxuGhVleAokILMqlqDwzHNsdhI8HIhfkERDktKMrb5T-BvFTMr7wCEralWEqFlUEqBapHC3bjepIlSnoCla0tXFcDhp9DgBxvqXCDSKQQqoVVVb5oqZWgm0Y5Vdeh6gGYBxjJE0IwJE1vAOwZj5lwhUAA6gdRf4gNQN9x9VYOptVYBtGIPqrnnj2phyPhAliCqrMAPtVkMP9hEgGAAKfGM5ZqDgAFeK6rVQBSBnnuzVRDIcqUQISrKWJiwYhPYrU9PyqegAGqOWL34qhCbzoQtYR9ZhkTWVVEAQ1UAZCVeGql9EZBkOK4r7KSRCnXK4rIQXHBklcyBr8H4reVVDjwVboAoVUkr8YKmAFSIir9PAOpmusrAn3Nm9rOlirapjir6pnwhCVc1M7QM+Ml2emA+oFdAFSD2AHALqBtQL4FKVSABqVQK5aVaIYhVanonwEQBKKBvK5EH9KZFphLLEJSwhgNsJIDF3RS9NVA7pIIoDQCghdQNAhPQL9Aa5I1BCXNqAlMBeqHAIphvoPqBdQONBr1WNBSkNqBd1elRUPnlVjpZ4Aj1fqAT1WeqL1Terr1beqpYA+qn1S+qdQBzF9bKIZqQoZhBwpwKzpiah-1YBrz1ZerQNXAhwNY1BH1c+rK5HYAUEEaBfWp+q6UjGAHADstkNX+rj1aer0NSBqdQGBr71ThrINapx4EBasHACghxQCRq21MeoOABzZMOGEFD1dRqgNRhr6NVhrGNbhqX1eKB42WOqUEC1AuNWur-QKSA+Nehpf1KNlbFX-Z5NQpRx1GgZKKF2r01cSp+VcmriYGRqdlmuq18Hit3FdXotNSSh91fqZiWHIhpDLzKz1L9wjIBEhGoFosX8oGjcYMSB91UHRrSNXRNFT5qROruRXNX8h3NTWxRlUZqzNT5rUunZraUI5qFas8oXNcQQ-kL9BInqh4vNefzv1X5r+MCCqU9DFqTuMGQumREg0tWl1BVVFrrNf-E5EEEpfas5rHdqWqj1PR5lNVChEeKpqsNEWAQwKmgtNYprrQBzZXFb3oglNW1w1VwBytTtBe9LTMrSAKsUsI8o6qpoq6cn+t1vISrXvISqB5YmqrRuPDuVQPLOAJvsTNcqNYSHugh8vtqhdmlBv1Ydrv1WkYowNW1zCINr1mdxqmtUWBrtQKgeNRzZvsJIBh9LLVmoMngjRpGAhlS8t10AhqhtUsgZQmIZBYL3oxlSnoJtdAAS+QAqIFa4M1VtNrS1WcAupdABWbJwrfeUUAodejqOjJjqTFdgB5krgqFFXZrUdepqaOnlqaqFogYwCT4EEClgJiHIgM2NqB5MJNALIQcrrNe-L4zHsgP5RABqda5F+tanoydY4r0dToqSdQIqyFUIrDFelBRFZxoBdSYriIMjqoAMTqx5ZQ8adfoqB1I1B5dUoqTFXIrqEDYrFder9edSnpfZmrB35SrraCGrqFdb7zlEGTre9PsdO5YbraPEAkYrHpBudTYB8ki-lWmoIpgNVerdQOKB7DLbqH4CBrxoIggL1WZqqtSAAatSAAzAJHrsAKUgrumOrXLHjBLtUY1dQGGwMNWZqboLaBoEBeqY9eKA49ZxrRDJoqJDBIx-tYnqbwNphSmuEF9dYAYaOWepoAA7rclc7rQkgOgrdQXqU9Psdy1ZAgqVTCrklamA4jO-KslAABSaICD63hDsa+wz96gEhEjQfW+1eHXpNRgwra8NZWSrQAz66hBysQzXJwKbWz6wYzp6iiAU6znXO6jLJyIYrAjK-PUt6wAzrirsHuzKWHE0FXrnmOXXm6mXVaK1wZdS5fWPaSvWn67AB36jXWw6yWp9GAnTjyh-XP6jfWPKIzWaK6vXPKWvU5KvSCfamAAN613UaK9-U8KsFUxWDHCJKrvXVqh+BxGbMh9620DD64fVaAUfXYAcfUPwBTxT63mXL6p0KDGE3nEQbFV3eTtXkG1fVrajLL0GrfXoyUSAc6qnU06g-VTq8QA0qkA0IG-LW76jg1Z6eoz42XZVLAhBQ-kGUAq4N0JTqgFUUy0BXRKDNgIIFBCXKnBTmEORDM2caD8gAACK9cg-VNI08AGhq0NuhsI1OCg9av0HGg7TRA1meprkvgQvVzNhKQY0GZs7TV+gJhqPV56uagRoBA1byo+VhLjQQyhtUNJ+v4NZmrZ1LKEp1XOs4Nb+tP10uth19TGb1LeuN10CtV16urR1Jip-1OtAJ0fBuQMNHJiNY80r1QPnSNceMThdKtEMbeuQNHeu4NFithVqYFNcA+qlIBBqINk+ud0uPinqFMuoN7atoNcyu7Vjul217Rpu8i+sM1XBqP1s6sL1OMhRBtupiekgDr1ekG+1NO0b1s2tIMJXxu1perrmFetGViWtjUEBsd1YQFmNv2st1QRqhxl+pZp1+qoVHsxHlgBpFo94Ff16xo-1-IBx1sOv-1DxtuNL+uVsMhnNuXACr6GYGP54BvHkxKCrVzAAIgtcvrlZgEbl2ZBblphLQSAJBnk-CpgA+irF18Col1xiqeNZiox8zUD4IKKsV1ccG1AcolfFyDgn18BpT0ZwHXl-IIewW8ozMVsuPlQYVtAZ8urlF8uiAV8r3AZrlEMr6OxNCAFxNAKFtA6hGMWBJsAMecGmVzykUAjKqQVcogzMvgqNlk0TiApQASw0SjjgkuqRMMSn5EJK2mM0oEs1yBhZNOJsustoAV4cgP5N-LFLV1utCgs8FiVLSFK19DVRNKuB2hqSs3iC+ic2EimP1oBpzmaSD962ptlNRLH1NoKpiViPDiVpppTA5popAlpofgFdDiwTmw2ecVgiYNjQtQoO3tNpBnB1biqrA1usF12AAAAfkmaTbuoQUzRibfeXmq0kOjqENDGgeTQabPTbPBvTQkq-TYSAAzRF0mwBuN3MGZBZPIVAcULx5-DI-rOatGbVFaqaD1C4qZDMjAGTatRugo6qmasChWol2MgzVrkvdPCR0wABVESJE80vjOgqpAyCMwKN9AgGcdBNFkocPp08ZgXZqfTRgNr1G3oAGDlAyRDub5dpE82PtA5-OflolzYuhe3ot1Uuh2BcQixpJAFhBFAIebXfleoHzUea0ug+9HQGCASfjuaigIebPXvXzheSvhnzT34hUPglApV1zp8DubzAEEodLOgAXSAFoFFcgBQAJVw5QE4ArVJIBkACABLXhwAELYNBQkBEAHlUeEgwMgAYqiAAMVMzYRSAPpBUHUEG4DwBY4I2AsLYKIELWnAjADAAgEmBBeQMgAd5IRAQAHNBcANAhUIHfBKFYthPQFPBuLT8JeLfxajeXKy4ANoapfhJavULxb5NFQAsLQbgELbRt-lfFlkAIV1lLQxBLAMzYQgPgAsLZgoqAASAELTCcHdUOAsLd4BEgCLjAsAhaSIRxa-AFxakADxbtydLg2AKRa4ZLxa4GDYB5LfnpFLZYBeLXvgtLaQBkAKs0ZISEAeFM5k+5VhalwghaCoLXJM8EFbqsktAgAA)

```jsx
// xpath for object identification
var xps666 = require("casper").selectXPath;

// assign parameters to p1-p9 variables
var p1 = casper.cli.raw.get(0);
var p2 = casper.cli.raw.get(1);
var p3 = casper.cli.raw.get(2);
var p4 = casper.cli.raw.get(3);
var p5 = casper.cli.raw.get(4);
var p6 = casper.cli.raw.get(5);
var p7 = casper.cli.raw.get(6);
var p8 = casper.cli.raw.get(7);
var p9 = casper.cli.raw.get(8);

// save start time to measure execution time
var automation_start_time = Date.now();
casper.echo("\nSTART - automation started - " + Date().toLocaleString());

// initialise time for timer() function
var timer_start_time = Date.now();

// infinity constant for use in for loops
var infinity = 1024;

// initialise default global variables
var quiet_mode = false;
var save_text_count = 0;
var snap_image_count = 0;

// counters for tracking messages in r, python, sikuli, chrome integrations
var r_count = 0;
var py_count = 0;
var sikuli_count = 0;
var chrome_id = 0;

// chrome context for frame handling and targetid for popup handling
var chrome_context = "document";
var chrome_targetid = "";

// variable for ask step to accept user input
var ask_result = "";

// JSON variable to pass variables into browser DOM
var dom_json = {};
var dom_result = "";

// variable for advance usage of api step
var api_config = { method: "GET", header: [], body: {} };

// variables for api and run steps execution result
var api_result = "";
var api_json = {};
var run_result = "";
var run_json = {};

// variables for R and Python integration execution result
var r_result = "";
var r_json = {};
var py_result = "";
var py_json = {};

// track begin-finish blocks for integrations eg - py, r, run, vision, js, dom
var inside_py_block = 0;
var inside_r_block = 0;
var inside_run_block = 0;
var inside_vision_block = 0;
var inside_js_block = 0;
var inside_dom_block = 0;

// determine how many casper.then steps to skip
function teleport_distance(teleport_marker) {
  number_to_hop = 0;
  if (teleport_marker.indexOf("[BREAK_SIGNAL]") > -1) {
    for (s = casper.steps.length - 1; s >= 0; s--) {
      if (
        casper.steps[s].toString() ==
        "function () {for_loop_signal = '" + teleport_marker + "';}"
      ) {
        number_to_hop = s;
        break;
      }
    }
  } // search backward direction for break step
  else if (teleport_marker.indexOf("[CONTINUE_SIGNAL]") > -1) {
    for (s = casper.step; s <= casper.steps.length - 1; s++) {
      if (
        casper.steps[s].toString() ==
        "function () {for_loop_signal = '" + teleport_marker + "';}"
      ) {
        number_to_hop = s;
        break;
      }
    } // search forward direction for continue step
    if (number_to_hop == 0) {
      for (s = casper.steps.length - 1; s >= 0; s--) {
        if (
          casper.steps[s].toString() ==
          "function () {for_loop_signal = '" +
            teleport_marker.replace("[CONTINUE_SIGNAL]", "[BREAK_SIGNAL]") +
            "';}"
        ) {
          number_to_hop = s;
          break;
        }
      }
    }
  } // handle as break if no step left to continue
  else return 0;
  if (number_to_hop - casper.step > 0) return number_to_hop - casper.step;
  else return 0;
}

// techo function for handling quiet option
function techo(echo_string) {
  if (!quiet_mode) {
    // mute about:blank, eg for desktop automation
    if (echo_string == "about:blank - \n" || echo_string == "\nabout:blank - ")
      casper.echo("");
    else if (tagui_language.toLowerCase() == "english")
      casper.echo(echo_string);
    else {
      var translated_string = translate(
        echo_string,
        "to",
        tagui_language.toLowerCase()
      );
      casper.echo(translated_string);
      if (translated_string.indexOf("ERROR - translation engine") !== -1)
        casper.exit();
    }
  }
  return;
}

// for muting echo in test automation scripts
function dummy_echo(muted_string) {
  return;
}

// for saving text information to file
function save_text(file_name, info_text) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  if (!file_name) {
    save_text_count++;
    file_name = flow_path + ds + "text" + save_text_count.toString() + ".txt";
  }
  var fs = require("fs");
  fs.write(file_name, info_text, "w");
}

// for appending text information to file
function append_text(file_name, info_text) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  if (!file_name) {
    if (save_text_count == 0) save_text_count++; // increment if 0, else use same count to append
    file_name = flow_path + ds + "text" + save_text_count.toString() + ".txt";
  }
  var fs = require("fs");
  fs.write(file_name, info_text + "\r\n", "a");
}

// for saving snapshots of website to file
function snap_image() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  snap_image_count++;
  return flow_path + ds + "snap" + snap_image_count.toString() + ".png";
}

// for saving table from website to file
function save_table(file_name, selector) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  if (!file_name) {
    save_text_count++;
    file_name = flow_path + ds + "table" + save_text_count.toString() + ".csv";
  }
  var row_data = "";
  var table_cell = "";
  var fs = require("fs");
  fs.write(file_name, "", "w"); // always reset file
  if (
    !casper.exists(selector) ||
    selector.toString().indexOf("xpath selector: ") == -1
  )
    return false; // exit if invalid
  if (selector.toString().length == 16) selector = "";
  else selector = selector.toString().substring(16); // get xpath
  for (table_row = 1; table_row <= 1024; table_row++) {
    row_data = "";
    for (table_col = 1; table_col <= 1024; table_col++) {
      table_cell = "(((" + selector + "//tr)[" + table_row + "]//th)" + "|"; // build cell xpath selector to include
      table_cell +=
        "((" + selector + "//tr)[" + table_row + "]//td))[" + table_col + "]"; // both td and td elements
      if (casper.exists(xps666(table_cell)))
        row_data =
          row_data + '","' + casper.fetchText(xps666(table_cell)).trim();
      else break;
    } // if searching for table cells (th and td) is not successful,  means end of row is reached
    if (row_data.substr(0, 2) == '",') {
      row_data = row_data.substr(2);
      row_data += '"';
      append_text(file_name, row_data);
    } else return true;
  }
} // if '",' is not found, means end of table is reached as there is no cell found in row

// for translating multi-language flows (comments in translate.php)
function translate(script_line, direction, language) {
  var start_keywords =
    "|click|tap|move|hover|type|enter|select|choose|read|fetch|show|print|save|echo|dump|write|snap|table|mouse|keyboard|" +
    "wait|live|download|upload|load|receive|frame|popup|timeout|api|dom|js|vision|else if|else|if|for|while|check|";
  var to_separator_keywords =
    "|read|fetch|save|load|dump|write|snap|table|download|receive|for|";
  var as_separator_keywords = "|type|enter|select|choose|upload|";
  var forloop_keywords = "|from|";
  var start_conditions_keywords = "|else if|if|for|while|check|";
  var start_helper_keywords = "|echo|dump|write|";
  var conditions_keywords =
    "|more than or equals to|more than or equal to|greater than or equals to|greater than or equal to|higher than or equals to|higher than or equal to|less than or equals to|less than or equal to|lesser than or equals to|lesser than or equal to|lower than or equals to|lower than or equal to|more than|greater than|higher than|less than|lesser than|lower than|not equals to|not equal to|equals to|equal to|not contains|not contain|contains|contain|and|or|";
  var helper_keywords =
    "|title()|url()|text()|timer()|count()|present()|visible()|mouse_" +
    "xy()|mouse_" +
    "x()|mouse_" +
    "y()|"; // break up mouse_ helper functions to avoid mistaken triggering by tagui_parse.php as sikuli process needed
  var seconds_keywords = "|seconds|second|";
  var start_seconds_keywords = "|wait|timeout|";
  if (!script_line || script_line == "") return "";
  if (!direction || direction == "")
    return "ERROR - translation engine direction parameter missing";
  if (!language || language == "")
    return "ERROR - translation engine language parameter missing";
  if (script_line == "" || script_line == "\r\n" || script_line == "\n")
    return script_line;
  var front_script_line_return = "";
  if (script_line.charAt(0) == "\n") front_script_line_return = "\n";
  var back_script_line_return = "";
  if (script_line.substr(-1) == "\n") back_script_line_return = "\n";
  direction = direction.toLowerCase();
  if (direction !== "to" && direction !== "from")
    return "ERROR - translation engine direction must be to or from";
  if (direction == "from") {
    var column_from = 1;
    var column_to = 0;
  } else {
    var column_from = 0;
    var column_to = 1;
  }
  language = language.toLowerCase();
  var language_count = 0;
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var language_file = "languages" + ds + language + ".csv";
  var fs = require("fs");
  if (!fs.exists(language_file))
    return "ERROR - translation engine " + language + ".csv file missing";
  else {
    var language_raw = fs.read(language_file);
    if (language_raw.indexOf("\r\n") !== -1)
      var language_data = language_raw.split(/\r\n/).map(function(line) {
        return line.split(",");
      });
    else
      var language_data = language_raw.split(/\n/).map(function(line) {
        return line.split(",");
      });
    language_count = language_data.length - 1;
    if (
      !language_data[language_count][0] ||
      language_data[language_count][0] == ""
    )
      language_count--;
  }
  script_line = "[START_OF_LINE]" + script_line.trim() + "[END_OF_LINE]";
  var start_word = "[NOT_ASSIGNED]";
  for (language_check = 1; language_check <= language_count; language_check++) {
    if (
      start_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (start_word !== "[NOT_ASSIGNED]") continue;
      if (
        script_line.indexOf(
          "[START_OF_LINE]" + language_data[language_check][column_from] + " "
        ) !== -1 ||
        script_line.indexOf(
          "[START_OF_LINE]" +
            language_data[language_check][column_from] +
            "[END_OF_LINE]"
        ) !== -1
      )
        start_word = language_data[language_check][0];
      var regex = new RegExp(
        "\\[START_OF_LINE\\]" +
          language_data[language_check][column_from] +
          " ",
        "g"
      );
      script_line = script_line.replace(
        regex,
        "[START_OF_LINE]" + language_data[language_check][column_to] + " "
      );
      var regex = new RegExp(
        "\\[START_OF_LINE\\]" +
          language_data[language_check][column_from] +
          "\\[END_OF_LINE\\]",
        "g"
      );
      script_line = script_line.replace(
        regex,
        "[START_OF_LINE]" +
          language_data[language_check][column_to] +
          "[END_OF_LINE]"
      );
    } else if (
      conditions_keywords.indexOf(
        "|" + language_data[language_check][0] + "|"
      ) !== -1
    ) {
      if (start_word == "check") {
        var array_script_line = script_line.split("|");
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        array_script_line[0] = array_script_line[0].replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
        script_line = array_script_line.join("|");
      } else if (
        start_word !== "[NOT_ASSIGNED]" &&
        start_conditions_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (
      seconds_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (
        start_word !== "[NOT_ASSIGNED]" &&
        start_seconds_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " +
            language_data[language_check][column_from] +
            "\\[END_OF_LINE\\]",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + "[END_OF_LINE]"
        );
      }
    } else if (
      forloop_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (start_word == "for") {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (language_data[language_check][0] == "to") {
      if (
        start_word !== "[NOT_ASSIGNED]" &&
        to_separator_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (language_data[language_check][0] == "as") {
      if (
        start_word !== "[NOT_ASSIGNED]" &&
        as_separator_keywords.indexOf("|" + start_word + "|") !== -1
      ) {
        var regex = new RegExp(
          " " + language_data[language_check][column_from] + " ",
          "g"
        );
        script_line = script_line.replace(
          regex,
          " " + language_data[language_check][column_to] + " "
        );
      }
    } else if (
      helper_keywords.indexOf("|" + language_data[language_check][0] + "|") !==
      -1
    ) {
      if (
        (start_word !== "[NOT_ASSIGNED]" &&
          start_conditions_keywords.indexOf("|" + start_word + "|") !== -1) ||
        (start_word !== "[NOT_ASSIGNED]" &&
          start_helper_keywords.indexOf("|" + start_word + "|") !== -1) ||
        script_line.indexOf("=") !== -1
      ) {
        var regex = new RegExp(
          (" " + language_data[language_check][column_from])
            .replace("(", "\\(")
            .replace(")", ""),
          "g"
        );
        script_line = script_line.replace(
          regex,
          (" " + language_data[language_check][column_to]).replace(")", "")
        );
      }
    }
  }
  script_line = script_line
    .replace("[START_OF_LINE]", "")
    .replace("[END_OF_LINE]", "");
  return (
    front_script_line_return + script_line.trim() + back_script_line_return
  );
}

// for checking if selector is xpath selector
function is_xpath_selector(selector) {
  if (selector.length == 0) return false;
  if (selector.indexOf("/") == 0 || selector.indexOf("(") == 0) return true;
  return false;
}

// for finding best match for given locator
function tx(locator) {
  if (is_xpath_selector(locator)) return xps666(locator);
  if (casper.exists(locator)) return locator; // check for css locator
  // first check for exact match then check for containing string
  if (casper.exists(xps666('//*[@id="' + locator + '"]')))
    return xps666('//*[@id="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@id,"' + locator + '")]')))
    return xps666('//*[contains(@id,"' + locator + '")]');
  if (casper.exists(xps666('//*[@name="' + locator + '"]')))
    return xps666('//*[@name="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@name,"' + locator + '")]')))
    return xps666('//*[contains(@name,"' + locator + '")]');
  if (casper.exists(xps666('//*[@class="' + locator + '"]')))
    return xps666('//*[@class="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@class,"' + locator + '")]')))
    return xps666('//*[contains(@class,"' + locator + '")]');
  if (casper.exists(xps666('//*[@title="' + locator + '"]')))
    return xps666('//*[@title="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@title,"' + locator + '")]')))
    return xps666('//*[contains(@title,"' + locator + '")]');
  if (casper.exists(xps666('//*[@aria-label="' + locator + '"]')))
    return xps666('//*[@aria-label="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@aria-label,"' + locator + '")]')))
    return xps666('//*[contains(@aria-label,"' + locator + '")]');
  if (casper.exists(xps666('//*[text()="' + locator + '"]')))
    return xps666('//*[text()="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(text(),"' + locator + '")]')))
    return xps666('//*[contains(text(),"' + locator + '")]');
  if (casper.exists(xps666('//*[@href="' + locator + '"]')))
    return xps666('//*[@href="' + locator + '"]');
  if (casper.exists(xps666('//*[contains(@href,"' + locator + '")]')))
    return xps666('//*[contains(@href,"' + locator + '")]');
  return xps666("/html");
}

// for checking if given locator is found
function check_tx(locator) {
  if (is_xpath_selector(locator)) {
    if (casper.exists(xps666(locator))) return true;
    else return false;
  }
  if (casper.exists(locator)) return true; // check for css locator
  // first check for exact match then check for containing string
  if (casper.exists(xps666('//*[@id="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@id,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@name="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@name,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@class="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@class,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@title="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@title,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@aria-label="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@aria-label,"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[text()="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(text(),"' + locator + '")]')))
    return true;
  if (casper.exists(xps666('//*[@href="' + locator + '"]'))) return true;
  if (casper.exists(xps666('//*[contains(@href,"' + locator + '")]')))
    return true;
  return false;
}

/**
 * Extra TagUI helper methods
 */

// friendlier name to use check_tx() in if condition in flow
function present(element_locator) {
  if (!element_locator) return false;
  if (is_sikuli(element_locator)) {
    var abs_param = abs_file(element_locator);
    var fs = require("fs");
    if (!fs.exists(abs_param)) {
      casper.echo("ERROR - cannot find image file for present step").exit();
    }
    if (sikuli_step("present " + abs_param)) return true;
    else return false;
  } else return check_tx(element_locator);
}

// friendlier name to check element visibility using elementVisible()
function visible(element_locator) {
  if (!element_locator) return false;
  if (is_sikuli(element_locator)) {
    var abs_param = abs_file(element_locator);
    var fs = require("fs");
    if (!fs.exists(abs_param)) {
      casper.echo("ERROR - cannot find image file for visible step").exit();
    }
    if (sikuli_step("visible " + abs_param)) return true;
    else return false;
  } else {
    var element_located = tx(element_locator);
    var element_visible = casper.elementVisible(element_located);
    // if tx() returns xps666('/html') means that the element is not found, so set element_visible to false
    if (element_located.toString() == xps666("/html").toString())
      element_visible = false;
    return element_visible;
  }
}

// friendlier name to count elements using countElements()
function count(element_locator) {
  if (!element_locator) return 0;
  var element_located = tx(element_locator);
  var element_count = casper.countElements(element_located);
  // if tx() returns xps666('/html') means that the element is not found, so set element_count to 0
  if (element_located.toString() == xps666("/html").toString())
    element_count = 0;
  return element_count;
}

// friendlier name to get web page title using getTitle()
function title() {
  return casper.getTitle();
}

// friendlier name to get web page url using getCurrentUrl()
function url() {
  return casper.getCurrentUrl();
}

// friendlier name to get web page text content using evaluate()
function text() {
  return casper.evaluate(function() {
    return document.body.innerText || document.body.textContent;
  });
}

function timer() {
  // return time elapsed in seconds between calls
  var time_elapsed = (Date.now() - timer_start_time) / 1000;
  timer_start_time = Date.now();
  return time_elapsed;
}

function sleep(ms) {
  // helper to add delay during loops
  var time_now = new Date().getTime();
  var time_end = time_now + ms;
  while (time_now < time_end) {
    time_now = new Date().getTime();
  }
}

// return x,y coordinates of mouse cursor as string '(x,y)'
mouse_xy = function() {
  // use this function declaration style for sikuli detection in tagui_parse.php
  sikuli_step(
    "vision xy_mouseLocation = Env.getMouseLocation(); " +
      "xy_x = xy_mouseLocation.getX(); xy_y = xy_mouseLocation.getY(); " +
      "output_sikuli_text('(' + str(xy_x) + ',' + str(xy_y) + ')');"
  );
  var xy_result = fetch_sikuli_text();
  clear_sikuli_text();
  return xy_result;
};

// return x coordinate of mouse cursor as integer number
mouse_x = function() {
  // use this function declaration style for sikuli detection in tagui_parse.php
  sikuli_step(
    "vision xy_mouseLocation = Env.getMouseLocation(); output_sikuli_text(str(xy_mouseLocation.getX()));"
  );
  var x_result = parseInt(fetch_sikuli_text());
  clear_sikuli_text();
  return x_result;
};

// return y coordinate of mouse cursor as integer number
mouse_y = function() {
  // use this function declaration style for sikuli detection in tagui_parse.php
  sikuli_step(
    "vision xy_mouseLocation = Env.getMouseLocation(); output_sikuli_text(str(xy_mouseLocation.getY()));"
  );
  var y_result = parseInt(fetch_sikuli_text());
  clear_sikuli_text();
  return y_result;
};

/**
 * string cell data sanitiser, returns a CSV formatted string
 * @param {string} cell_data
 */
function sanitise_csv_cell(cell_data) {
  // Replace all double quotes with 2 double quotes
  cell_data = cell_data.replace(/"/g, '""');
  var whitespaceCheckRegex = /\s/;
  // if cell_data has a comma, or new line, or its first or last character is a
  // whitespace, then wrap the entire expression in double quotes
  if (
    cell_data.indexOf(",") >= 0 ||
    cell_data.indexOf("\n") >= 0 ||
    whitespaceCheckRegex.test(cell_data.charAt(0)) ||
    whitespaceCheckRegex.test(cell_data.charAt(cell_data.length - 1))
  ) {
    cell_data = '"' + cell_data + '"';
  }
  return cell_data;
}

/**
 * Returns a CSV-formatted string that denotes a row in a CSV file
 * @param {string[]} row_data a 1-D array of strings denoting data to
 * encode as a CSV row
 */
function csv_row(row_data) {
  // if row_data has at least 1 element, extract and sanitise first element
  // else start_element is empty string
  var start_element =
    row_data.length > 0 ? sanitise_csv_cell(row_data.shift()) : "";
  // concat each row_data with a comma
  return row_data.reduce(function(accumulator, currentValue) {
    return accumulator + "," + sanitise_csv_cell(currentValue);
  }, start_element);
}

// for initialising integration with sikuli visual automation
function sikuli_handshake() {
  // techo('[connecting to sikuli process]');
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  clear_sikuli_text();
  var fs = require("fs");
  fs.write("tagui.sikuli" + ds + "tagui_sikuli.in", "", "w");
  var sikuli_handshake = "";
  if (!fs.exists("tagui.sikuli" + ds + "tagui_sikuli.out"))
    fs.write("tagui.sikuli" + ds + "tagui_sikuli.out", "", "w");
  do {
    sleep(500);
    sikuli_handshake = fs.read("tagui.sikuli" + ds + "tagui_sikuli.out").trim();
  } while (sikuli_handshake !== "[0] START"); // techo('[connected to sikuli process]');
}

// for passing dynamic inputs to sikuli visual automation
function vision_step(vision_intent) {
  if (vision_intent.indexOf("vision ") !== 0)
    vision_intent = "vision " + vision_intent;
  sikuli_step(vision_intent);
}

// for using sikuli visual automation instead of casperjs
function sikuli_step(sikuli_intent) {
  sikuli_count++;
  if (sikuli_count == 1) sikuli_handshake(); // handshake on first call
  if (sikuli_intent.indexOf("snap_image()") > -1) {
    sikuli_intent = sikuli_intent.replace("snap_image()", snap_image());
  }
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write(
    "tagui.sikuli" + ds + "tagui_sikuli.in",
    "[" + sikuli_count.toString() + "] " + sikuli_intent,
    "w"
  );
  var sikuli_result = "";
  do {
    sleep(500);
    sikuli_result = fs.read("tagui.sikuli" + ds + "tagui_sikuli.out").trim();
  } while (sikuli_result.indexOf("[" + sikuli_count.toString() + "] ") == -1);
  if (sikuli_result.indexOf("SUCCESS") !== -1) return true;
  else return false;
}

// for fetching text from sikuli optical character recognition
function fetch_sikuli_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui.sikuli" + ds + "tagui_sikuli.txt"))
    return fs.read("tagui.sikuli" + ds + "tagui_sikuli.txt").trim();
  else return "";
}

// for clearing text from sikuli optical character recognition
function clear_sikuli_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write("tagui.sikuli" + ds + "tagui_sikuli.txt", "", "w");
}

// for setting timeout in sikuli when looking for ui element
function sikuli_timeout(time_in_seconds) {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui.sikuli" + ds + "tagui_sikuli.in"))
    sikuli_step(
      "vision setAutoWaitTimeout(" + time_in_seconds.toString() + ")"
    );
  sikuli_step("vision wait_timeout = " + time_in_seconds.toString());
}

// for initialising integration with R
function r_handshake() {
  // techo('[connecting to R process]');
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  clear_r_text();
  var fs = require("fs");
  fs.write("tagui_r" + ds + "tagui_r.in", "", "w");
  var r_handshake = "";
  if (!fs.exists("tagui_r" + ds + "tagui_r.out"))
    fs.write("tagui_r" + ds + "tagui_r.out", "", "w");
  do {
    sleep(100);
    r_handshake = fs.read("tagui_r" + ds + "tagui_r.out").trim();
  } while (r_handshake !== "[0] START"); // techo('[connected to R process]');
}

// R integration for data analytics and machine learning
function r_step(r_intent) {
  if (r_intent.indexOf("r ") !== 0) r_intent = "r " + r_intent;
  r_count++;
  if (r_count == 1) r_handshake(); // handshake on first call
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write(
    "tagui_r" + ds + "tagui_r.in",
    "[" + r_count.toString() + "] " + r_intent,
    "w"
  );
  var r_step_result = "";
  do {
    sleep(100);
    r_step_result = fs.read("tagui_r" + ds + "tagui_r.out").trim();
  } while (r_step_result.indexOf("[" + r_count.toString() + "] ") == -1);
  if (r_step_result.indexOf("SUCCESS") !== -1) return true;
  else return false;
}

// for fetching text from R integration execution result
function fetch_r_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui_r" + ds + "tagui_r.txt"))
    return fs.read("tagui_r" + ds + "tagui_r.txt").trim();
  else return "";
}

// for clearing text from R integration execution result
function clear_r_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write("tagui_r" + ds + "tagui_r.txt", "", "w");
}

// for initialising integration with Python
function py_handshake() {
  // techo('[connecting to Python process]');
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  clear_py_text();
  var fs = require("fs");
  fs.write("tagui_py" + ds + "tagui_py.in", "", "w");
  var py_handshake = "";
  if (!fs.exists("tagui_py" + ds + "tagui_py.out"))
    fs.write("tagui_py" + ds + "tagui_py.out", "", "w");
  do {
    sleep(100);
    py_handshake = fs.read("tagui_py" + ds + "tagui_py.out").trim();
  } while (py_handshake !== "[0] START"); // techo('[connected to Python process]');
}

// Python integration for data analytics and machine learning
function py_step(py_intent) {
  if (py_intent.indexOf("py ") !== 0) py_intent = "py " + py_intent;
  py_count++;
  if (py_count == 1) py_handshake(); // handshake on first call
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write(
    "tagui_py" + ds + "tagui_py.in",
    "[" + py_count.toString() + "] " + py_intent,
    "w"
  );
  var py_step_result = "";
  do {
    sleep(100);
    py_step_result = fs.read("tagui_py" + ds + "tagui_py.out").trim();
  } while (py_step_result.indexOf("[" + py_count.toString() + "] ") == -1);
  if (py_step_result.indexOf("SUCCESS") !== -1) return true;
  else return false;
}

// for fetching text from Python integration execution result
function fetch_py_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  if (fs.exists("tagui_py" + ds + "tagui_py.txt"))
    return fs.read("tagui_py" + ds + "tagui_py.txt").trim();
  else return "";
}

// for clearing text from Python integration execution result
function clear_py_text() {
  var ds;
  if (flow_path.indexOf("/") !== -1) ds = "/";
  else ds = "\\";
  var fs = require("fs");
  fs.write("tagui_py" + ds + "tagui_py.txt", "", "w");
}

if (chrome_id > 0) {
  // super large if block to load chrome related functions if chrome or headless option is used
  chrome_id = 0; // reset chrome_id from 1 back to 0 to prepare for initial call of chrome_step

  // for initialising integration with chrome web browser
  function chrome_handshake() {
    // techo('[connecting to chrome websocket]');
    var fs = require("fs");
    fs.write("tagui_chrome.in", "", "w");
    var chrome_handshake = "";
    if (!fs.exists("tagui_chrome.out")) fs.write("tagui_chrome.out", "", "w");
    do {
      sleep(100);
      chrome_handshake = fs.read("tagui_chrome.out").trim();
    } while (chrome_handshake !== "[0] START"); // techo('[connected to chrome websocket]');
  }

  // send websocket message to chrome browser using chrome devtools protocol
  // php helper process tagui_chrome.php running to handle this concurrently
  function chrome_step(method, params) {
    chrome_id++;
    if (chrome_id == 1) chrome_handshake(); // handshake on first call
    var chrome_intent = JSON.stringify({
      id: chrome_id,
      method: method,
      params: params
    });
    if (chrome_targetid !== "")
      chrome_intent = JSON.stringify({
        id: chrome_id,
        method: "Target.sendMessageToTarget",
        params: { sessionId: chrome_targetid, message: chrome_intent }
      }); // send as message to target if context is popup
    var fs = require("fs");
    fs.write(
      "tagui_chrome.in",
      "[" + chrome_id.toString() + "] " + chrome_intent,
      "w"
    );
    var chrome_result = "";
    do {
      sleep(100);
      chrome_result = fs.read("tagui_chrome.out").trim();
    } while (chrome_result.indexOf("[" + chrome_id.toString() + "] ") == -1);
    if (chrome_targetid == "")
      return chrome_result.substring(chrome_result.indexOf("] ") + 2);
    // below for handling popup
    else {
      try {
        var raw_json_string = JSON.stringify(
          JSON.parse(chrome_result.substring(chrome_result.indexOf("] ") + 2))
            .params.message
        );
        return raw_json_string
          .slice(1, -1)
          .replace(/\\"/g, '"')
          .replace(/\\\\n/g, "\\n");
      } catch (e) {
        return "";
      }
    }
  }

  // chrome object for handling integration with chrome or headless chrome
  var chrome = new Object();
  chrome.mouse = new Object();

  // chrome methods as casper methods replacement for chrome integration
  chrome.exists = function(selector) {
    // different handling for xpath and css to support both
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotLength"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          chrome_context + ".querySelectorAll('" + selector + "').length"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value > 0) return true;
      else return false;
    } catch (e) {
      return false;
    }
  };

  chrome.elementVisible = function(selector) {
    // same as chrome.exists, except for checking visibility
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var e = document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0); var visible = false; if (!e) visible = false; else {var style = window.getComputedStyle(e); visible = style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';}; visible"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var e = " +
          chrome_context +
          ".querySelector('" +
          selector +
          "'); var visible = false; if (!e) visible = false; else {var style = window.getComputedStyle(e); visible = style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';}; visible"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value == true)
        return ws_json.result.result.value;
      else return false;
    } catch (e) {
      return false;
    }
  };

  chrome.countElements = function(selector) {
    // same as chrome.exists, except element count is returned
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotLength"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          chrome_context + ".querySelectorAll('" + selector + "').length"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value > 0) return ws_json.result.result.value;
      else return 0;
    } catch (e) {
      return 0;
    }
  };

  /* // backup of previous click implementation to experiment with Puppeteer's version
chrome.click = function(selector) { // click by sending click event instead of mouse down/up/click, then focus on element
if ((selector.toString().length >= 16) && (selector.toString().substr(0,16) == 'xpath selector: '))
{if (selector.toString().length == 16) selector = ''; else selector = selector.toString().substring(16);
chrome_step('Runtime.evaluate',{expression: 'document.evaluate(\''+selector+'\','+chrome_context+',null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).click()'}); chrome_step('Runtime.evaluate',{expression: 'document.evaluate(\''+selector+'\','+chrome_context+',null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).focus()'});}
else {chrome_step('Runtime.evaluate',{expression: chrome_context+'.querySelector(\''+selector+'\').click()'});
chrome_step('Runtime.evaluate',{expression: chrome_context+'.querySelector(\''+selector+'\').focus()'});}}; */

  chrome.click = function(selector) {
    // click using Puppeteer's implementation - see TagUI issue #212
    chrome.scrollIntoViewIfNeeded(selector);
    var xy = chrome.mouse.getXY(selector);
    chrome.mouse.action("mouseMoved", xy.x, xy.y, "none", 0);
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 1);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 1);
  };

  chrome.scrollIntoViewIfNeeded = function(selector) {
    // helper function to scroll element into view
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).scrollIntoViewIfNeeded()"
      });
    } else {
      chrome_step("Runtime.evaluate", {
        expression:
          chrome_context +
          ".querySelector('" +
          selector +
          "').scrollIntoViewIfNeeded()"
      });
    }
  };

  chrome.mouse.action = function(type, x, y, button, clickCount) {
    // helper function to send various mouse events
    chrome_step("Input.dispatchMouseEvent", {
      type: type,
      x: x,
      y: y,
      button: button,
      clickCount: clickCount
    });
  };

  chrome.mouse.getXY = function(selector) {
    // helper function to get xy center coordinates of selector
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).getBoundingClientRect(); var result_xy = {x: Math.round(result_bounds.left + result_bounds.width / 2), y: Math.round(result_bounds.top + result_bounds.height / 2)}; result_xy",
        returnByValue: true
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').getBoundingClientRect(); var result_xy = {x: Math.round(result_bounds.left + result_bounds.width / 2), y: Math.round(result_bounds.top + result_bounds.height / 2)}; result_xy",
        returnByValue: true
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (
        ws_json.result.result.value.x > 0 &&
        ws_json.result.result.value.y > 0
      )
        return ws_json.result.result.value;
      else return { x: 0, y: 0 };
    } catch (e) {
      return { x: 0, y: 0 };
    }
  };

  chrome.getRect = function(selector) {
    // helper function to get rectangle boundary coordinates of selector
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).getBoundingClientRect(); var result_rect = {top: Math.round(result_bounds.top), left: Math.round(result_bounds.left), width: Math.round(result_bounds.width), height: Math.round(result_bounds.height)}; result_rect",
        returnByValue: true
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "var result_bounds = " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').getBoundingClientRect(); var result_rect = {top: Math.round(result_bounds.top), left: Math.round(result_bounds.left), width: Math.round(result_bounds.width), height: Math.round(result_bounds.height)}; result_rect",
        returnByValue: true
      });
    try {
      var ws_json = JSON.parse(ws_message); // check if width and height are valid before returning coordinates
      if (
        ws_json.result.result.value.width > 0 &&
        ws_json.result.result.value.height > 0
      )
        return ws_json.result.result.value;
      else return { left: 0, top: 0, width: 0, height: 0 };
    } catch (e) {
      return { left: 0, top: 0, width: 0, height: 0 };
    }
  };

  chrome.mouse.move = function(selector, y) {
    // move mouse pointer to center of specified selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mouseMoved", xy.x, xy.y, "none", 0);
  };

  chrome.mouse.click = function(selector, y) {
    // press and release on center of specfied selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 1);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 1);
  };

  chrome.mouse.doubleclick = function(selector, y) {
    // double press and release on center of selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 2);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 2);
  };

  chrome.mouse.rightclick = function(selector, y) {
    // right click press and release on center of selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "right", 1);
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "right", 1);
  };

  chrome.mouse.down = function(selector, y) {
    // left press on center of specified selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mousePressed", xy.x, xy.y, "left", 1);
  };

  chrome.mouse.up = function(selector, y) {
    // left release on center of specified selector or point
    if (!y) {
      chrome.scrollIntoViewIfNeeded(selector);
      var xy = chrome.mouse.getXY(selector);
    } else var xy = { x: selector, y: y }; // get coordinates accordingly
    chrome.mouse.action("mouseReleased", xy.x, xy.y, "left", 1);
  };

  chrome.sendKeys = function(selector, value, options) {
    // send key strokes to selector, options not implemented
    if (value == casper.page.event.key.Enter) value = "\r";
    if (value) {
      value = value.replace(/\[enter\]/g, "\r"); // to cater for [enter] passed in as part of a variable
      value = value.replace(/\r\n/g, "\r"); // change \r\n to \r which is the enter key for chrome browser
      value = value.replace(/\n/g, "\r");
    } // change \n to \r which is the enter key for chrome browser
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).focus()"
      });
    } else
      chrome_step("Runtime.evaluate", {
        expression:
          chrome_context + ".querySelector('" + selector + "').focus()"
      });
    if (options && options.reset == true) {
      // handling for clearing field by checking options.reset
      if (selector.indexOf("/") == 0 || selector.indexOf("(") == 0) {
        // check for xpath selector and handle accordingly
        chrome_step("Runtime.evaluate", {
          expression:
            "var sendKeys_field = document.evaluate('" +
            selector +
            "'," +
            chrome_context +
            ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0); sendKeys_field.value = ''; var evt = document.createEvent('UIEvents'); evt.initUIEvent('change', true, true); sendKeys_field.dispatchEvent(evt);"
        });
      } else
        chrome_step("Runtime.evaluate", {
          expression:
            "var sendKeys_field = " +
            chrome_context +
            ".querySelector('" +
            selector +
            "'); sendKeys_field.value = ''; var evt = document.createEvent('UIEvents'); evt.initUIEvent('change', true, true); sendKeys_field.dispatchEvent(evt);"
        });
    }
    for (
      var character = 0, length = value.length;
      character < length;
      character++
    ) {
      chrome_step("Input.dispatchKeyEvent", {
        type: "char",
        text: value[character]
      });
    }
  };

  chrome.selectOptionByValue = function(selector, valueToMatch) {
    // select dropdown option (base on casperjs issue #1390)
    chrome.evaluate(
      "function() {var selector = '" +
        selector +
        "'; var valueToMatch = '" +
        valueToMatch +
        "'; var found = false; if ((selector.indexOf('/') == 0) || (selector.indexOf('(') == 0)) var select = document.evaluate(selector," +
        chrome_context +
        ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0); else var select = " +
        chrome_context +
        ".querySelector(selector); if (valueToMatch == '[clear]') valueToMatch = ''; Array.prototype.forEach.call(select.children, function(opt, i) {if (!found && opt.value.indexOf(valueToMatch) !== -1) {select.selectedIndex = i; found = true;}}); var evt = document.createEvent(\"UIEvents\"); evt.initUIEvent(\"change\", true, true); select.dispatchEvent(evt);}"
    );
  };

  chrome.fetchText = function(selector) {
    // grab text from selector following casperjs logic, but grab only first match
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      if (selector.toString().length == 16) selector = "";
      else selector = selector.toString().substring(16);
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          "document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).textContent || document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).innerText || document.evaluate('" +
          selector +
          "'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).value || ''"
      });
    } else
      var ws_message = chrome_step("Runtime.evaluate", {
        expression:
          chrome_context +
          ".querySelector('" +
          selector +
          "').textContent || " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').innerText || " +
          chrome_context +
          ".querySelector('" +
          selector +
          "').value || ''"
      });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.decode = function(str) {
    // funtion to convert base64 data to binary string
    // used in https://github.com/casperjs/casperjs/blob/master/modules/clientutils.js
    if (!str) return ""; // return empty string if somehow null value is passed in
    var BASE64_DECODE_CHARS = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    var c1,
      c2,
      c3,
      c4,
      i = 0,
      len = str.length,
      out = "";
    while (i < len) {
      do {
        c1 = BASE64_DECODE_CHARS[str.charCodeAt(i++) & 0xff];
      } while (i < len && c1 === -1);
      if (c1 === -1) {
        break;
      }
      do {
        c2 = BASE64_DECODE_CHARS[str.charCodeAt(i++) & 0xff];
      } while (i < len && c2 === -1);
      if (c2 === -1) {
        break;
      }
      out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));
      do {
        c3 = str.charCodeAt(i++) & 0xff;
        if (c3 === 61) {
          return out;
        }
        c3 = BASE64_DECODE_CHARS[c3];
      } while (i < len && c3 === -1);
      if (c3 === -1) {
        break;
      }
      out += String.fromCharCode(((c2 & 0xf) << 4) | ((c3 & 0x3c) >> 2));
      do {
        c4 = str.charCodeAt(i++) & 0xff;
        if (c4 === 61) {
          return out;
        }
        c4 = BASE64_DECODE_CHARS[c4];
      } while (i < len && c4 === -1);
      if (c4 === -1) {
        break;
      }
      out += String.fromCharCode(((c3 & 0x03) << 6) | c4);
    }
    return out;
  };

  chrome.capture = function(filename) {
    // capture screenshot of webpage to file in png/jpg/jpeg format
    // having pdf extension saves to a pdf file instead. only works in headless mode, visible mode errors out
    var format = "png";
    var quality = 80;
    var fromSurface = true;
    var screenshot_data = ""; // options not implemented
    if (
      filename.substr(-3).toLowerCase() == "jpg" ||
      filename.substr(-4).toLowerCase() == "jpeg"
    )
      format = "jpeg";
    if (filename.substr(-3).toLowerCase() == "pdf")
      var ws_message = chrome_step("Page.printToPDF", {
        printBackground: true
      });
    else
      var ws_message = chrome_step("Page.captureScreenshot", {
        format: format,
        quality: quality,
        fromSurface: fromSurface
      });
    try {
      var ws_json = JSON.parse(ws_message);
      screenshot_data = ws_json.result.data;
    } catch (e) {
      screenshot_data = "";
    }
    var fs = require("fs");
    fs.write(filename, chrome.decode(screenshot_data), "wb");
  };

  /* // backup of previous captureSelector implementation to use Page.captureScreenshot with clipping directly
chrome.captureSelector = function(filename,selector) { // capture screenshot of selector to png/jpg/jpeg format
// first capture entire screen, then use casperjs / phantomjs browser to crop image base on selector dimensions
chrome.capture(filename); var selector_rect = chrome.getRect(selector); // so that there is no extra dependency
if (selector_rect.width > 0 && selector_rect.height > 0) // from using other libraries or creating html canvas 
casper.thenOpen(file_url(filename), function() {casper . capture(filename, // spaces around . to avoid replacing 
{top: selector_rect.top, left: selector_rect.left, width: selector_rect.width, height: selector_rect.height});
casper.thenOpen('about:blank');});}; // reset phantomjs browser state */

  chrome.captureSelector = function(filename, selector) {
    // capture screenshot of selector to png/jpg/jpeg format
    var selector_rect = chrome.getRect(selector);
    if (selector_rect.width > 0 && selector_rect.height > 0) {
      var format = "png";
      var quality = 80;
      var fromSurface = true;
      var screenshot_data = ""; // options not implemented
      if (
        filename.substr(-3).toLowerCase() == "jpg" ||
        filename.substr(-4).toLowerCase() == "jpeg"
      )
        format = "jpeg";
      var clip = {
        x: selector_rect.left,
        y: selector_rect.top,
        width: selector_rect.width,
        height: selector_rect.height,
        scale: 1
      };
      var ws_message = chrome_step("Page.captureScreenshot", {
        format: format,
        quality: quality,
        clip: clip,
        fromSurface: fromSurface
      });
      try {
        var ws_json = JSON.parse(ws_message);
        screenshot_data = ws_json.result.data;
      } catch (e) {
        screenshot_data = "";
      }
      var fs = require("fs");
      fs.write(filename, chrome.decode(screenshot_data), "wb");
    }
  };

  chrome.upload = function(selector, filename) {
    // upload function to upload file to provided selector
    if (
      selector.toString().length >= 16 &&
      selector.toString().substr(0, 16) == "xpath selector: "
    ) {
      casper.echo(
        "ERROR - upload step is only implemented for CSS selector and not XPath selector"
      );
      casper.echo(
        "ERROR - for consistency with PhantomJS as it only supports upload with CSS selector"
      );
    } else
      try {
        var ws_message = "";
        var ws_json = {};
        ws_message = chrome_step("DOM.getDocument", {});
        ws_json = JSON.parse(ws_message);
        ws_message = chrome_step("DOM.querySelector", {
          nodeId: ws_json.result.root.nodeId,
          selector: selector
        });
        ws_json = JSON.parse(ws_message);
        ws_message = chrome_step("DOM.setFileInputFiles", {
          files: [filename],
          nodeId: ws_json.result.nodeId
        });
        ws_json = JSON.parse(ws_message);
        ws_message = chrome_step("DOM.disable"); // disable invoked DOM agent from running and firing events
      } catch (e) {
        casper.echo("ERROR - unable to upload " + selector + " as " + filename);
      }
  };

  chrome.download = function(url, filename) {
    // download function for downloading url resource to file
    // casper download cannot be used for urls which requires login as casperjs engine can't access chrome
    // the chromium issue 696481 is moving well, else an alternative may be to inject casper clientutils.js
    // TagUI by default auto-sets to allow downloads for headless Chrome (otherwise it prevents downloads)
    casper.echo(
      "ERROR - for headless and visible Chrome, download file using normal webpage interaction"
    );
  };

  chrome.evaluate = function(fn_statement, eval_json) {
    // evaluate expression in browser dom context
    // chrome runtime.evaluate is different from casperjs evaluate, do some processing to reduce gap
    var statement = fn_statement.toString();
    if (!eval_json) {
      statement = statement.slice(
        statement.indexOf("{") + 1,
        statement.lastIndexOf("}")
      );
      statement = statement.replace(/return /g, "");
    } // defining function() with return keyword is invalid for chrome
    else
      statement = "(" + statement + ")" + "(" + JSON.stringify(eval_json) + ")"; // unless variable is passed into fx
    var ws_message = chrome_step("Runtime.evaluate", { expression: statement }); // statements can be separated by ;
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return null;
    } catch (e) {
      return null;
    }
  };

  chrome.withFrame = function(frameInfo, then) {
    // replace casperjs frame for switching frame context
    var new_context = "";
    if (chrome_context == "document") new_context = "mainframe_context";
    else if (chrome_context == "mainframe_context")
      new_context = "subframe_context";
    casper.then(function _step() {
      chrome_step("Runtime.evaluate", {
        expression:
          new_context +
          " = document.evaluate('(//frame|//iframe)[@name=\"" +
          frameInfo +
          '" or @id="' +
          frameInfo +
          "\"]'," +
          chrome_context +
          ",null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null).snapshotItem(0).contentDocument"
      });
      chrome_context = new_context;
    }); // set mainframe_context/subframe_context in dom
    casper.then(then);
    casper.then(function _step() {
      if (chrome_context == "subframe_context") {
        chrome_step("Runtime.evaluate", {
          expression: "subframe_context = null"
        });
        chrome_context = "mainframe_context";
      } else if (chrome_context == "mainframe_context") {
        chrome_step("Runtime.evaluate", {
          expression: "mainframe_context = null"
        });
        chrome_context = "document";
      }
    });
  };

  chrome.waitForPopup = function(popupInfo, then, onTimeout) {
    // replace casperjs waitforpopup for checking popup window
    casper.waitFor(
      function check() {
        // use similar logic as chrome withpopup to scan through list of browser targets
        var found_popup = false;
        var chrome_targets = [];
        var ws_message = chrome_step("Target.getTargets", {});
        try {
          var ws_json = JSON.parse(ws_message);
          if (ws_json.result.targetInfos)
            chrome_targets = ws_json.result.targetInfos;
          else chrome_targets = [];
        } catch (e) {
          chrome_targets = [];
        } // following line scan through targets to find match
        chrome_targets.forEach(function(target) {
          if (target.url.search(popupInfo) !== -1) found_popup = true;
        });
        return found_popup;
      },
      then,
      onTimeout
    );
  };

  chrome.withPopup = function(popupInfo, then) {
    // replace casperjs withpopup for handling popup window
    casper.then(function _step() {
      // get list of targets, find a match, attach to the target and set chrome_targetid
      var found_targetid = "";
      var chrome_targets = [];
      var ws_message = chrome_step("Target.getTargets", {});
      try {
        var ws_json = JSON.parse(ws_message);
        if (ws_json.result.targetInfos)
          chrome_targets = ws_json.result.targetInfos;
        else chrome_targets = [];
      } catch (e) {
        chrome_targets = [];
      } // following line scan through targets to find match
      chrome_targets.forEach(function(target) {
        if (target.url.search(popupInfo) !== -1)
          found_targetid = target.targetId;
      });
      if (found_targetid !== "") {
        var ws_message = chrome_step("Target.attachToTarget", {
          targetId: found_targetid
        });
        try {
          var ws_json = JSON.parse(ws_message);
          if (ws_json.result.sessionId !== "")
            found_targetid = ws_json.result.sessionId;
          else found_targetid = "";
        } catch (e) {
          found_targetid = "";
        }
      }
      chrome_targetid = found_targetid;
    }); // set chrome_targetid only after attaching to found target successfully
    casper.then(then);
    casper.then(function _step() {
      if (chrome_targetid !== "") {
        // detach from target after running then
        var found_targetid = chrome_targetid;
        chrome_targetid = "";
        chrome_step("Target.detachFromTarget", { sessionId: found_targetid });
      }
    });
  };

  chrome.getHTML = function() {
    // get raw html of current webpage
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.documentElement.outerHTML"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.getTitle = function() {
    // get title of current webpage
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.title"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.getCurrentUrl = function() {
    // get url of current webpage
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.location.href"
    });
    try {
      var ws_json = JSON.parse(ws_message); // chrome returns below value on empty dead url
      if (ws_json.result.result.value == "data:text/html,chromewebdata")
        ws_json.result.result.value = "about:blank";
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.debugHTML = function() {
    casper.echo(chrome.getHTML());
  }; // print raw html of current webpage

  chrome.reload = function() {
    // reload the current webpage, then not implemented
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "document.location.reload()"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.back = function() {
    // move back a step in browser history
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "window.history.back()"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.forward = function() {
    // move forward a step in browser history
    var ws_message = chrome_step("Runtime.evaluate", {
      expression: "window.history.forward()"
    });
    try {
      var ws_json = JSON.parse(ws_message);
      if (ws_json.result.result.value) return ws_json.result.result.value;
      else return "";
    } catch (e) {
      return "";
    }
  };

  chrome.echo = function(value) {
    casper.echo(value);
  }; // use casper echo to print output

  chrome.on = function(value, statement) {
    casper.on(value, statement);
  }; // use casper event system
} // end of super large if block to load chrome related functions if chrome or headless option is used

// for live mode simple parsing of tagui steps into js code
function tagui_parse(raw_input) {
  if (tagui_language.toLowerCase() == "english") return parse_intent(raw_input);
  else {
    var translated_string = translate(
      raw_input,
      "from",
      tagui_language.toLowerCase()
    );
    if (translated_string.indexOf("ERROR - translation engine") !== -1)
      casper.echo(translated_string).exit();
    else return parse_intent(translated_string);
  }
}

// for live mode interpretation of step into casperjs code
function parse_intent(live_line) {
  live_line = live_line.trim();
  if (live_line == "") return "";
  live_line = parse_variables(live_line);
  live_line = live_line.trim();
  if (live_line == "") return "";
  switch (get_intent(live_line)) {
    case "url":
      return url_intent(live_line);
      break;
    case "tap":
      return tap_intent(live_line);
      break;
    case "rtap":
      return rtap_intent(live_line);
      break;
    case "dtap":
      return dtap_intent(live_line);
      break;
    case "hover":
      return hover_intent(live_line);
      break;
    case "type":
      return type_intent(live_line);
      break;
    case "select":
      return select_intent(live_line);
      break;
    case "read":
      return read_intent(live_line);
      break;
    case "show":
      return show_intent(live_line);
      break;
    case "upload":
      return upload_intent(live_line);
      break;
    case "down":
      return down_intent(live_line);
      break;
    case "receive":
      return receive_intent(live_line);
      break;
    case "echo":
      return echo_intent(live_line);
      break;
    case "save":
      return save_intent(live_line);
      break;
    case "dump":
      return dump_intent(live_line);
      break;
    case "write":
      return write_intent(live_line);
      break;
    case "load":
      return load_intent(live_line);
      break;
    case "snap":
      return snap_intent(live_line);
      break;
    case "table":
      return table_intent(live_line);
      break;
    case "wait":
      return wait_intent(live_line);
      break;
    case "live":
      return live_intent(live_line);
      break;
    case "ask":
      return ask_intent(live_line);
      break;
    case "keyboard":
      return keyboard_intent(live_line);
      break;
    case "mouse":
      return mouse_intent(live_line);
      break;
    case "check":
      return check_intent(live_line);
      break;
    case "test":
      return test_intent(live_line);
      break;
    case "frame":
      return frame_intent(live_line);
      break;
    case "popup":
      return popup_intent(live_line);
      break;
    case "api":
      return api_intent(live_line);
      break;
    case "run":
      return run_intent(live_line);
      break;
    case "dom":
      return dom_intent(live_line);
      break;
    case "js":
      return js_intent(live_line);
      break;
    case "r":
      return r_intent(live_line);
      break;
    case "py":
      return py_intent(live_line);
      break;
    case "vision":
      return vision_intent(live_line);
      break;
    case "timeout":
      return timeout_intent(live_line);
      break;
    case "code":
      return code_intent(live_line);
      break;
    default:
      return (
        "this.echo('ERROR - cannot understand step " +
        live_line.replace(/'/g, "\\'") +
        "')"
      );
  }
}

function parse_variables(script_line) {
  // `variable` --> '+variable+'
  quote_token = "'+"; // token to alternate replacements for '+variable+'
  for (char_counter = 0; char_counter < script_line.length; char_counter++) {
    if (script_line.charAt(char_counter) == "`") {
      script_line =
        script_line.substr(0, char_counter) +
        quote_token +
        script_line.substr(char_counter + 1);
      if (quote_token == "'+") quote_token = "+'";
      else quote_token = "'+";
    }
  }
  return script_line;
}

// for live mode understanding intent of line entered
function get_intent(raw_intent) {
  var lc_raw_intent = raw_intent.toLowerCase();
  if (inside_py_block !== 0) return "py";
  if (inside_r_block !== 0) return "r";
  if (inside_run_block !== 0) return "run";
  if (inside_vision_block !== 0) return "vision";
  if (inside_js_block !== 0) return "js";
  if (inside_dom_block !== 0) return "dom";

  if (
    lc_raw_intent.substr(0, 7) == "http://" ||
    lc_raw_intent.substr(0, 8) == "https://"
  )
    return "url";

  // first set of conditions check for valid keywords with their parameters
  if (
    lc_raw_intent.substr(0, 4) == "tap " ||
    lc_raw_intent.substr(0, 6) == "click "
  )
    return "tap";
  if (
    lc_raw_intent.substr(0, 5) == "rtap " ||
    lc_raw_intent.substr(0, 7) == "rclick "
  )
    return "rtap";
  if (
    lc_raw_intent.substr(0, 5) == "dtap " ||
    lc_raw_intent.substr(0, 7) == "dclick "
  )
    return "dtap";
  if (
    lc_raw_intent.substr(0, 6) == "hover " ||
    lc_raw_intent.substr(0, 5) == "move "
  )
    return "hover";
  if (
    lc_raw_intent.substr(0, 5) == "type " ||
    lc_raw_intent.substr(0, 6) == "enter "
  )
    return "type";
  if (
    lc_raw_intent.substr(0, 7) == "select " ||
    lc_raw_intent.substr(0, 7) == "choose "
  )
    return "select";
  if (
    lc_raw_intent.substr(0, 5) == "read " ||
    lc_raw_intent.substr(0, 6) == "fetch "
  )
    return "read";
  if (
    lc_raw_intent.substr(0, 5) == "show " ||
    lc_raw_intent.substr(0, 6) == "print "
  )
    return "show";
  if (
    lc_raw_intent.substr(0, 3) == "up " ||
    lc_raw_intent.substr(0, 7) == "upload "
  )
    return "upload";
  if (
    lc_raw_intent.substr(0, 5) == "down " ||
    lc_raw_intent.substr(0, 9) == "download "
  )
    return "down";
  if (lc_raw_intent.substr(0, 8) == "receive ") return "receive";
  if (lc_raw_intent.substr(0, 5) == "echo ") return "echo";
  if (lc_raw_intent.substr(0, 5) == "save ") return "save";
  if (lc_raw_intent.substr(0, 5) == "dump ") return "dump";
  if (lc_raw_intent.substr(0, 6) == "write ") return "write";
  if (lc_raw_intent.substr(0, 5) == "load ") return "load";
  if (lc_raw_intent.substr(0, 5) == "snap ") return "snap";
  if (lc_raw_intent.substr(0, 6) == "table ") return "table";
  if (lc_raw_intent.substr(0, 5) == "wait ") return "wait";
  if (lc_raw_intent.substr(0, 5) == "live ") return "live";
  if (lc_raw_intent.substr(0, 4) == "ask ") return "ask";
  if (lc_raw_intent.substr(0, 9) == "keyboard ") return "keyboard";
  if (lc_raw_intent.substr(0, 6) == "mouse ") return "mouse";
  if (lc_raw_intent.substr(0, 6) == "check ") return "check";
  if (lc_raw_intent.substr(0, 5) == "test ") return "test";
  if (lc_raw_intent.substr(0, 6) == "frame ") return "frame";
  if (lc_raw_intent.substr(0, 6) == "popup ") return "popup";
  if (lc_raw_intent.substr(0, 4) == "api ") return "api";
  if (lc_raw_intent.substr(0, 4) == "run ") return "run";
  if (lc_raw_intent.substr(0, 4) == "dom ") return "dom";
  if (lc_raw_intent.substr(0, 3) == "js ") return "js";
  if (lc_raw_intent.substr(0, 2) == "r ") return "r";
  if (lc_raw_intent.substr(0, 3) == "py ") return "py";
  if (lc_raw_intent.substr(0, 7) == "vision ") return "vision";
  if (lc_raw_intent.substr(0, 8) == "timeout ") return "timeout";

  // second set of conditions check for valid keywords with missing parameters
  if (lc_raw_intent == "tap" || lc_raw_intent == "click") return "tap";
  if (lc_raw_intent == "rtap" || lc_raw_intent == "rclick") return "rtap";
  if (lc_raw_intent == "dtap" || lc_raw_intent == "dclick") return "dtap";
  if (lc_raw_intent == "hover" || lc_raw_intent == "move") return "hover";
  if (lc_raw_intent == "type" || lc_raw_intent == "enter") return "type";
  if (lc_raw_intent == "select" || lc_raw_intent == "choose") return "select";
  if (lc_raw_intent == "read" || lc_raw_intent == "fetch") return "read";
  if (lc_raw_intent == "show" || lc_raw_intent == "print") return "show";
  if (lc_raw_intent == "up" || lc_raw_intent == "upload") return "upload";
  if (lc_raw_intent == "down" || lc_raw_intent == "download") return "down";
  if (lc_raw_intent == "receive") return "receive";
  if (lc_raw_intent == "echo") return "echo";
  if (lc_raw_intent == "save") return "save";
  if (lc_raw_intent == "dump") return "dump";
  if (lc_raw_intent == "write") return "write";
  if (lc_raw_intent == "load") return "load";
  if (lc_raw_intent == "snap") return "snap";
  if (lc_raw_intent == "table") return "table";
  if (lc_raw_intent == "wait") return "wait";
  if (lc_raw_intent == "live") return "live";
  if (lc_raw_intent == "ask") return "ask";
  if (lc_raw_intent == "keyboard") return "keyboard";
  if (lc_raw_intent == "mouse") return "mouse";
  if (lc_raw_intent == "check") return "check";
  if (lc_raw_intent == "test") return "test";
  if (lc_raw_intent == "frame") return "frame";
  if (lc_raw_intent == "popup") return "popup";
  if (lc_raw_intent == "api") return "api";
  if (lc_raw_intent == "run") return "run";
  if (lc_raw_intent == "dom") return "dom";
  if (lc_raw_intent == "js") return "js";
  if (lc_raw_intent == "r") return "r";
  if (lc_raw_intent == "py") return "py";
  if (lc_raw_intent == "vision") return "vision";
  if (lc_raw_intent == "timeout") return "timeout";

  // final check for recognized code before returning error
  if (is_code(raw_intent)) return "code";
  else return "error";
}

function is_code(raw_intent) {
  // due to asynchronous waiting for element, if/for/while can work for parsing single step
  // other scenarios can be assumed to behave as unparsed javascript in casperjs context
  // to let if/for/while handle multiple steps/code use the { and } steps to define block
  if (raw_intent.substr(0, 4) == "var " || raw_intent.substr(0, 3) == "do ")
    return true;
  if (raw_intent.substr(0, 1) == "{" || raw_intent.substr(0, 1) == "}")
    return true;
  if (
    raw_intent.charAt(raw_intent.length - 1) == "{" ||
    raw_intent.charAt(raw_intent.length - 1) == "}"
  )
    return true;
  if (raw_intent.substr(0, 3) == "if " || raw_intent.substr(0, 4) == "else")
    return true;
  if (raw_intent.substr(0, 4) == "for " || raw_intent.substr(0, 6) == "while ")
    return true;
  if (
    raw_intent.substr(0, 7) == "switch " ||
    raw_intent.substr(0, 5) == "case "
  )
    return true;
  if (raw_intent.substr(0, 6) == "break;" || raw_intent == "break") return true;
  if (raw_intent.substr(0, 9) == "continue;" || raw_intent == "continue")
    return true;
  if (
    raw_intent.substr(0, 7) == "casper." ||
    raw_intent.substr(0, 5) == "this."
  )
    return true;
  if (raw_intent.substr(0, 7) == "chrome.") return true; // chrome object for chrome integration
  if (raw_intent.substr(0, 5) == "test" + ".") return true; // avoid replacement with test option
  if (
    raw_intent.substr(0, 2) == "//" ||
    raw_intent.charAt(raw_intent.length - 1) == ";"
  )
    return true;
  if (raw_intent.substr(0, 9) == "function ") return true; // function definition
  // assume = is assignment statement, kinda acceptable as this is checked at the very end
  if (raw_intent.indexOf("=") > -1) return true;
  return false;
}

function file_url(absolute_filename) {
  // helper function to append file:// according for opening local files
  if (!absolute_filename || absolute_filename == "") return "";
  if (absolute_filename.substr(0, 1) == "/")
    return "file://" + absolute_filename;
  if (absolute_filename.substr(1, 1) == ":")
    return "file:///" + absolute_filename;
  return absolute_filename;
}

function abs_file(filename) {
  // helper function to return absolute filename
  if (filename == "") return ""; // unlike tagui_parse.php not deriving path from script variable
  if (filename.substr(0, 1) == "/") return filename; // return mac/linux absolute filename directly
  if (filename.substr(1, 1) == ":") return filename.replace(/\\/g, "/"); // return windows absolute filename directly
  if (is_coordinates(filename)) return filename; // to handle when sikuli (x,y) coordinates locator is provided
  var tmp_flow_path = flow_path; // otherwise use flow_path defined in generated script to build absolute filename
  // above str_replace is because casperjs/phantomjs do not seem to support \ for windows paths, replace with / to work
  if (tmp_flow_path.indexOf("/") > -1)
    return (tmp_flow_path + "/" + filename).replace(/\\/g, "/");
  else return tmp_flow_path + "\\" + filename;
}

function add_concat(source_string) {
  // parse string and add missing + concatenator
  if (source_string.indexOf("'") > -1 && source_string.indexOf('"') > -1)
    return "'ERROR - inconsistent quotes in text'";
  else if (source_string.indexOf("'") > -1) var quote_type = "'";
  // derive quote type used
  else if (source_string.indexOf('"') > -1) var quote_type = '"';
  else var quote_type = "none";
  var within_quote = false;
  source_string = source_string.trim(); // trim for future proof
  for (srcpos = 0; srcpos < source_string.length; srcpos++) {
    if (source_string.charAt(srcpos) == quote_type)
      within_quote = !within_quote;
    if (within_quote == false && source_string.charAt(srcpos) == " ")
      source_string =
        source_string.substring(0, srcpos) +
        "+" +
        source_string.substring(srcpos + 1);
  }
  source_string = source_string.replace(/\+\+\+\+\+/g, "+");
  source_string = source_string.replace(/\+\+\+\+/g, "+");
  source_string = source_string.replace(/\+\+\+/g, "+");
  source_string = source_string.replace(/\+\+/g, "+");
  return source_string;
} // replacing multiple variations of + to handle user typos of double spaces etc

function escape_bs(input_string) {
  // helper function to escape backslash characters and friends
  escaped_string = input_string
    .replace(/\\/g, "\\\\")
    .replace(/\'/g, "\\'")
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r");
  return escaped_string
    .replace(/\t/g, "\\t")
    .replace(/\f/g, "\\f")
    .replace(/\v/g, "\\v")
    .replace(/\"/g, '\\"');
}

function is_coordinates(input_params) {
  // helper function to check if string is (x,y) coordinates
  if (
    input_params.length > 4 &&
    input_params.substr(0, 1) == "(" &&
    input_params.substr(-1) == ")" &&
    (input_params.split(",").length == 2 ||
      input_params.split(",").length == 3) &&
    !input_params.match(/[a-z]/i)
  )
    return true;
  else return false;
}

function is_sikuli(input_params) {
  // helper function to check if input is meant for sikuli visual automation
  if (
    input_params.length > 4 &&
    input_params.substr(-4).toLowerCase() == ".png"
  )
    return true;
  // support png and bmp
  else if (
    input_params.length > 4 &&
    input_params.substr(-4).toLowerCase() == ".bmp"
  )
    return true;
  else if (is_coordinates(input_params)) return true;
  else return false;
}

function call_sikuli(input_intent, input_params, other_actions) {
  // helper function to use sikuli visual automation
  var fs = require("fs"); // use phantomjs fs file system module to access files and directories
  fs.write("tagui.sikuli/tagui_sikuli.in", "", "w");
  fs.write("tagui.sikuli/tagui_sikuli.out", "", "w");
  if (!fs.exists("tagui.sikuli/tagui_sikuli.in"))
    return "this.echo('ERROR - cannot initialise tagui_sikuli.in')";
  if (!fs.exists("tagui.sikuli/tagui_sikuli.out"))
    return "this.echo('ERROR - cannot initialise tagui_sikuli.out')";
  if (!other_actions) other_actions = ""; // to handle most cases where other_actions is not passed in during call
  return (
    "var fs = require('fs'); if (!sikuli_step('" +
    input_intent +
    "')) if (!fs.exists('" +
    input_params +
    "')) " +
    "this.echo('ERROR - cannot find image file " +
    input_params +
    "'); " +
    "else this.echo('ERROR - cannot find " +
    input_params +
    " on screen'); " +
    other_actions
  );
}

function call_r(input_intent) {
  // helper function to use R integration for data analytics and machine learning
  var fs = require("fs"); // use phantomjs fs file system module to access files and directories
  fs.write("tagui_r/tagui_r.in", "", "w");
  fs.write("tagui_r/tagui_r.out", "", "w");
  if (!fs.exists("tagui_r/tagui_r.in"))
    return "this.echo('ERROR - cannot initialise tagui_r.in')";
  if (!fs.exists("tagui_r/tagui_r.out"))
    return "this.echo('ERROR - cannot initialise tagui_r.out')";
  return (
    "r_result = ''; if (!r_step('" +
    input_intent +
    "')) this.echo('ERROR - cannot execute R command(s)'); else {r_result = fetch_r_text(); clear_r_text(); try {r_json = JSON.parse(r_result);} catch(e) {r_json = JSON.parse('null');}}"
  );
}

function call_py(input_intent) {
  // helper function to use Python integration for data analytics and machine learning
  var fs = require("fs"); // use phantomjs fs file system module to access files and directories
  fs.write("tagui_py/tagui_py.in", "", "w");
  fs.write("tagui_py/tagui_py.out", "", "w");
  if (!fs.exists("tagui_py/tagui_py.in"))
    return "this.echo('ERROR - cannot initialise tagui_py.in')";
  if (!fs.exists("tagui_py/tagui_py.out"))
    return "this.echo('ERROR - cannot initialise tagui_py.out')";
  return (
    "py_result = ''; if (!py_step('" +
    input_intent +
    "')) this.echo('ERROR - cannot execute Python command(s)'); else {py_result = fetch_py_text(); clear_py_text(); try {py_json = JSON.parse(py_result);} catch(e) {py_json = JSON.parse('null');}}"
  );
}

function url_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  if (chrome_id == 0)
    return "this.echo('ERROR - step only supported in live mode using Chrome browser')";
  else
    return (
      'this.evaluate(function() {window.location.href = "' + raw_intent + '"})'
    );
}

function tap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params)) return "this.click(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function rtap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params))
    return "this.mouse.rightclick(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function dtap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params))
    return "this.mouse.doubleclick(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function hover_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent, abs_params);
  } // use sikuli visual automation as needed
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params)) return "this.mouse.move(tx('" + params + "'))";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function type_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" as ")).trim();
  var param2 = params.substr(4 + params.indexOf(" as ")).trim();
  if (is_sikuli(param1) && param2 !== "") {
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    return call_sikuli(abs_intent, abs_param1);
  } // use sikuli visual automation as needed
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - target/text missing for " + raw_intent + "')";
  else if (check_tx(param1)) {
    if (param2.indexOf("[clear]") == 0) {
      if (param2.length > 7) param2 = param2.substr(7);
      else param2 = "";
      clear_field = "this.sendKeys(tx('" + param1 + "'),'',{reset: true}); ";
    } else clear_field = "";
    if (param2.indexOf("[enter]") == -1)
      return (
        clear_field + "this.sendKeys(tx('" + param1 + "'),'" + param2 + "')"
      );
    // special handling to send enter key events
    else {
      param2 = param2.replace(
        /\[enter\]/g,
        "',{keepFocus: true}); this.sendKeys(tx('" +
          param1 +
          "'),casper.page.event.key.Enter,{keepFocus: true}); this.sendKeys(tx('" +
          param1 +
          "'),'"
      );
      return (
        clear_field +
        "this.sendKeys(tx('" +
        param1 +
        "'),'" +
        param2 +
        "',{keepFocus: true});"
      );
    }
  } else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function select_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" as ")).trim();
  var param2 = params.substr(4 + params.indexOf(" as ")).trim();
  if (is_sikuli(param1) && is_sikuli(param2)) {
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    var abs_param2 = abs_file(param2);
    abs_intent = abs_intent.replace(param2, abs_param2);
    return call_sikuli(abs_intent, abs_param1);
  } // use sikuli visual automation as needed
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - target/option missing for " + raw_intent + "')";
  else if (check_tx(param1))
    return (
      "var select_locator = tx('" +
      param1 +
      "'); if (is_xpath_selector(select_locator.toString().replace('xpath selector: ',''))) select_locator = select_locator.toString().substring(16); this.selectOptionByValue(select_locator,'" +
      param2 +
      "');"
    );
  else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function read_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (is_sikuli(param1) && params.indexOf(" to ") > -1) {
    // use sikuli visual automation as needed
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    return call_sikuli(
      abs_intent,
      abs_param1,
      param2 + " = fetch_sikuli_text(); clear_sikuli_text();"
    );
  }
  if (param1.toLowerCase() == "page" && param2 !== "")
    return param2 + " = this.getHTML()";
  if (param1 == "" || param2 == "")
    return (
      "this.echo('ERROR - target/variable missing for " + raw_intent + "')"
    );
  else if (check_tx(param1))
    return param2 + " =  this.fetchText(tx('" + param1 + "')).trim()";
  else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function show_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (is_sikuli(params)) {
    // use sikuli visual automation as needed
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(
      abs_intent,
      abs_params,
      "this.echo(fetch_sikuli_text()); clear_sikuli_text();"
    );
  }
  if (params.toLowerCase() == "page")
    return "this.echo('" + raw_intent + "' + ' - ' + '\\n' + this.getHTML())";
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (check_tx(params))
    return "this.echo(this.fetchText(tx('" + params + "')).trim())";
  else return "this.echo('ERROR - cannot find " + params + "')";
}

function upload_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" as ")).trim();
  var param2 = params.substr(4 + params.indexOf(" as ")).trim();
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - filename missing for " + raw_intent + "')";
  else if (check_tx(param1))
    return (
      "this.page.uploadFile(tx('" + param1 + "'),'" + abs_file(param2) + "')"
    );
  else return "this.echo('ERROR - cannot find " + param1 + "')";
}

function down_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (param1 == "" || param2 == "")
    return "this.echo('ERROR - url/filename missing for " + raw_intent + "')";
  else return "this.download('" + param1 + "','" + abs_file(param2) + "')";
}

function receive_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, it requires creating CasperJS event')";
}

function echo_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - text missing for " + raw_intent + "')";
  else return "this.echo(" + add_concat(params) + ")";
}

function save_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (is_sikuli(param1) && params.indexOf(" to ") > -1) {
    // use sikuli visual automation as needed
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    return call_sikuli(
      abs_intent,
      abs_param1,
      "save_text('" +
        abs_file(param2) +
        "',fetch_sikuli_text()); clear_sikuli_text();"
    );
  } else if (is_sikuli(params) && params.indexOf(" to ") == -1) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(
      abs_intent,
      abs_param1,
      "save_text('',fetch_sikuli_text()); clear_sikuli_text();"
    );
  }
  if (params.toLowerCase() == "page" || param1.toLowerCase() == "page") {
    if (params.indexOf(" to ") > -1)
      return "save_text('" + abs_file(param2) + "',this.getHTML())";
    else return "save_text('',this.getHTML())";
  }
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1) {
    if (check_tx(param1))
      return (
        "save_text('" +
        abs_file(param2) +
        "',this.fetchText(tx('" +
        param1 +
        "')).trim())"
      );
    else return "this.echo('ERROR - cannot find " + param1 + "')";
  } else {
    if (check_tx(params))
      return "save_text('',this.fetchText(tx('" + params + "')).trim())";
    else return "this.echo('ERROR - cannot find " + params + "')";
  }
}

function dump_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - variable missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1)
    return "save_text('" + abs_file(param2) + "'," + add_concat(param1) + ")";
  else return "save_text(''," + add_concat(params) + ")";
}

function write_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - variable missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1)
    return "append_text('" + abs_file(param2) + "'," + add_concat(param1) + ")";
  else return "append_text(''," + add_concat(params) + ")";
}

function load_intent(raw_intent) {
  // code to support dynamic variables not applicable
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - filename missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1)
    return (
      "var fs = require('fs'); " +
      param2 +
      " = ''; if (fs.exists('" +
      abs_file(param1) +
      "')) " +
      param2 +
      " = fs.read('" +
      abs_file(param1) +
      "').trim(); else this.echo('ERROR - cannot find file " +
      param1 +
      "')"
    );
  else return "this.echo('ERROR - variable missing for " + raw_intent + "')";
}

function snap_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (is_sikuli(param1) && params.indexOf(" to ") > -1) {
    var abs_param1 = abs_file(param1);
    var abs_intent = raw_intent.replace(param1, abs_param1);
    var abs_param2 = abs_file(param2);
    abs_intent = abs_intent.replace(param2, abs_param2);
    return call_sikuli(abs_intent, abs_param1);
  } // use sikuli visual automation as needed
  else if (is_sikuli(params) && params.indexOf(" to ") == -1) {
    var abs_params = abs_file(params);
    var abs_intent = raw_intent.replace(params, abs_params);
    return call_sikuli(abs_intent + " to snap_image()", abs_params);
  } // handle no output filename
  if (params.toLowerCase() == "page" || param1.toLowerCase() == "page") {
    if (params.indexOf(" to ") > -1)
      return "this.capture('" + abs_file(param2) + "')";
    else return "this.capture(snap_image())";
  }
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1) {
    if (check_tx(param1))
      return (
        "this.captureSelector('" + abs_file(param2) + "',tx('" + param1 + "'))"
      );
    else return "this.echo('ERROR - cannot find " + param1 + "')";
  } else {
    if (check_tx(params))
      return "this.captureSelector(snap_image(),tx('" + params + "'))";
    else return "this.echo('ERROR - cannot find " + params + "')";
  }
}

function table_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  var param1 = params.substr(0, params.indexOf(" to ")).trim();
  var param2 = params.substr(4 + params.indexOf(" to ")).trim();
  if (params == "")
    return "this.echo('ERROR - target missing for " + raw_intent + "')";
  else if (params.indexOf(" to ") > -1) {
    if (check_tx(param1))
      return "save_table('" + abs_file(param2) + "',tx('" + param1 + "'))";
    else return "this.echo('ERROR - cannot find " + param1 + "')";
  } else {
    if (check_tx(params)) return "save_table('',tx('" + params + "'))";
    else return "this.echo('ERROR - cannot find " + params + "')";
  }
}

function wait_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - waiting for some time is not relevant in live mode')";
}

function live_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - you are already in live mode, type done to quit live mode')";
}

function ask_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step is not relevant in live mode, set ask_result directly')";
}

function keyboard_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - keys to type missing for " + raw_intent + "')";
  else return call_sikuli(raw_intent, params);
}

function mouse_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - down / up missing for " + raw_intent + "')";
  else if (params.toLowerCase() == "down")
    return call_sikuli(raw_intent, "down");
  else if (params.toLowerCase() == "up") return call_sikuli(raw_intent, "up");
  else return "this.echo('ERROR - cannot understand step " + raw_intent + "')";
}

function check_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, there is no conditions language parser')";
}

function test_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return (
    "this.echo('ERROR - use CasperJS tester module to professionally " +
    raw_intent +
    "\\nERROR - info at http://docs.casperjs.org/en/latest/modules/tester.html\\nERROR - support CSS selector or tx(\\'selector\\') for XPath algo by TagUI')"
  );
}

function frame_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, it is meant for trying single steps')";
}

function popup_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, it is meant for trying single steps')";
}

function api_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - API URL missing for " + raw_intent + "')";
  else
    return (
      "api_result = ''; api_result = call_api('" +
      params +
      "'); " +
      "try {api_json = JSON.parse(api_result);} catch(e) {api_json = JSON.parse('null');}"
    );
}

function run_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  return "this.echo('ERROR - step not supported in live mode, as run output cannot be retrieved')";
}

function dom_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "dom begin") {
    inside_dom_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "dom finish") {
    inside_dom_block = 0;
    return "";
  }
  if (inside_dom_block == 1) raw_intent = "dom " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - statement missing for " + raw_intent + "')";
  else
    return (
      "dom_result = ''; dom_result = this.evaluate(function(dom_json) {" +
      params +
      "}, dom_json)"
    );
}

function js_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "js begin") {
    inside_js_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "js finish") {
    inside_js_block = 0;
    return "";
  }
  if (inside_js_block == 1) raw_intent = "js " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - statement missing for " + raw_intent + "')";
  else return check_chrome_context(params);
}

function r_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "r begin") {
    inside_r_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "r finish") {
    inside_r_block = 0;
    return "";
  }
  if (inside_r_block == 1) raw_intent = "r " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return "this.echo('ERROR - R command(s) missing for " + raw_intent + "')";
  else return call_r(raw_intent.replace(/\\/g, "\\\\").replace(/'/g, "\\'"));
}

function py_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "py begin") {
    inside_py_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "py finish") {
    inside_py_block = 0;
    return "";
  }
  if (inside_py_block == 1) raw_intent = "py " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return (
      "this.echo('ERROR - Python command(s) missing for " + raw_intent + "')"
    );
  else return call_py(raw_intent.replace(/\\/g, "\\\\").replace(/'/g, "\\'"));
}

function vision_intent(raw_intent) {
  // code to support dynamic variables not applicable
  if (raw_intent.toLowerCase() == "vision begin") {
    inside_vision_block = 1;
    return "";
  } else if (raw_intent.toLowerCase() == "vision finish") {
    inside_vision_block = 0;
    return "";
  }
  if (inside_vision_block == 1) raw_intent = "vision " + raw_intent;
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return (
      "this.echo('ERROR - Sikuli command(s) missing for " + raw_intent + "')"
    );
  else
    return call_sikuli(
      raw_intent.replace(/\\/g, "\\\\").replace(/'/g, "\\'"),
      "for vision step"
    );
}

function timeout_intent(raw_intent) {
  raw_intent = eval("'" + escape_bs(raw_intent) + "'"); // support dynamic variables
  var params = (raw_intent + " ")
    .substr(1 + (raw_intent + " ").indexOf(" "))
    .trim();
  if (params == "")
    return (
      "this.echo('ERROR - time in seconds missing for " + raw_intent + "')"
    );
  else
    return check_chrome_context(
      "casper.options.waitTimeout = " +
        (parseFloat(params) * 1000).toString() +
        "; sikuli_timeout(" +
        parseFloat(params).toString() +
        ");"
    );
}

function code_intent(raw_intent) {
  // code to support dynamic variables not applicable
  return check_chrome_context(raw_intent);
}

function check_chrome_context(source_code) {
  // function to convert javascript code to chrome context
  // specifically for live mode, as statements in flow file are already converted by tagui_parse.php
  if (chrome_id == 0) return source_code; // if chrome or headless option is used, chrome_id will be > 0
  source_code = source_code
    .replace(/casper\.exists/g, "chrome.exists")
    .replace(/this\.exists/g, "chrome.exists");
  source_code = source_code
    .replace(/casper\.click/g, "chrome.click")
    .replace(/this\.click/g, "chrome.click");
  source_code = source_code
    .replace(/casper\.mouse/g, "chrome.mouse")
    .replace(/this\.mouse/g, "chrome.mouse");
  source_code = source_code
    .replace(/casper\.sendKeys/g, "chrome.sendKeys")
    .replace(/this\.sendKeys/g, "chrome.sendKeys");
  source_code = source_code
    .replace(/casper\.selectOptionByValue/g, "chrome.selectOptionByValue")
    .replace(/this\.selectOptionByValue/g, "chrome.selectOptionByValue");
  source_code = source_code
    .replace(/casper\.countElements/g, "chrome.countElements")
    .replace(/this\.countElements/g, "chrome.countElements");
  source_code = source_code
    .replace(/casper\.elementVisible/g, "chrome.elementVisible")
    .replace(/this\.elementVisible/g, "chrome.elementVisible");
  source_code = source_code
    .replace(/casper\.fetchText/g, "chrome.fetchText")
    .replace(/this\.fetchText/g, "chrome.fetchText");
  source_code = source_code
    .replace(/casper\.capture/g, "chrome.capture")
    .replace(/this\.capture/g, "chrome.capture");
  source_code = source_code
    .replace(/casper\.captureSelector/g, "chrome.captureSelector")
    .replace(/this\.captureSelector/g, "chrome.captureSelector");
  source_code = source_code
    .replace(/chrome\.page\.uploadFile/g, "chrome.upload")
    .replace(/casper\.page\.uploadFile/g, "chrome.upload")
    .replace(/this\.page\.uploadFile/g, "chrome.upload");
  source_code = source_code
    .replace(/casper\.download/g, "chrome.download")
    .replace(/this\.download/g, "chrome.download");
  source_code = source_code
    .replace(/casper\.evaluate/g, "chrome.evaluate")
    .replace(/this\.evaluate/g, "chrome.evaluate");
  source_code = source_code
    .replace(/casper\.getHTML/g, "chrome.getHTML")
    .replace(/this\.getHTML/g, "chrome.getHTML");
  source_code = source_code
    .replace(/casper\.getTitle/g, "chrome.getTitle")
    .replace(/this\.getTitle/g, "chrome.getTitle");
  source_code = source_code
    .replace(/casper\.getCurrentUrl/g, "chrome.getCurrentUrl")
    .replace(/this\.getCurrentUrl/g, "chrome.getCurrentUrl");
  source_code = source_code
    .replace(/casper\.debugHTML/g, "chrome.debugHTML")
    .replace(/this\.debugHTML/g, "chrome.debugHTML");
  source_code = source_code
    .replace(/casper\.reload/g, "chrome.reload")
    .replace(/this\.reload/g, "chrome.reload");
  source_code = source_code
    .replace(/casper\.back/g, "chrome.back")
    .replace(/this\.back/g, "chrome.back");
  source_code = source_code
    .replace(/casper\.forward/g, "chrome.forward")
    .replace(/this\.forward/g, "chrome.forward");
  return source_code;
}

// for calling rest api url synchronously
function call_api(rest_url) {
  // advance users can define api_config for advance calls
  // the api_config variable defaults to {method:'GET', header:[], body:{}}
  var xhttp = new XMLHttpRequest();
  xhttp.open(api_config.method, rest_url, false);
  for (var item = 0; item < api_config.header.length; item++) {
    // process headers
    if (api_config.header[item] == "") continue; // skip if header is not defined
    var header_value_pair = api_config.header[item].split(":"); // format is 'Header_name: header_value'
    xhttp.setRequestHeader(
      header_value_pair[0].trim(),
      header_value_pair[1].trim()
    );
  }
  xhttp.send(JSON.stringify(api_config.body));
  return xhttp.responseText;
}

// custom function to handle dropdown option
casper.selectOptionByValue = function(selector, valueToMatch) {
  // solution posted in casperjs issue #1390
  this.evaluate(
    function(selector, valueToMatch) {
      var found = false; // modified to allow xpath / css locators
      if (selector.indexOf("/") == 0 || selector.indexOf("(") == 0)
        var select = __utils__.getElementByXPath(selector);
      else var select = document.querySelector(selector); // auto-select xpath or query css method to get element
      if (valueToMatch == "[clear]") valueToMatch = ""; // [clear] keyword to allow selecting empty / blank option
      Array.prototype.forEach.call(select.children, function(opt, i) {
        // loop through list to select option
        if (!found && opt.value.indexOf(valueToMatch) !== -1) {
          select.selectedIndex = i;
          found = true;
        }
      });
      var evt = document.createEvent("UIEvents"); // dispatch change event in case there is validation
      evt.initUIEvent("change", true, true);
      select.dispatchEvent(evt);
    },
    selector,
    valueToMatch
  );
};

// custom function to return element visibility
casper.elementVisible = function(selector) {
  return casper.visible(selector);
}; // use casperjs to maximize compatibility

// custom function to return element count
casper.countElements = function(selector) {
  // use casperjs in-built function to maximize compatibility
  var count_result = casper.evaluate(function(selector) {
    return __utils__.findAll(selector).length;
  }, selector);
  try {
    if (count_result > 0) return count_result;
    else return 0;
  } catch (e) {
    return 0;
  }
};

// custom function from casperjs v1.1.5 (not yet released)
casper.waitForExec = function(command, parameters, then, onTimeout, timeout) {
  "use strict";
  var killTimeout;
  var utils = require("utils");
  var f = utils.format; // custom added line from casper.js global
  if (utils.isArray(timeout)) {
    killTimeout = utils.isNumber(timeout[1])
      ? getTimeoutAndCheckNextStepFunction(
          timeout[1],
          then,
          "waitForExec",
          this.options.waitTimeout
        )
      : getTimeoutAndCheckNextStepFunction(
          timeout[0],
          then,
          "waitForExec",
          this.options.waitTimeout
        );
    timeout = getTimeoutAndCheckNextStepFunction(
      timeout[0],
      then,
      "waitForExec",
      this.options.waitTimeout
    );
  } else {
    timeout = getTimeoutAndCheckNextStepFunction(
      timeout,
      then,
      "waitForExec",
      this.options.waitTimeout
    );
    killTimeout = timeout;
  }

  if (!utils.isString(command) && !utils.isArray(parameters)) {
    throw new CasperError(
      "waitForExec() needs an command string as program and parameters separated by space to run or an array of parameters. if program is falsy or not a string, it uses default system shell"
    );
  }
  if (utils.isFalsy(command) || !utils.isString(command)) {
    var system = require("system");
    command = system.env.SHELL || system.env.ComSpec; // SHELL for UNIX(?), ComSpec for Windows(?)
    this.log(
      "Casper.waitForExec()  is going to use default system shell " +
        JSON.stringify(command) +
        " - command is falsy or is not a string",
      "warning"
    );
  }
  if (utils.isFalsy(parameters) || !utils.isArray(parameters)) {
    parameters = [];
  }

  // add use of a escape char like '\'??? (e.g.: '/bin/bash -c {\ ls\ /\ &&\ ls\ /home\ }' becomes ['/bin/bash', '-c', '{ ls / && ls /home }']
  command = command.split(" ");
  parameters = command.splice(1, command.length - 1).concat(parameters);
  command = command[0];
  var fs = require("fs");
  if (!fs.isExecutable(command)) {
    this.log(
      "Casper.waitForExec() is going to call non executable file " +
        JSON.stringify(command) +
        " - maybe runs if is in PATH",
      "warning"
    );
  }

  var spawn = require("child_process").spawn;
  var stdout = ""; // VARIABLE TO STORE PROGRAM STDOUT
  var stderr = ""; // VARIABLE TO STORE PROGRAM STDERR
  var exitCode = null; // VARIABLE TO STORE PROGRAM EXIT CODE
  var realPid = null; // VARIABLE TO STORE PROGRAM REAL PID
  var elapsedTime = null; // VARIABLE TO STORE PROGRAM DURATION
  var childStartTime = new Date().getTime();
  var child = spawn(command, parameters);
  realPid = child.pid;

  child.stdout.on("data", function(standardOut) {
    // keeps stdout updated
    stdout += standardOut;
  });
  child.stderr.on("data", function(standardError) {
    // keeps stderr updated
    stderr += standardError;
  });
  child.on("exit", function(code) {
    elapsedTime = new Date().getTime() - childStartTime;
    exitCode = code;
  });

  function __details() {
    return {
      data: {
        command: command,
        parameters: parameters,
        pid: realPid,
        stdout: stdout,
        stderr: stderr,
        exitCode: exitCode,
        elapsedTime: elapsedTime,
        isChildNotFinished: exitCode == null
      }
    };
  }
  function __onTimeout(timeout, details) {
    var __onWaitTimeout = onTimeout ? onTimeout : this.options.onWaitTimeout;
    var signalToKill = "SIGTERM";
    child.kill(signalToKill);

    killTimeout = getTimeoutAndCheckNextStepFunction(
      killTimeout,
      __onWaitTimeout,
      "killAndCallOnWaitTimeout",
      this.options.waitTimeout,
      false
    );
    (function killAndCallOnWaitTimeout() {
      this.waitFor(
        function isProgramKilled() {
          // HAVE TO ADD waitFor() TO MAKE child.on("exit"... UPDATES exitCode AND TO child.pid BE UPDATED
          return exitCode != null;
        },
        function onProgramKilled() {
          this.log(
            f(
              "waitForExec() has killed %s %s (PID %d) with %s",
              details.data.command,
              JSON.stringify(details.data.parameters),
              details.data.pid,
              signalToKill
            ),
            "info"
          );
          // this.then(this.createStep(__onWaitTimeout, timeout, __details()));
          __onWaitTimeout.call(this, timeout, __details());
        },
        function onProgramNotKilled() {
          this.log(
            f(
              "waitForExec() has not killed %s %s (PID %d) with %s",
              details.data.command,
              JSON.stringify(details.data.parameters),
              details.data.pid,
              signalToKill
            ),
            "warning"
          );
          signalToKill =
            require("system").os.name !== "windows" ? "SIGKILL" : "WM_QUIT"; // "WM_QUIT" SEEMS TO BE THE WINDOWS EQUIVALENT TO UNIX SIGKILL
          child.kill(signalToKill);
          killTimeout = 1;
          killAndCallOnWaitTimeout.call(this);
        },
        killTimeout
      );
    }.call(this));
  }
  this.log(
    f(
      "waitForExec() called %s (PID %d) with %s arguments",
      JSON.stringify(command),
      realPid,
      JSON.stringify(parameters)
    ),
    "info"
  );
  return this.waitFor(
    function isProgramFinished() {
      return exitCode != null;
    },
    function onProgramFinished() {
      this.then(this.createStep(then, __details()));
    },
    __onTimeout,
    timeout,
    __details()
  );
};

// dependency function of casper.waitForExec in v1.1.5 (not yet released)
function getTimeoutAndCheckNextStepFunction(
  timeout,
  then,
  methodName,
  defaultTimeout,
  isThenRequired
) {
  var utils = require("utils"); // custom added line from casper.js global
  if (isThenRequired || then) {
    var isFunction = utils.isFunction(then); // Optimization to perform "isFunction" check only once.

    if (isThenRequired && !isFunction) {
      throw new CasperError(methodName + "() needs a step function");
    } else if (then && !isFunction) {
      throw new CasperError(
        methodName + "() next step definition must be a function"
      );
    }
  }

  timeout = ~~timeout || ~~defaultTimeout;
  if (timeout < 0) {
    throw new CasperError(
      methodName + "() only accepts an integer >= 0 as a timeout value"
    );
  }

  return timeout;
}

// global try-catch for catching unexpected and unhandled errors, eg referencing an undeclared variable
phantom.onError = function(msg, trace) {
  if (msg.indexOf("Error:") !== -1) {
    // clean up and format error message
    msg = msg.substring(msg.indexOf("Error:") + 6).trim();
    msg = msg.charAt(0).toLowerCase() + msg.slice(1);
  }
  casper.echo("ERROR - " + msg).exit();
};

```
